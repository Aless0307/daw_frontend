{
    "sourceFile": "src/components/BraillePassword.jsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1744949743938,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1744949743938,
            "name": "Commit-0",
            "content": "import React, { useState, useEffect, useRef } from 'react';\nimport { config } from '../config';\nimport './BraillePassword.css';\nimport { speakWithPolly } from '../services/pollyService';\nimport { playBeep, playPredefinedMessage } from '../services/audioService';\n\n// Función para convertir un array de puntos a su descripción verbal\nconst getDotsDescription = (dots) => {\n    if (!dots || dots.length === 0) return '';\n    \n    if (dots.length === 1) {\n        return `punto ${dots[0]}`;\n    } else if (dots.length === 2) {\n        return `puntos ${dots[0]} y ${dots[1]}`;\n    } else {\n        const lastDot = dots[dots.length - 1];\n        const initialDots = dots.slice(0, -1).join(', ');\n        return `puntos ${initialDots} y ${lastDot}`;\n    }\n};\n\nconst BraillePassword = ({ onPasswordComplete }) => {\n    const [activeDots, setActiveDots] = useState([]);\n    const [password, setPassword] = useState('');\n    const [displayPassword, setDisplayPassword] = useState('');\n    const [listening, setListening] = useState(false);\n    const [message, setMessage] = useState('');\n    const [currentCharacter, setCurrentCharacter] = useState('');\n    const [status, setStatus] = useState('waiting'); // waiting, listening, processing, completed\n    // Nuevo estado para almacenar las combinaciones de puntos usadas\n    const [dotCombinations, setDotCombinations] = useState([]);\n    // Estados para la funcionalidad de edición\n    const [editMode, setEditMode] = useState(false); // Modo de edición activado/desactivado\n    const [editPosition, setEditPosition] = useState(-1); // Posición que se está editando (base 0)\n    const [editStep, setEditStep] = useState('none'); // none, askPosition, editingPosition, confirmEdit\n    // Nuevo estado para controlar si ya se reprodujeron las instrucciones de edición\n    const [playedEditInstructions, setPlayedEditInstructions] = useState(false);\n    // Nuevo estado para controlar si ya se reprodujo el prompt de posición\n    const [playedPositionPrompt, setPlayedPositionPrompt] = useState(false);\n    \n    const audioRef = useRef(null);\n    \n    // Referencias para almacenar los valores más recientes\n    const currentCharRef = useRef('');\n    const passwordRef = useRef('');\n    const displayPasswordRef = useRef('');\n    const dotCombinationsRef = useRef([]);\n    // Referencias para la edición\n    const editModeRef = useRef(false);\n    const editPositionRef = useRef(-1);\n    const editStepRef = useRef('none');\n    // Referencia para el estado del prompt de posición\n    const playedPositionPromptRef = useRef(false);\n    \n    // Efecto para mantener las referencias actualizadas con los estados\n    useEffect(() => {\n        currentCharRef.current = currentCharacter;\n    }, [currentCharacter]);\n    \n    useEffect(() => {\n        passwordRef.current = password;\n    }, [password]);\n    \n    useEffect(() => {\n        displayPasswordRef.current = displayPassword;\n    }, [displayPassword]);\n    \n    useEffect(() => {\n        dotCombinationsRef.current = dotCombinations;\n    }, [dotCombinations]);\n    \n    // Comprobar si estamos en modo de edición\n    useEffect(() => {\n        editModeRef.current = editMode;\n    }, [editMode]);\n    \n    useEffect(() => {\n        editPositionRef.current = editPosition;\n    }, [editPosition]);\n    \n    useEffect(() => {\n        editStepRef.current = editStep;\n    }, [editStep]);\n\n    // Actualizar la referencia del estado del prompt de posición\n    useEffect(() => {\n        playedPositionPromptRef.current = playedPositionPrompt;\n    }, [playedPositionPrompt]);\n\n    // Mapeo de combinaciones braille a caracteres (simplificado)\n    const brailleMap = {\n        '1': 'a', '12': 'b', '14': 'c', '145': 'd', '15': 'e',\n        '124': 'f', '1245': 'g', '125': 'h', '24': 'i', '245': 'j',\n        '13': 'k', '123': 'l', '134': 'm', '1345': 'n', '135': 'o',\n        '1234': 'p', '12345': 'q', '1235': 'r', '234': 's', '2345': 't',\n        '136': 'u', '1236': 'v', '2456': 'w', '1346': 'x', '13456': 'y', '1356': 'z',\n        '3456': '#', 'numero_16': '1', 'numero_126': '2', 'numero_146': '3', 'numero_1456': '4', 'numero_156': '5',\n        'numero_1246': '6', 'numero_12456': '7', 'numero_1256': '8', 'numero_246': '9', 'numero_2456': '0'\n    };\n\n    // Referencia al reconocimiento de voz\n    const recognitionRef = useRef(null);\n\n    // Inicializar reconocimiento de voz\n    useEffect(() => {\n        console.log(\"====== Inicializando componente BraillePassword ======\");\n        // Verificar si el navegador soporta reconocimiento de voz\n        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {\n            setMessage('El reconocimiento de voz no es compatible con este navegador.');\n            return;\n        }\n        \n\n        // Crear instancia de reconocimiento de voz\n        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n        recognitionRef.current = new SpeechRecognition();\n        recognitionRef.current.lang = 'es-ES';\n        recognitionRef.current.continuous = true;\n        recognitionRef.current.interimResults = false;\n\n        // Configurar eventos\n        recognitionRef.current.onresult = handleSpeechResult;\n        recognitionRef.current.onerror = (event) => {\n            console.error('Error en reconocimiento de voz:', event.error);\n            setMessage(`Error en reconocimiento: ${event.error}. Puedes usar los botones en pantalla.`);\n            \n            // Si es un error no fatal, intentar reiniciar después de un tiempo\n            if (event.error !== 'not-allowed' && event.error !== 'service-not-allowed') {\n                setTimeout(() => {\n                    if (listening) {\n                        try {\n                            startListening();\n                        } catch (e) {\n                            console.error('Error al reintentar reconocimiento:', e);\n                        }\n                    }\n                }, 2000);\n            } else {\n                setListening(false);\n            }\n        };\n        recognitionRef.current.onend = () => {\n            if (listening) {\n                try {\n                    recognitionRef.current.start();\n                } catch (error) {\n                    console.error('Error al reiniciar reconocimiento:', error);\n                    setListening(false);\n                    setMessage('Error al reiniciar escucha. Inténtalo manualmente.');\n                }\n            }\n        };\n\n        // Usar setTimeout para dar tiempo a que otros componentes se inicialicen completamente\n        // y evitar conflictos con otros reconocimientos de voz\n        const timeoutId = setTimeout(() => {\n            const initializeBraillePassword = async () => {\n                try {\n                    console.log(\"🚀 Iniciando secuencia de instrucciones de BraillePassword\");\n                    \n                    // Detener cualquier síntesis de voz en curso\n                    window.speechSynthesis.cancel();\n\n                    // Pequeña pausa inicial\n                    await new Promise(resolve => setTimeout(resolve, 500));\n                    \n                    // Usar síntesis de voz en lugar de audio pregrabado para evitar errores\n                    await speakMessage(\"Bienvenido al sistema de contraseña Braille. A continuación te explicaré cómo funciona.\");\n                    \n                    await new Promise(resolve => setTimeout(resolve, 300));\n                    \n                    await speakMessage(\"Para crear tu contraseña, debes indicar qué puntos del patrón braille deseas activar. Utiliza los números del 1 al 6 para referirte a las posiciones.\");\n                    \n                    await new Promise(resolve => setTimeout(resolve, 300));\n                    \n                    await speakMessage(\"Di 'siguiente' para confirmar un carácter, 'borrar' para eliminar el último, o 'he terminado' cuando hayas completado tu contraseña.\");\n                    \n                    // Iniciar el reconocimiento de voz\n                    setStatus('listening');\n                    setMessage('Escuchando comandos braille...');\n                    console.log(\"🎧 Iniciando reconocimiento de voz para comandos braille\");\n                    startListening();\n                } catch (error) {\n                    console.error('Error durante la inicialización de BraillePassword:', error);\n                    setMessage('Error en la inicialización. Por favor, intenta hablar ahora.');\n                }\n            };\n            \n            initializeBraillePassword();\n        }, 1000); // Esperar 1 segundo antes de iniciar la secuencia\n\n        return () => {\n            console.log(\"⚠️ Limpiando componente BraillePassword\");\n            clearTimeout(timeoutId);\n            if (recognitionRef.current) {\n                try {\n                    recognitionRef.current.stop();\n                } catch (error) {\n                    console.error('Error al detener reconocimiento:', error);\n                }\n            }\n            \n            // Limpiar cualquier audio en reproducción\n            if (audioRef.current) {\n                audioRef.current.pause();\n                audioRef.current = null;\n            }\n            \n            // Cancelar cualquier síntesis de voz pendiente\n            window.speechSynthesis.cancel();\n        };\n    }, []);\n\n    // Función para hablar un mensaje usando síntesis de voz\n    const speakMessage = (text) => {\n        return new Promise((resolve) => {\n            try {\n                // Si hay alguna síntesis en curso, cancelarla\n                window.speechSynthesis.cancel();\n                \n                // Verificar si el navegador está en modo de ahorro de energía \n                // o si la página no está activa\n                if (document.hidden) {\n                    console.log('Página no visible, omitiendo síntesis de voz');\n                    resolve();\n                    return;\n                }\n                \n                const utterance = new SpeechSynthesisUtterance(text);\n                utterance.lang = 'es-ES';\n                utterance.rate = 0.9; // Hablar un poco más lento para mayor claridad\n                utterance.volume = 1.0; // Volumen máximo\n                \n                utterance.onend = () => {\n                    console.log(`Mensaje completado: ${text}`);\n                    resolve();\n                };\n                \n                utterance.onerror = (event) => {\n                    console.error('Error en síntesis de voz:', event);\n                    // No mostrar error al usuario para evitar interrupciones\n                    resolve(); // Resolver la promesa incluso si hay error\n                };\n                \n                // Usar setTimeout para evitar problemas de concurrencia\n                setTimeout(() => {\n                    try {\n                        window.speechSynthesis.speak(utterance);\n                    } catch (err) {\n                        console.error('Error al iniciar síntesis:', err);\n                        resolve();\n                    }\n                }, 300); // Aumentar el retraso para dar más tiempo al navegador\n            } catch (error) {\n                console.error('Error general en síntesis de voz:', error);\n                resolve(); // Resolver la promesa incluso con errores\n            }\n        });\n    };\n\n    // Función para manejar los resultados del reconocimiento de voz\n    const handleSpeechResult = (event) => {\n        const last = event.results.length - 1;\n        const command = event.results[last][0].transcript.trim().toLowerCase();\n        \n        console.log('Comando reconocido:', command);\n        \n        // Primero comprobar si es un comando de edición\n        if (handleEditCommands(command)) {\n            // Si el comando fue manejado por la lógica de edición, terminar aquí\n            return;\n        }\n        \n        // Comprobar si el usuario dice \"he terminado\"\n        if (command.includes('terminado') || command.includes('he terminado') || command.includes('finalizar') || command.includes('fin')) {\n            completePassword();\n            return;\n        }\n        \n        // Primero procesar el comando para activar puntos y luego comprobar si el usuario dice \"siguiente\"\n        // Verificar si el comando incluye la palabra \"número\" o \"numero\"\n        const isNumberInput = command.includes('número') || command.includes('numero');\n        const hasSiguienteCommand = command.includes('siguiente') || command.includes('confirmar') || command.includes('aceptar') || \n                                    command.includes('ok') || command.includes('añadir') || command.includes('agregar');\n        \n        // Detectar números individuales expresados como texto primero\n        // Esta verificación se mueve hacia arriba para darle prioridad\n        if (command.includes('uno') && !command.includes('dos') && !command.includes('tres') && \n            !command.includes('cuatro') && !command.includes('cinco') && !command.includes('seis')) {\n            handleNumberCombination([1], isNumberInput);\n            return;\n        }\n        if (command.includes('dos') && !command.includes('uno') && !command.includes('tres') && \n            !command.includes('cuatro') && !command.includes('cinco') && !command.includes('seis')) {\n            handleNumberCombination([2], isNumberInput);\n            return;\n        }\n        if (command.includes('tres') && !command.includes('uno') && !command.includes('dos') && \n            !command.includes('cuatro') && !command.includes('cinco') && !command.includes('seis')) {\n            handleNumberCombination([3], isNumberInput);\n            return;\n        }\n        if (command.includes('cuatro') && !command.includes('uno') && !command.includes('dos') && \n            !command.includes('tres') && !command.includes('cinco') && !command.includes('seis')) {\n            handleNumberCombination([4], isNumberInput);\n            return;\n        }\n        if (command.includes('cinco') && !command.includes('uno') && !command.includes('dos') && \n            !command.includes('tres') && !command.includes('cuatro') && !command.includes('seis')) {\n            handleNumberCombination([5], isNumberInput);\n            return;\n        }\n        if (command.includes('seis') && !command.includes('uno') && !command.includes('dos') && \n            !command.includes('tres') && !command.includes('cuatro') && !command.includes('cinco')) {\n            handleNumberCombination([6], isNumberInput);\n            return;\n        }\n        \n        // Detección mejorada para un solo número (1-6) en el comando\n        if (/^[1-6]$/.test(command) || command === \"un\" || command === \"uno\") {\n            let num = command === \"uno\" || command === \"un\" ? 1 : parseInt(command);\n            console.log(\"Número individual detectado:\", num);\n            handleNumberCombination([num], isNumberInput);\n            return;\n        }\n        \n        // Detectar números agrupados sin espacios (como \"2456\")\n        // Solución 1: Buscar secuencias de dígitos\n        const groupedNumbers = command.match(/\\d{2,}/g);\n        if (groupedNumbers && groupedNumbers.length > 0) {\n            console.log(\"Detectada secuencia de dígitos:\", groupedNumbers[0]);\n            const rawDigits = command.replace(/\\D/g, '');\n            const digits = rawDigits.split('').map(Number).filter(d => d >= 1 && d <= 6);\n\n            if (digits.length > 0) {\n                console.log(\"Dígitos válidos:\", digits);\n                \n                // Manejar combinación y después ejecutar comando \"siguiente\" si está presente\n                handleNumberCombination(digits, isNumberInput);\n                \n                if (hasSiguienteCommand) {\n                    // Usar un retraso mayor para asegurar que la actualización de estado se complete\n                    setTimeout(() => {\n                        console.log(\"Comando de confirmación detectado después de dígitos\");\n                        console.log(\"Estado antes de confirmar:\", currentCharacter, \"Referencia:\", currentCharRef.current);\n                        confirmCharacter();\n                    }, 800); // Aumentar el retraso para dar más tiempo a que se actualice el estado\n                }\n                return;\n            }\n        }\n        \n        // Solución 2: Si no hay agrupados, intentar extraer todos los dígitos del comando\n        if (!groupedNumbers) {\n            const allDigits = command.match(/\\d/g);\n            if (allDigits && allDigits.length > 0) {\n                console.log(\"Extrayendo todos los dígitos del comando:\", allDigits);\n                const digits = allDigits.map(d => parseInt(d)).filter(d => d >= 1 && d <= 6);\n                if (digits.length > 0) {\n                    console.log(\"Dígitos válidos:\", digits);\n                    \n                    // Manejar combinación y después ejecutar comando \"siguiente\" si está presente\n                    handleNumberCombination(digits, isNumberInput);\n                    \n                    if (hasSiguienteCommand) {\n                        // Usar un retraso mayor para asegurar que la actualización de estado se complete\n                        setTimeout(() => {\n                            console.log(\"Comando de confirmación detectado después de dígitos\");\n                            console.log(\"Estado antes de confirmar:\", currentCharacter, \"Referencia:\", currentCharRef.current);\n                            confirmCharacter();\n                        }, 800); // Aumentar el retraso para dar más tiempo a que se actualice el estado\n                    }\n                    return;\n                }\n            }\n        }\n        \n        // Normalizar el comando para evitar problemas con espacios y comas\n        let normalizedCommand = command\n        .replace(/uno/g, '1')\n        .replace(/dos/g, '2')\n        .replace(/tres/g, '3')\n        .replace(/cuatro/g, '4')\n        .replace(/cinco/g, '5')\n        .replace(/seis/g, '6')\n        .replace(/,/g, '')\n        .replace(/ /g, '');\n      \n\n        // Comprobar si el usuario dice \"siguiente\" o similar\n        if (hasSiguienteCommand) {\n            console.log(\"Comando de confirmación detectado\");\n            confirmCharacter();\n            return;\n        }\n        \n        // Comprobar si el usuario dice \"borrar\" o similar\n        if (command.includes('borrar') || command.includes('eliminar') || command.includes('quitar') || \n            command.includes('suprimir') || command.includes('remover')) {\n            console.log(\"Comando de borrado detectado\");\n            deleteLastCharacter();\n            return;\n        }\n        \n        // Comprobar si el usuario dice \"ayuda\"\n        if (command.includes('ayuda') || command.includes('help') || command.includes('instrucciones')) {\n            playAudio('brailleHelp');\n            return;\n        }\n        \n        // Comprobar si el usuario dice \"reiniciar\"\n        if (/^[1-6]+$/.test(normalizedCommand)) {\n            const digits = normalizedCommand.split('').map(Number);\n            console.log(\"Combinación reconocida:\", digits);\n            handleNumberCombination(digits, isNumberInput);\n        \n            if (hasSiguienteCommand) {\n                setTimeout(() => {\n                    confirmCharacter();\n                }, 800);\n            }\n            return;\n        }\n        \n        \n        // Intentar reconocer números del 1 al 6 (con diversos separadores)\n        // Esta expresión regular buscará dígitos del 1 al 6, separados por espacios, comas, \"y\", etc.\n        const numberRegex = /\\b[1-6]\\b/g;\n        const numbers = command.match(numberRegex);\n        \n        if (numbers && numbers.length > 0) {\n            console.log(\"Números separados encontrados:\", numbers);\n            const uniqueNumbers = [...new Set(numbers.map(n => parseInt(n)))].sort();\n            \n            // Verificar que todos los números estén entre 1 y 6\n            const validNumbers = uniqueNumbers.filter(n => n >= 1 && n <= 6);\n            \n            if (validNumbers.length > 0) {\n                console.log(\"Números válidos separados:\", validNumbers);\n                handleNumberCombination(validNumbers, isNumberInput);\n                return;\n            }\n        }\n        \n        // Si llegamos aquí, no hemos reconocido ningún comando o número válido\n        playAudio('notUnderstood');\n    };\n    \n    // Manejar combinación de números\n    const handleNumberCombination = (numbers, isNumberInput = false) => {\n        if (numbers.length === 0) return;\n        \n        console.log(\"handleNumberCombination - Recibidos:\", numbers, \"isNumberInput:\", isNumberInput);\n        \n        // Solo permitir números del 1 al 6\n        const validNumbers = numbers.filter(num => num >= 1 && num <= 6);\n        \n        if (validNumbers.length === 0) return;\n        \n        // Actualizar los puntos activos\n        setActiveDots(validNumbers);\n        \n        // Generar la clave para el mapa braille\n        let dotKey = validNumbers.sort().join('');\n        console.log(\"Clave generada:\", dotKey);\n        \n        // Si se mencionó \"número\", añadir el prefijo\n        if (isNumberInput) {\n            dotKey = 'numero_' + dotKey;\n            console.log(\"Clave con prefijo:\", dotKey);\n        }\n        \n        // Validar si la combinación existe en el mapa\n        const characterFound = brailleMap[dotKey];\n        if (characterFound) {\n            console.log(\"Carácter encontrado:\", characterFound);\n            \n            // Actualizar el estado y la referencia\n            setCurrentCharacter(characterFound);\n            currentCharRef.current = characterFound; // Actualizar la referencia inmediatamente\n            console.log(\"Estado actualizado directamente a:\", characterFound, \"Referencia:\", currentCharRef.current);\n            \n            // Generar descripción de los puntos para anunciar (sin mencionar el carácter)\n            const description = validNumbers.length === 1 \n                ? `punto ${validNumbers[0]}` \n                : `puntos ${validNumbers.join(', ')}`;\n            \n            // Solo anunciar los puntos seleccionados, no el carácter resultante\n            speakMessage(`Has seleccionado ${description}.`);\n        } else {\n            // Si la combinación no existe en el mapa, limpiar el carácter actual\n            console.log(\"No se encontró carácter para la clave:\", dotKey);\n            setCurrentCharacter('');\n            currentCharRef.current = ''; // Actualizar la referencia inmediatamente\n            \n            const message = validNumbers.length === 1 \n                ? `Has seleccionado punto ${validNumbers[0]}.` \n                : `Has seleccionado puntos ${validNumbers.join(', ')}.`;\n                \n            speakMessage(message);\n        }\n        \n        // Para propósitos de depuración, verificar después de un tiempo\n        setTimeout(() => {\n            console.log(\"VERIFICACIÓN tras handleNumberCombination - Estado:\", currentCharacter, \"Referencia:\", currentCharRef.current);\n        }, 100);\n    };\n\n    // Actualizar el carácter actual basado en los puntos activos\n    const updateCurrentCharacter = (char) => {\n        if (char) {\n            console.log(\"Actualizando carácter actual a:\", char);\n            setCurrentCharacter(char);\n        } else {\n            console.log(\"Limpiando carácter actual\");\n            setCurrentCharacter('');\n        }\n    };\n\n    // Confirmar el carácter actual y añadirlo a la contraseña\n    const confirmCharacter = () => {\n        // Leer directamente desde la referencia para evitar problemas de sincronización\n        const charToAdd = currentCharRef.current;\n        console.log(\"Ejecutando confirmCharacter. Carácter actual (estado):\", currentCharacter);\n        console.log(\"Carácter actual (referencia):\", charToAdd);\n        \n        if (charToAdd) {\n            // Usar los valores de referencia para asegurar consistencia\n            const currentPassword = passwordRef.current;\n            const currentDisplay = displayPasswordRef.current;\n            const newPassword = currentPassword + charToAdd;\n            const newDisplay = currentDisplay + charToAdd;\n            \n            // Guardar la combinación de puntos actual para el resumen final\n            const currentDotCombinations = dotCombinationsRef.current;\n            const newDotCombinations = [...currentDotCombinations, [...activeDots]];\n            setDotCombinations(newDotCombinations);\n            dotCombinationsRef.current = newDotCombinations;\n            \n            console.log(\"Antes de actualizar - Password (ref):\", currentPassword, \"Display (ref):\", currentDisplay);\n            console.log(\"Guardando combinación de puntos:\", activeDots);\n            \n            // Actualizar ambos estados de forma consistente\n            setPassword(prevPassword => {\n                const updatedPassword = prevPassword + charToAdd;\n                console.log(\"Actualizando password a:\", updatedPassword);\n                return updatedPassword;\n            });\n            \n            setDisplayPassword(prevDisplay => {\n                const updatedDisplay = prevDisplay + charToAdd;\n                console.log(\"Actualizando display a:\", updatedDisplay);\n                return updatedDisplay;\n            });\n            \n            // Actualizar referencias inmediatamente\n            passwordRef.current = newPassword;\n            displayPasswordRef.current = newDisplay;\n            \n            // Limpiar el estado actual\n            setActiveDots([]);\n            setCurrentCharacter('');\n            currentCharRef.current = ''; // Actualizar la referencia inmediatamente\n            \n            // Dar feedback sobre la operación, sin mencionar el carácter específico\n            const feedbackMessage = `Puntos confirmados. Longitud actual: ${newPassword.length} caracteres`;\n            console.log(feedbackMessage);\n            speakMessage(feedbackMessage);\n            \n            // Actualizar mensaje para el usuario\n            setMessage(`Posición ${newPassword.length} confirmada. Total: ${newPassword.length} caracteres`);\n            \n            setTimeout(() => {\n                // Verificación adicional después de un tiempo\n                console.log(\"VERIFICACIÓN POSTERIOR - Password (ref):\", passwordRef.current, \"Display (ref):\", displayPasswordRef.current);\n                console.log(\"Combinaciones guardadas:\", dotCombinationsRef.current);\n            }, 1000);\n        } else {\n            console.log(\"No hay carácter para confirmar. Estado:\", currentCharacter, \"Referencia:\", currentCharRef.current);\n            playAudio('brailleError');\n            speakMessage(\"No hay ningún carácter para confirmar. Primero debes activar al menos un punto.\");\n        }\n    };\n\n    // Eliminar el último carácter de la contraseña\n    const deleteLastCharacter = () => {\n        // Usar referencia para el valor más actualizado\n        const currentPassword = passwordRef.current;\n        const currentDisplay = displayPasswordRef.current;\n        const currentDotCombinations = dotCombinationsRef.current;\n        \n        console.log(\"deleteLastCharacter - Password actual (ref):\", currentPassword, \"Longitud:\", currentPassword.length);\n        \n        if (currentPassword.length > 0) {\n            console.log(\"Eliminando último carácter\");\n            \n            const newPassword = currentPassword.slice(0, -1);\n            const newDisplay = currentDisplay.slice(0, -1);\n            const newDotCombinations = currentDotCombinations.slice(0, -1);\n            \n            // Actualizar referencias inmediatamente\n            passwordRef.current = newPassword;\n            displayPasswordRef.current = newDisplay;\n            dotCombinationsRef.current = newDotCombinations;\n            \n            // Actualizar estados\n            setPassword(newPassword);\n            setDisplayPassword(newDisplay);\n            setDotCombinations(newDotCombinations);\n            \n            console.log(\"Después del borrado - Password (ref):\", passwordRef.current, \"Display (ref):\", displayPasswordRef.current);\n            console.log(\"Combinaciones restantes:\", dotCombinationsRef.current);\n            \n            playAudio('brailleCharacterDeleted');\n        } else {\n            console.log(\"No hay caracteres para eliminar\");\n            speakMessage(\"No hay caracteres para eliminar.\");\n        }\n    };\n\n    // Función para reproducir audio con Amazon Polly\n    const speakWithPollyService = async (text) => {\n        // Ya no intentamos usar Polly, usamos directamente la síntesis del navegador\n        console.log(\"Usando síntesis de voz local para:\", text);\n        return speakMessage(text);\n    };\n\n    // Función para reproducir audio pregrabado con fallback a síntesis de voz\n    const playBrailleAudio = async (type, char, dotsDescription = '') => {\n        try {\n            console.log(`Intentando reproducir audio braille para: ${type}, carácter: ${char}`);\n            \n            // Determinar qué archivo intentar reproducir\n            let audioFile = '';\n            let fallbackText = '';\n            \n            if (type === 'character_info') {\n                // Audio solo con la descripción de los puntos, sin mencionar el carácter resultante\n                audioFile = `braille/braille_${char}_info`;\n                // Solo mencionar los puntos, no el carácter (por seguridad)\n                fallbackText = `Has seleccionado ${dotsDescription}.`;\n            } else if (type === 'character') {\n                // Solo puntos, sin mencionar el carácter\n                audioFile = `braille/braille_${char}`;\n                fallbackText = `Puntos confirmados.`;\n            } else if (type === 'intro') {\n                audioFile = `braille/password_intro`;\n                fallbackText = \"Tu contraseña ha sido creada. A continuación escucharás cada uno de los caracteres.\";\n            } else if (type === 'completed') {\n                audioFile = `braille/password_completed`;\n                fallbackText = \"Tu contraseña ha sido guardada correctamente.\";\n            } else if (type === 'char_prefix') {\n                audioFile = `braille/password_char_prefix`;\n                fallbackText = \"Carácter\";\n            }\n            \n            // Intentar reproducir el audio pregrabado\n            try {\n                await playPredefinedMessage(audioFile);\n                console.log(`✅ Audio pregrabado reproducido: ${audioFile}`);\n                return true;\n            } catch (audioError) {\n                console.log(`❌ No se pudo reproducir audio pregrabado: ${audioFile}. Usando síntesis de voz.`);\n                // Si falla, usar síntesis de voz como fallback\n                await speakMessage(fallbackText);\n                return true;\n            }\n        } catch (error) {\n            console.error('Error en playBrailleAudio:', error);\n            // En caso de error general, intentar síntesis de voz directamente\n            if (dotsDescription) {\n                await speakMessage(`Has seleccionado ${dotsDescription}.`);\n            }\n            return false;\n        }\n    };\n\n    // Función mejorada para hablar un mensaje con posibilidad de usar audios pregrabados\n    const speakBrailleCharacter = async (char, dotsDescription = '') => {\n        // Intentar usar audio pregrabado primero, pero solo anunciando los puntos seleccionados\n        try {\n            // En lugar de usar el audio pregrabado que menciona el carácter, solo anunciar los puntos\n            // await playBrailleAudio('character_info', char, dotsDescription);\n            await speakMessage(`Has seleccionado ${dotsDescription}.`);\n        } catch (error) {\n            console.error('Error al reproducir audio para puntos braille:', error);\n            // Fallback a síntesis de voz\n            await speakMessage(`Has seleccionado ${dotsDescription}.`);\n        }\n    };\n\n    // Función mejorada para reproducir el resumen de la contraseña\n    const speakPasswordSummary = async () => {\n        try {\n            const combinations = dotCombinationsRef.current;\n            const characters = displayPasswordRef.current.split('');\n            \n            console.log(\"Reproduciendo resumen de contraseña con combinaciones:\", combinations);\n            console.log(\"Caracteres de la contraseña:\", characters);\n            \n            // Mensaje introductorio - intentar usar audio pregrabado\n            await playBrailleAudio('intro');\n            \n            // Pequeña pausa\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            \n            // Describir cada carácter usando los archivos de audio pregrabados\n            for (let i = 0; i < characters.length; i++) {\n                const char = characters[i];\n                console.log(`Reproduciendo información para el carácter ${i+1}: \"${char}\"`);\n                \n                try {\n                    // Usar directamente el archivo de audio de posición\n                    const positionNumber = i + 1;\n                    const positionAudioFile = `position_${positionNumber}`;\n                    \n                    try {\n                        // Reproducir el audio de la posición (\"posición X\")\n                        console.log(`Reproduciendo audio de posición: ${positionAudioFile}`);\n                        await playPredefinedMessage(positionAudioFile);\n                    } catch (positionError) {\n                        console.error(`Error al reproducir posición ${positionNumber}:`, positionError);\n                        // Fallback a síntesis de voz si falla\n                        await speakMessage(`Posición ${positionNumber}`);\n                    }\n                    \n                    // Pequeña pausa\n                    await new Promise(resolve => setTimeout(resolve, 300));\n                    \n                    // Reproducir el audio específico para este carácter\n                    try {\n                        // Intentar reproducir el archivo de audio específico para el carácter\n                        console.log(`Intentando reproducir archivo braille/braille_${char}_info.mp3`);\n                        await playPredefinedMessage(`braille/braille_${char}_info`);\n                        console.log(`✅ Audio de carácter reproducido correctamente: braille_${char}_info`);\n                    } catch (audioError) {\n                        console.error(`❌ Error al reproducir audio para carácter \"${char}\":`, audioError);\n                        \n                        // Si falla el audio pregrabado, usar la descripción de puntos como fallback\n                        const dotDescription = getDotsDescription(combinations[i]);\n                        await speakMessage(`formado por ${dotDescription}.`);\n                    }\n                } catch (error) {\n                    console.error(`Error al procesar carácter ${i+1}:`, error);\n                    // Si falla completamente, usar la síntesis de voz como último recurso\n                    const dotDescription = getDotsDescription(combinations[i]);\n                    await speakMessage(`Posición ${i+1}: formado por ${dotDescription}.`);\n                }\n                \n                // Pequeña pausa entre caracteres\n                await new Promise(resolve => setTimeout(resolve, 800));\n            }\n            \n            // Mensaje final con audio pregrabado si está disponible\n            await playBrailleAudio('completed');\n            \n        } catch (error) {\n            console.error(\"Error al reproducir resumen:\", error);\n            speakMessage(\"Ocurrió un error al reproducir el resumen de la contraseña.\");\n        }\n    };\n\n    // Completar la contraseña\n    const completePassword = () => {\n        // Usar referencia para el valor más actualizado\n        const currentPassword = passwordRef.current;\n        console.log(\"Intentando completar la contraseña. Longitud (ref):\", currentPassword.length);\n        \n        // Leer desde la referencia por consistencia\n        const charPending = currentCharRef.current;\n        \n        if (currentPassword.length > 0 || charPending) {\n            let finalPassword = currentPassword;\n            \n            // Si hay un carácter activo, confirmarlo primero\n            if (charPending) {\n                finalPassword = currentPassword + charPending;\n                console.log(\"Añadiendo último carácter antes de completar:\", finalPassword);\n                \n                // Guardar la combinación de puntos actual\n                const currentDotCombinations = dotCombinationsRef.current;\n                const newDotCombinations = [...currentDotCombinations, [...activeDots]];\n                \n                // Actualizar estados y referencias con el carácter final\n                passwordRef.current = finalPassword;\n                displayPasswordRef.current = displayPasswordRef.current + charPending;\n                dotCombinationsRef.current = newDotCombinations;\n                \n                setPassword(finalPassword);\n                setDisplayPassword(displayPasswordRef.current);\n                setDotCombinations(newDotCombinations);\n                \n                setActiveDots([]);\n                setCurrentCharacter('');\n                currentCharRef.current = ''; \n            }\n            \n            // En lugar de completar inmediatamente, activar el modo de edición \n            // y preguntar si el usuario quiere editar la contraseña\n            console.log(\"Contraseña completada, preguntando si desea editarla:\", finalPassword);\n            console.log(\"Combinaciones finales:\", dotCombinationsRef.current);\n            \n            playAudio('braillePasswordSaved');\n            setStatus('completed');\n            stopListening();\n            \n            // Reproducir el resumen de la contraseña\n            setTimeout(async () => {\n                await speakPasswordSummary();\n                \n                // Después de reproducir el resumen, preguntar si quiere editar\n                setTimeout(() => {\n                    console.log(\"Preguntando si desea editar la contraseña\");\n                    // Iniciar modo de edición\n                    startEditMode();\n                    // Reiniciar la escucha para captar la respuesta\n                    setTimeout(() => {\n                        if (recognitionRef.current) {\n                            startListening();\n                        }\n                    }, 500);\n                }, 1000);\n            }, 1500);\n            \n        } else {\n            console.log(\"No se puede completar: contraseña vacía\");\n            playAudio('brailleError');\n            speakMessage(\"No puedes finalizar sin introducir al menos un carácter.\");\n        }\n    };\n\n    // Iniciar la escucha de voz\n    const startListening = () => {\n        try {\n            playBeep();\n            // Detener cualquier instancia previa si está en ejecución\n            if (recognitionRef.current) {\n                try {\n                    recognitionRef.current.stop();\n                } catch (error) {\n                    console.log('Deteniendo reconocimiento previo:', error);\n                    // Ignorar errores aquí, ya que podría no estar ejecutándose\n                }\n            }\n            \n            // Esperar un momento antes de iniciar el nuevo reconocimiento\n            setTimeout(() => {\n                try {\n                    recognitionRef.current.start();\n                    setListening(true);\n                    setStatus('listening');\n                    setMessage('Escuchando...');\n                } catch (error) {\n                    console.error('Error al iniciar reconocimiento:', error);\n                    setMessage(`Error al iniciar reconocimiento: ${error.message}. Intenta hacer clic en el botón \"Iniciar escucha\"`);\n                }\n            }, 300);\n        } catch (error) {\n            console.error('Error general al iniciar reconocimiento:', error);\n            setMessage(`Error general: ${error.message}. Intenta hacer clic en el botón \"Iniciar escucha\"`);\n        }\n    };\n\n    // Detener la escucha de voz\n    const stopListening = () => {\n        if (recognitionRef.current) {\n            recognitionRef.current.stop();\n        }\n        setListening(false);\n        setMessage('');\n    };\n\n    // Reproducir archivos de audio\n    const playAudio = (audioName) => {\n        try {\n            console.log(`Reproduciendo mensaje: ${audioName}`);\n            \n            // Comprobar si es uno de los nuevos audios de edición\n            if (audioName.startsWith('edit_') || audioName === 'position_selected') {\n                // Intentar reproducir el archivo de audio pregrabado para edición\n                playPredefinedMessage(audioName)\n                    .catch(error => {\n                        console.error(`Error al reproducir audio de edición ${audioName}:`, error);\n                        // Fallback a mensajes de texto en caso de error\n                        let fallbackMessage = \"\";\n                        switch (audioName) {\n                            case 'edit_password_question':\n                                fallbackMessage = \"¿Deseas editar tu contraseña? Dí 'editar' para modificarla o 'confirmar' para guardarla como está.\";\n                                break;\n                            case 'edit_position_prompt':\n                                fallbackMessage = \"Dí la posición que deseas editar, por ejemplo 'posición 2'.\";\n                                break;\n                            case 'edit_points_prompt':\n                                fallbackMessage = \"Ahora dí los puntos que deseas activar para esta posición.\";\n                                break;\n                            case 'edit_from_scratch':\n                                fallbackMessage = \"¿Deseas crear la contraseña desde cero? Dí 'sí' para empezar de nuevo o 'no' para mantener la contraseña actual y editar posiciones específicas.\";\n                                break;\n                            case 'edit_confirm':\n                                fallbackMessage = \"Dí 'confirmar' para guardar los cambios a tu contraseña.\";\n                                break;\n                            case 'edit_success':\n                                fallbackMessage = \"Contraseña modificada correctamente.\";\n                                break;\n                            case 'position_selected':\n                                fallbackMessage = \"Posición seleccionada. Ahora dí los puntos que deseas activar.\";\n                                break;\n                            case 'edit_cancelled':\n                                fallbackMessage = \"Edición cancelada. Tu contraseña se mantiene como estaba.\";\n                                break;\n                            default:\n                                fallbackMessage = \"Comando de edición no reconocido.\";\n                                break;\n                        }\n                        speakMessage(fallbackMessage);\n                    });\n                return;\n            }\n            \n            // Usar síntesis de voz para el resto de mensajes\n            let message = \"\";\n            \n            // Mapeo de identificadores de audio a mensajes\n            switch (audioName) {\n                case 'braillePointsRecognized':\n                    message = \"Puntos reconocidos\";\n                    break;\n                case 'brailleCharacterConfirmed':\n                    message = \"Carácter confirmado\";\n                    break;\n                case 'brailleError':\n                    message = \"Error. Intenta de nuevo\";\n                    break;\n                case 'brailleCharacterDeleted':\n                    message = \"Último carácter eliminado\";\n                    break;\n                case 'braillePasswordSaved':\n                    message = \"Contraseña guardada correctamente\";\n                    break;\n                case 'brailleHelp':\n                    message = \"Di los números de los puntos braille que deseas activar, luego di siguiente para confirmar el carácter\";\n                    break;\n                case 'notUnderstood':\n                    message = \"No he entendido. Por favor, di números del 1 al 6, o comandos como siguiente, borrar o he terminado\";\n                    break;\n                default:\n                    message = audioName; // Usar el nombre como mensaje si no hay mapeo\n            }\n            \n            // Evitar llamar a speakMessage si está vacío\n            if (message.trim()) {\n                // También actualizar el mensaje en pantalla para mayor feedback\n                setMessage(message);\n                // Usar directamente speakMessage para unificar manejo de errores\n                speakMessage(message);\n            }\n            \n        } catch (error) {\n            console.error(`Error general al manejar audio ${audioName}:`, error);\n            // Mostrar el error en pantalla ya que la síntesis falló\n            setMessage(`Error de audio. Por favor, utiliza los botones en pantalla.`);\n        }\n    };\n\n    // Función para reproducir un archivo de audio pregrabado\n    const playPredefinedMessage = (audioName) => {\n        return new Promise((resolve, reject) => {\n            try {\n                console.log(`Intentando reproducir audio pregrabado: ${audioName}`);\n                const audioPath = `${window.location.origin}/audio/${audioName}.mp3`;\n                \n                const audio = new Audio(audioPath);\n                \n                audio.addEventListener('error', (e) => {\n                    console.error(`Error al cargar el audio ${audioName}:`, e);\n                    reject(new Error(`No se pudo cargar el audio ${audioName}`));\n                });\n                \n                audio.addEventListener('ended', () => {\n                    console.log(`Audio ${audioName} terminado`);\n                    resolve();\n                });\n                \n                audio.play().catch(error => {\n                    console.error(`Error al reproducir audio ${audioName}:`, error);\n                    reject(error);\n                });\n            } catch (error) {\n                console.error(`Error general al reproducir audio ${audioName}:`, error);\n                reject(error);\n            }\n        });\n    };\n\n    // Mapeo de puntos braille a posiciones en la matriz\n    const getBrailleDotClass = (position) => {\n        return activeDots.includes(position) ? 'active' : '';\n    };\n\n    // Manejar los comandos de edición\n    const handleEditCommands = (command) => {\n        // Si está en modo edición\n        if (editModeRef.current) {\n            // Gestionar diferentes pasos del proceso de edición\n            if (editStepRef.current === 'askEdit') {\n                if (command.includes('editar') || command.includes('modificar') || command.includes('cambiar')) {\n                    // Solo reproducir las instrucciones de edición si no se han reproducido antes\n                    if (!playedEditInstructions) {\n                        playAudio('edit_position_prompt');\n                        setPlayedEditInstructions(true);\n                        setPlayedPositionPrompt(true); // Marcar que ya se reprodujo el prompt de posición\n                    } else {\n                        speakMessage(\"Dí la posición que deseas editar, por ejemplo 'posición 2'.\");\n                    }\n                    setEditStep('askPosition');\n                    return true;\n                } else if (command.includes('confirmar') || command.includes('guardar') || command.includes('aceptar')) {\n                    // Salir del modo edición y completar el proceso\n                    // Usar el audio de contraseña guardada en lugar del de contraseña modificada\n                    playAudio('braillePasswordSaved');\n                    setEditMode(false);\n                    setEditStep('none');\n                    \n                    // Notificar que la contraseña está completa sin iniciar un nuevo ciclo de edición\n                    if (onPasswordComplete) {\n                        onPasswordComplete(passwordRef.current);\n                    }\n                    return true;\n                } else if (command.includes('cancelar') || command.includes('salir')) {\n                    // Salir del modo edición sin cambios\n                    playAudio('edit_cancelled');\n                    setEditMode(false);\n                    setEditStep('none');\n                    return true;\n                }\n            } \n            else if (editStepRef.current === 'askPosition') {\n                // Buscar una mención a una posición, como \"posición 2\"\n                const positionMatch = command.match(/posici[oóò]n\\s+(\\d+)/i);\n                if (positionMatch) {\n                    const position = parseInt(positionMatch[1]);\n                    if (position > 0 && position <= passwordRef.current.length) {\n                        setEditPosition(position - 1); // Ajustar a base 0\n                        playAudio('position_selected');\n                        setEditStep('editingPosition');\n                        \n                        // Cargar los puntos de la posición para poder editarlos\n                        if (dotCombinationsRef.current[position - 1]) {\n                            setActiveDots(dotCombinationsRef.current[position - 1]);\n                            // Calcular el carácter correspondiente\n                            let dotKey = dotCombinationsRef.current[position - 1].sort().join('');\n                            const characterFound = brailleMap[dotKey];\n                            if (characterFound) {\n                                setCurrentCharacter(characterFound);\n                                currentCharRef.current = characterFound;\n                            }\n                        }\n                        \n                        return true;\n                    } else {\n                        speakMessage(`La posición ${position} no es válida. Tu contraseña tiene ${passwordRef.current.length} caracteres.`);\n                        return true;\n                    }\n                } \n                // Si menciona directamente un número\n                const numberMatch = command.match(/\\b(\\d+)\\b/);\n                if (numberMatch) {\n                    const position = parseInt(numberMatch[1]);\n                    if (position > 0 && position <= passwordRef.current.length) {\n                        setEditPosition(position - 1); // Ajustar a base 0\n                        playAudio('position_selected');\n                        setEditStep('editingPosition');\n                        \n                        // Cargar los puntos de la posición para poder editarlos\n                        if (dotCombinationsRef.current[position - 1]) {\n                            setActiveDots(dotCombinationsRef.current[position - 1]);\n                            // Calcular el carácter correspondiente\n                            let dotKey = dotCombinationsRef.current[position - 1].sort().join('');\n                            const characterFound = brailleMap[dotKey];\n                            if (characterFound) {\n                                setCurrentCharacter(characterFound);\n                                currentCharRef.current = characterFound;\n                            }\n                        }\n                        \n                        return true;\n                    } else {\n                        speakMessage(`La posición ${position} no es válida. Tu contraseña tiene ${passwordRef.current.length} caracteres.`);\n                        return true;\n                    }\n                }\n                else if (command.includes('salir') || command.includes('cancelar')) {\n                    playAudio('edit_cancelled');\n                    setEditMode(false);\n                    setEditStep('none');\n                    return true;\n                }\n                else if (command.includes('desde cero') || command.includes('empezar') || command.includes('nuevo')) {\n                    playAudio('edit_from_scratch');\n                    setEditStep('askFromScratch');\n                    return true;\n                }\n            }\n            else if (editStepRef.current === 'askFromScratch') {\n                if (command.includes('sí') || command.includes('si') || command.includes('afirmativo') || command.includes('ok')) {\n                    // Resetear la contraseña y salir del modo edición\n                    setPassword('');\n                    setDisplayPassword('');\n                    setDotCombinations([]);\n                    passwordRef.current = '';\n                    displayPasswordRef.current = '';\n                    dotCombinationsRef.current = [];\n                    setActiveDots([]);\n                    setCurrentCharacter('');\n                    currentCharRef.current = '';\n                    \n                    // Salir del modo edición\n                    setEditMode(false);\n                    setEditStep('none');\n                    speakMessage(\"Contraseña eliminada. Ahora puedes crear una nueva desde cero.\");\n                    return true;\n                } else if (command.includes('no') || command.includes('negativo') || command.includes('cancelar')) {\n                    // Volver a preguntar por la posición\n                    playAudio('edit_position_prompt');\n                    setEditStep('askPosition');\n                    return true;\n                }\n            }\n            else if (editStepRef.current === 'editingPosition') {\n                // Si dice \"confirmar\" estando en modo edición de posición\n                if (command.includes('confirmar') || command.includes('listo') || command.includes('siguiente') || \n                    command.includes('aceptar') || command.includes('ok')) {\n                    confirmEditedPosition();\n                    return true;\n                }\n                // Si dice \"cancelar\" estando en modo edición de posición\n                else if (command.includes('cancelar') || command.includes('salir')) {\n                    cancelPositionEdit();\n                    return true;\n                }\n                \n                // Si estamos editando una posición, procesar los números como en el modo normal\n                // No manejarlos aquí, dejar que el flujo normal los procese\n                return false;\n            }\n        }\n        // Si no está en modo edición, comprobar si quiere entrar en modo edición\n        else if (command.includes('editar') || command.includes('modificar') || command.includes('cambiar')) {\n            startEditMode();\n            return true;\n        }\n        \n        // No era un comando de edición\n        return false;\n    };\n\n    // Iniciar el modo de edición\n    const startEditMode = () => {\n        if (passwordRef.current.length === 0) {\n            speakMessage(\"No hay una contraseña para editar.\");\n            return;\n        }\n        \n        setEditMode(true);\n        setEditStep('askEdit');\n        // Resetear el estado para controlar si ya se reprodujeron las instrucciones\n        setPlayedEditInstructions(false);\n        // Resetear el estado del prompt de posición\n        setPlayedPositionPrompt(false);\n        playAudio('edit_password_question');\n        \n        // Ya no reproducimos automáticamente el prompt de posición aquí,\n        // ahora se reproducirá solo cuando el usuario diga \"editar\"\n    };\n\n    // Confirmar los cambios hechos en la posición editada\n    const confirmEditedPosition = () => {\n        // Obtener el carácter actual desde la referencia\n        const charToEdit = currentCharRef.current;\n        const posToEdit = editPositionRef.current;\n        \n        if (charToEdit && posToEdit >= 0 && posToEdit < passwordRef.current.length) {\n            console.log(`Editando posición ${posToEdit + 1}: reemplazando por \"${charToEdit}\"`);\n            \n            // Crear copias de las cadenas actuales\n            const currentPassword = passwordRef.current;\n            const currentDisplay = displayPasswordRef.current;\n            const currentDotCombinations = [...dotCombinationsRef.current];\n            \n            // Actualizar las cadenas de contraseña\n            const passwordChars = currentPassword.split('');\n            passwordChars[posToEdit] = charToEdit;\n            const newPassword = passwordChars.join('');\n            \n            const displayChars = currentDisplay.split('');\n            displayChars[posToEdit] = charToEdit;\n            const newDisplay = displayChars.join('');\n            \n            // Actualizar la combinación de puntos\n            currentDotCombinations[posToEdit] = [...activeDots];\n            \n            // Actualizar los estados y referencias\n            setPassword(newPassword);\n            setDisplayPassword(newDisplay);\n            setDotCombinations(currentDotCombinations);\n            \n            passwordRef.current = newPassword;\n            displayPasswordRef.current = newDisplay;\n            dotCombinationsRef.current = currentDotCombinations;\n            \n            // Limpiar estados actuales\n            setActiveDots([]);\n            setCurrentCharacter('');\n            currentCharRef.current = '';\n            \n            // Dar feedback al usuario\n            speakMessage(`Posición ${posToEdit + 1} actualizada. Puedes editar otra posición o confirmar los cambios.`);\n            \n            // Volver a preguntar por otra posición solo si no se ha reproducido ya\n            setTimeout(() => {\n                if (!playedPositionPromptRef.current) {\n                    playAudio('edit_position_prompt');\n                    setPlayedPositionPrompt(true);\n                } else {\n                    speakMessage(\"Puedes editar otra posición o confirmar los cambios.\");\n                }\n                setEditStep('askPosition');\n            }, 2000);\n        } else {\n            speakMessage(\"No hay cambios para confirmar en esta posición.\");\n            \n            // Volver a preguntar por otra posición solo si no se ha reproducido ya\n            setTimeout(() => {\n                if (!playedPositionPromptRef.current) {\n                    playAudio('edit_position_prompt');\n                    setPlayedPositionPrompt(true);\n                } else {\n                    speakMessage(\"Puedes editar otra posición o confirmar los cambios.\");\n                }\n                setEditStep('askPosition');\n            }, 1500);\n        }\n    };\n\n    // Cancelar la edición de posición actual\n    const cancelPositionEdit = () => {\n        setActiveDots([]);\n        setCurrentCharacter('');\n        currentCharRef.current = '';\n        setEditPosition(-1);\n        \n        speakMessage(\"Edición de posición cancelada. Puedes elegir otra posición para editar.\");\n        \n        setTimeout(() => {\n            // Solo reproducir el prompt si no se ha reproducido antes\n            if (!playedPositionPromptRef.current) {\n                playAudio('edit_position_prompt');\n                setPlayedPositionPrompt(true);\n            } else {\n                speakMessage(\"Puedes elegir otra posición para editar o confirmar los cambios.\");\n            }\n            setEditStep('askPosition');\n        }, 1500);\n    };\n\n    return (\n        <div className=\"braille-password-container bg-white p-6 rounded-lg shadow-sm border border-gray-200\">\n            <h3 className=\"text-lg font-medium text-gray-900 mb-4 text-center\">Contraseña Braille</h3>\n            \n            <div className=\"mb-4 text-center\">\n                <p className=\"text-md text-gray-700\">\n                    {status === 'waiting' && 'Preparando reconocimiento de voz...'}\n                    {status === 'listening' && 'Di los números de los puntos braille (1-6)'}\n                    {status === 'processing' && 'Procesando...'}\n                    {status === 'completed' && '¡Contraseña guardada!'}\n                </p>\n                \n                {listening && (\n                    <div className=\"mt-2 inline-flex items-center\">\n                        <span className=\"w-3 h-3 bg-green-500 rounded-full animate-pulse mr-2\"></span>\n                        <span className=\"text-sm text-green-600\">Escuchando comandos de voz</span>\n                    </div>\n                )}\n                \n                {message && (\n                    <p className=\"text-sm text-blue-600 mt-2\">{message}</p>\n                )}\n            </div>\n\n            <div className=\"braille-display mb-6\">\n                <div className=\"relative\">\n                    <div className=\"mb-2 text-center\">\n                        <span className=\"text-xs text-gray-500\">Configuración de puntos Braille</span>\n                    </div>\n                    <div className=\"braille-cell\">\n                        <div \n                            className={`braille-dot ${getBrailleDotClass(1)}`} \n                            data-position=\"1\"\n                            aria-label=\"Punto braille 1\"\n                            title=\"Punto 1\"\n                        >1</div>\n                        <div \n                            className={`braille-dot ${getBrailleDotClass(2)}`} \n                            data-position=\"2\"\n                            aria-label=\"Punto braille 2\"\n                            title=\"Punto 2\"\n                        >2</div>\n                        <div \n                            className={`braille-dot ${getBrailleDotClass(3)}`} \n                            data-position=\"3\"\n                            aria-label=\"Punto braille 3\"\n                            title=\"Punto 3\"\n                        >3</div>\n                        <div \n                            className={`braille-dot ${getBrailleDotClass(4)}`} \n                            data-position=\"4\"\n                            aria-label=\"Punto braille 4\"\n                            title=\"Punto 4\"\n                        >4</div>\n                        <div \n                            className={`braille-dot ${getBrailleDotClass(5)}`} \n                            data-position=\"5\"\n                            aria-label=\"Punto braille 5\"\n                            title=\"Punto 5\"\n                        >5</div>\n                        <div \n                            className={`braille-dot ${getBrailleDotClass(6)}`} \n                            data-position=\"6\"\n                            aria-label=\"Punto braille 6\"\n                            title=\"Punto 6\"\n                        >6</div>\n                    </div>\n                </div>\n                \n                <div className=\"current-braille-info mt-4 text-center\">\n                    {currentCharacter ? (\n                        <div>\n                            {/* Mostrar el carácter en la interfaz visual */}\n                            <span className=\"text-2xl font-bold block\">{currentCharacter}</span>\n                            <span className=\"text-xs text-gray-500\">\n                                Puntos seleccionados: {activeDots.join(', ')}\n                            </span>\n                        </div>\n                    ) : (\n                        <span className=\"text-sm text-gray-500\">Indica números para activar puntos</span>\n                    )}\n                </div>\n            </div>\n\n            <div className=\"password-display mb-4 p-3 bg-gray-50 rounded border border-gray-200\">\n                <label className=\"block text-sm font-medium text-gray-700 mb-2\">Contraseña creada:</label>\n                <div className=\"h-8 flex items-center justify-center\">\n                    {displayPassword ? (\n                        <span className=\"text-lg tracking-widest font-mono text-primary-600 font-bold\">\n                            {/* Mostrar los caracteres reales de la contraseña */}\n                            {displayPassword}\n                        </span>\n                    ) : (\n                        <span className=\"text-sm text-gray-500 italic\">No hay caracteres aún</span>\n                    )}\n                </div>\n                {displayPassword.length > 0 && (\n                    <div className=\"mt-2 text-center\">\n                        <span className=\"text-xs text-gray-500\">\n                            Longitud: {displayPassword.length} {displayPassword.length === 1 ? 'carácter' : 'caracteres'}\n                        </span>\n                    </div>\n                )}\n            </div>\n\n            <div className=\"voice-commands mb-4 p-3 bg-blue-50 rounded border border-blue-200\">\n                <h4 className=\"font-medium text-blue-800 mb-2 text-center\">Comandos de voz disponibles:</h4>\n                <div className=\"grid grid-cols-2 gap-2\">\n                    <div className=\"p-2 bg-white rounded shadow-sm\">\n                        <span className=\"text-sm font-medium block text-blue-700\">1-6</span>\n                        <span className=\"text-xs text-gray-600\">Activar puntos braille</span>\n                    </div>\n                    <div className=\"p-2 bg-white rounded shadow-sm\">\n                        <span className=\"text-sm font-medium block text-blue-700\">Siguiente</span>\n                        <span className=\"text-xs text-gray-600\">Confirmar puntos seleccionados</span>\n                    </div>\n                    <div className=\"p-2 bg-white rounded shadow-sm\">\n                        <span className=\"text-sm font-medium block text-blue-700\">Borrar</span>\n                        <span className=\"text-xs text-gray-600\">Eliminar última posición</span>\n                    </div>\n                    <div className=\"p-2 bg-white rounded shadow-sm\">\n                        <span className=\"text-sm font-medium block text-blue-700\">He terminado</span>\n                        <span className=\"text-xs text-gray-600\">Finalizar contraseña</span>\n                    </div>\n                </div>\n            </div>\n\n            <div className=\"controls flex flex-wrap gap-2 justify-center\">\n                <button \n                    onClick={startListening} \n                    disabled={listening || status === 'completed'} \n                    className=\"px-4 py-2 bg-green-600 text-white rounded-md disabled:opacity-50 flex items-center\"\n                    aria-label=\"Iniciar reconocimiento de voz\"\n                >\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5 mr-1\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                        <path fillRule=\"evenodd\" d=\"M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z\" clipRule=\"evenodd\" />\n                    </svg>\n                    Iniciar escucha\n                </button>\n                <button \n                    onClick={stopListening} \n                    disabled={!listening || status === 'completed'} \n                    className=\"px-4 py-2 bg-red-600 text-white rounded-md disabled:opacity-50 flex items-center\"\n                    aria-label=\"Detener reconocimiento de voz\"\n                >\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5 mr-1\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                        <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm8-8a8 8 0 11-16 0 8 8 0 0116 0zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z\" clipRule=\"evenodd\" />\n                    </svg>\n                    Detener escucha\n                </button>\n                <button \n                    onClick={confirmCharacter} \n                    disabled={!currentCharacter || status === 'completed'} \n                    className=\"px-4 py-2 bg-blue-600 text-white rounded-md disabled:opacity-50 flex items-center\"\n                    aria-label=\"Confirmar carácter actual\"\n                >\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5 mr-1\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                        <path fillRule=\"evenodd\" d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\" clipRule=\"evenodd\" />\n                    </svg>\n                    Confirmar\n                </button>\n                <button \n                    onClick={deleteLastCharacter} \n                    disabled={password.length === 0 || status === 'completed'} \n                    className=\"px-4 py-2 bg-yellow-600 text-white rounded-md disabled:opacity-50 flex items-center\"\n                    aria-label=\"Borrar último carácter\"\n                >\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5 mr-1\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                        <path fillRule=\"evenodd\" d=\"M6.707 4.879A3 3 0 018.828 4H15a3 3 0 013 3v6a3 3 0 01-3 3H8.828a3 3 0 01-2.12-.879l-4.415-4.414a1 1 0 010-1.414l4.414-4.414zm4 2.414a1 1 0 00-1.414 1.414L10.586 10l-1.293 1.293a1 1 0 101.414 1.414L12 11.414l1.293 1.293a1 1 0 001.414-1.414L13.414 10l1.293-1.293a1 1 0 00-1.414-1.414L12 8.586l-1.293-1.293z\" clipRule=\"evenodd\" />\n                    </svg>\n                    Borrar\n                </button>\n                <button \n                    onClick={completePassword} \n                    disabled={password.length === 0 || status === 'completed'} \n                    className=\"px-4 py-2 bg-purple-600 text-white rounded-md disabled:opacity-50 flex items-center\"\n                    aria-label=\"Finalizar y guardar contraseña\"\n                >\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5 mr-1\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                        <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\" clipRule=\"evenodd\" />\n                    </svg>\n                    Finalizar\n                </button>\n            </div>\n        </div>\n    );\n};\n\nexport default BraillePassword;"
        }
    ]
}