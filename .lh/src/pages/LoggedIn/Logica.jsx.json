{
    "sourceFile": "src/pages/LoggedIn/Logica.jsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 27,
            "patches": [
                {
                    "date": 1746061173230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1746062346061,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n // 1. Importa React\n import React from 'react';\n+import Micro-enter from './Componentes-Iniciado/Micro-enter';\n \n // 2. Define el componente como una función\n //    (El nombre de la función debe empezar con mayúscula)\n const MiComponenteBasico = () => {\n"
                },
                {
                    "date": 1746062352790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n // 1. Importa React\n import React from 'react';\n-import Micro-enter from './Componentes-Iniciado/Micro-enter';\n+import 'Micro-enter' from './Componentes-Iniciado/Micro-enter';\n \n // 2. Define el componente como una función\n //    (El nombre de la función debe empezar con mayúscula)\n const MiComponenteBasico = () => {\n"
                },
                {
                    "date": 1746062410820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,18 +1,26 @@\n // 1. Importa React\n import React from 'react';\n-import 'Micro-enter' from './Componentes-Iniciado/Micro-enter';\n+import SpeechToTextPTT from './Componentes-Iniciado/Micro-enter';\n \n // 2. Define el componente como una función\n-//    (El nombre de la función debe empezar con mayúscula)\n const MiComponenteBasico = () => {\n-  // 3. La función devuelve JSX (código que parece HTML)\n-  return (\n-    <div>\n-      <h1>Hola desde mi componente básico!</h1>\n-      <p>Este es un párrafo simple.</p>\n-    </div>\n-  );\n-};\n-\n-// 4. Exporta el componente para poder usarlo en otras partes de tu aplicación\n\\ No newline at end of file\n-export default MiComponenteBasico;\n+    // 3. La función devuelve JSX (código que parece HTML)\n+    return (\n+      <div>\n+        <h1>Hola desde mi componente básico!</h1>\n+        <p>Este es un párrafo simple.</p>\n+  \n+        {/* --- Aquí se renderiza el componente SpeechToTextPTT --- */}\n+        {/* Al incluir <SpeechToTextPTT />, todo lo que ese componente renderiza */}\n+        {/* (el control de voz y el área de texto) aparecerá en este punto */}\n+        <SpeechToTextPTT />\n+  \n+        {/* Puedes seguir añadiendo más contenido si quieres */}\n+        {/* <p>Más contenido después del control de voz.</p> */}\n+  \n+      </div>\n+    );\n+  };\n+  \n+  // 4. Exporta el componente\n+  export default MiComponenteBasico;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746063778537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,16 @@\n // 1. Importa React\n import React from 'react';\n import SpeechToTextPTT from './Componentes-Iniciado/Micro-enter';\n+import Navbar from '../../components/Navbar';\n \n // 2. Define el componente como una función\n const MiComponenteBasico = () => {\n     // 3. La función devuelve JSX (código que parece HTML)\n     return (\n+        \n       <div>\n+      <navbar />\n         <h1>Hola desde mi componente básico!</h1>\n         <p>Este es un párrafo simple.</p>\n   \n         {/* --- Aquí se renderiza el componente SpeechToTextPTT --- */}\n"
                },
                {
                    "date": 1746063822715,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,29 +1,32 @@\n // 1. Importa React\n import React from 'react';\n+// Importa el componente SpeechToTextPTT (ruta ajustada por el usuario)\n import SpeechToTextPTT from './Componentes-Iniciado/Micro-enter';\n+// Importa el componente Navbar (ruta ajustada por el usuario)\n import Navbar from '../../components/Navbar';\n \n // 2. Define el componente como una función\n const MiComponenteBasico = () => {\n     // 3. La función devuelve JSX (código que parece HTML)\n     return (\n-        \n+      // Este es el contenedor principal del componente\n       <div>\n-      <navbar />\n+        {/* --- ¡AÑADE TU BARRA DE NAVEGACIÓN AQUÍ! --- */}\n+        {/* Se coloca normalmente al principio del contenido principal del componente */}\n+        <Navbar />\n+\n+        {/* --- El resto del contenido de tu página va DESPUÉS de la barra de navegación --- */}\n         <h1>Hola desde mi componente básico!</h1>\n         <p>Este es un párrafo simple.</p>\n-  \n+\n         {/* --- Aquí se renderiza el componente SpeechToTextPTT --- */}\n-        {/* Al incluir <SpeechToTextPTT />, todo lo que ese componente renderiza */}\n-        {/* (el control de voz y el área de texto) aparecerá en este punto */}\n         <SpeechToTextPTT />\n-  \n+\n         {/* Puedes seguir añadiendo más contenido si quieres */}\n-        {/* <p>Más contenido después del control de voz.</p> */}\n-  \n+\n       </div>\n     );\n   };\n-  \n+\n   // 4. Exporta el componente\n   export default MiComponenteBasico;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746113371676,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,28 +3,31 @@\n // Importa el componente SpeechToTextPTT (ruta ajustada por el usuario)\n import SpeechToTextPTT from './Componentes-Iniciado/Micro-enter';\n // Importa el componente Navbar (ruta ajustada por el usuario)\n import Navbar from '../../components/Navbar';\n+import SideBar from './Componentes-Iniciado/SideBar';\n \n // 2. Define el componente como una función\n const MiComponenteBasico = () => {\n     // 3. La función devuelve JSX (código que parece HTML)\n     return (\n       // Este es el contenedor principal del componente\n-      <div>\n-        {/* --- ¡AÑADE TU BARRA DE NAVEGACIÓN AQUÍ! --- */}\n-        {/* Se coloca normalmente al principio del contenido principal del componente */}\n-        <Navbar />\n+      <div className=\"app-container\">\n+        <SideBar />\n+        <main className=\"content\">\n+          {/* --- ¡AÑADE TU BARRA DE NAVEGACIÓN AQUÍ! --- */}\n+          {/* Se coloca normalmente al principio del contenido principal del componente */}\n+          <Navbar />\n \n-        {/* --- El resto del contenido de tu página va DESPUÉS de la barra de navegación --- */}\n-        <h1>Hola desde mi componente básico!</h1>\n-        <p>Este es un párrafo simple.</p>\n+          {/* --- El resto del contenido de tu página va DESPUÉS de la barra de navegación --- */}\n+          <h1>Hola desde mi componente básico!</h1>\n+          <p>Este es un párrafo simple.</p>\n \n-        {/* --- Aquí se renderiza el componente SpeechToTextPTT --- */}\n-        <SpeechToTextPTT />\n+          {/* --- Aquí se renderiza el componente SpeechToTextPTT --- */}\n+          <SpeechToTextPTT />\n \n-        {/* Puedes seguir añadiendo más contenido si quieres */}\n-\n+          {/* Puedes seguir añadiendo más contenido si quieres */}\n+        </main>\n       </div>\n     );\n   };\n \n"
                },
                {
                    "date": 1746113599281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,9 @@\n import SpeechToTextPTT from './Componentes-Iniciado/Micro-enter';\n // Importa el componente Navbar (ruta ajustada por el usuario)\n import Navbar from '../../components/Navbar';\n import SideBar from './Componentes-Iniciado/SideBar';\n+import './Logica.css';\n \n // 2. Define el componente como una función\n const MiComponenteBasico = () => {\n     // 3. La función devuelve JSX (código que parece HTML)\n"
                },
                {
                    "date": 1746114294029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,36 +1,127 @@\n-// 1. Importa React\n-import React from 'react';\n-// Importa el componente SpeechToTextPTT (ruta ajustada por el usuario)\n-import SpeechToTextPTT from './Componentes-Iniciado/Micro-enter';\n-// Importa el componente Navbar (ruta ajustada por el usuario)\n+import React, { useState, useRef } from 'react';\n+// Importa la librería cliente oficial de Google Generative AI para JS\n+import { GoogleGenerativeAI } from '@google/generative-ai';\n+// Importa el componente de reconocimiento de voz (renombrado)\n+import VoiceRecognition from './Componentes-Iniciado/Micro-enter';\n+// Importa el componente Navbar\n import Navbar from '../../components/Navbar';\n import SideBar from './Componentes-Iniciado/SideBar';\n import './Logica.css';\n \n-// 2. Define el componente como una función\n+// --- ¡¡¡ ADVERTENCIA DE SEGURIDAD !!! ---\n+// !!! NO PONGAS TU CLAVE DE API DIRECTAMENTE AQUÍ EN CÓDIGO PARA PRODUCCIÓN !!!\n+// Esto es solo para demostración. Para producción, la llamada a la API debe hacerse desde un BACKEND SEGURO.\n+const API_KEY = \"AIzaSyClAldN4Lvq3HjK1MgogyFdMzitzAqAkXM\";\n+\n const MiComponenteBasico = () => {\n-    // 3. La función devuelve JSX (código que parece HTML)\n-    return (\n-      // Este es el contenedor principal del componente\n-      <div className=\"app-container\">\n-        <SideBar />\n-        <main className=\"content\">\n-          {/* --- ¡AÑADE TU BARRA DE NAVEGACIÓN AQUÍ! --- */}\n-          {/* Se coloca normalmente al principio del contenido principal del componente */}\n-          <Navbar />\n+  // Estados para manejar la comunicación con Gemini\n+  const [geminiResponse, setGeminiResponse] = useState('');\n+  const [isLoadingGemini, setIsLoadingGemini] = useState(false);\n+  const [geminiError, setGeminiError] = useState('');\n \n\\ No newline at end of file\n-          {/* --- El resto del contenido de tu página va DESPUÉS de la barra de navegación --- */}\n-          <h1>Hola desde mi componente básico!</h1>\n-          <p>Este es un párrafo simple.</p>\n+  // Referencias para la comunicación con Gemini\n+  const genAiRef = useRef(null);\n+  const modelRef = useRef(null);\n+  const isGeminiCallingRef = useRef(false);\n \n-          {/* --- Aquí se renderiza el componente SpeechToTextPTT --- */}\n-          <SpeechToTextPTT />\n+  // Configuración de Gemini\n+  const MODEL_NAME = 'gemini-2.0-flash';\n+  const generationConfig = {\n+    \"temperature\": 0.5,\n+  };\n \n-          {/* Puedes seguir añadiendo más contenido si quieres */}\n-        </main>\n-      </div>\n-    );\n+  // Contexto específico para esta sección - personalizable\n+  const CONTEXT_PREFIX = \"Eres un asistente experto en programación web. \";\n+  const PROMPT_PREFIX = CONTEXT_PREFIX + \"Responde de forma concisa a lo siguiente: \";\n+\n+  // Función para enviar el texto reconocido a Gemini\n+  const sendToGemini = async (text, isClearRequest = false) => {\n+    // Si es una solicitud de limpieza, simplemente resetear los estados\n+    if (isClearRequest) {\n+      setGeminiResponse('');\n+      setGeminiError('');\n+      return;\n+    }\n+\n+    // Evitar enviar prompts vacíos o si ya hay una llamada en curso\n+    if (!text.trim() || isLoadingGemini || isGeminiCallingRef.current) {\n+      console.log(\"Saltando llamada a Gemini: texto vacío o ya hay una llamada en progreso.\");\n+      return;\n+    }\n+\n+    setIsLoadingGemini(true);\n+    isGeminiCallingRef.current = true;\n+    setGeminiResponse('');\n+    setGeminiError('');\n+\n+    try {\n+      // Inicializar el cliente y el modelo si no existen ya\n+      if (!genAiRef.current) {\n+        if (!API_KEY) {\n+          throw new Error(\"API Key de Gemini no configurada correctamente.\");\n+        }\n+        genAiRef.current = new GoogleGenerativeAI(API_KEY);\n+      }\n+      if (!modelRef.current) {\n+        modelRef.current = genAiRef.current.getGenerativeModel({\n+          model: MODEL_NAME,\n+          generationConfig: generationConfig,\n+        });\n+      }\n+\n+      // Construir el prompt completo con el prefijo del contexto\n+      const fullPrompt = PROMPT_PREFIX + text;\n+      console.log(\"Enviando a Gemini:\", fullPrompt);\n+\n+      // Llamar a la API usando streaming\n+      const result = await modelRef.current.generateContentStream(fullPrompt);\n+\n+      // Procesar el stream de respuesta\n+      let responseText = '';\n+      for await (const chunk of result.stream) {\n+        const chunkText = chunk.text() || '';\n+        responseText += chunkText;\n+        setGeminiResponse(prev => prev + chunkText);\n+      }\n+\n+      console.log(\"Respuesta de Gemini finalizada.\");\n+\n+    } catch (e) {\n+      console.error(\"Error llamando a la API de Gemini:\", e);\n+      setGeminiError(`Error de Gemini: ${e.message || 'Desconocido'}. Verifica tu API key y la consola.`);\n+      setGeminiResponse('');\n+    } finally {\n+      setIsLoadingGemini(false);\n+      isGeminiCallingRef.current = false;\n+    }\n   };\n \n-  // 4. Exporta el componente\n-  export default MiComponenteBasico;\n+  return (\n+    <div className=\"app-container\">\n+      <SideBar />\n+      <main className=\"content\">\n+        <Navbar />\n+\n+        <h1>Centro de ayuda de programación</h1>\n+        <p>Haz preguntas sobre programación web y nuestro asistente te ayudará.</p>\n+\n+        {/* Componente de reconocimiento de voz con props para la comunicación */}\n+        <VoiceRecognition \n+          onTextRecognized={sendToGemini}\n+          responseData={geminiResponse}\n+          isLoadingResponse={isLoadingGemini}\n+          responseError={geminiError}\n+        />\n+\n+        {/* ADVERTENCIA DE SEGURIDAD EN EL FRONTEND */}\n+        <div style={{ color: '#e65100', backgroundColor: '#fff3e0', borderColor: '#ffcc80', padding: '15px', border: '1px solid', borderRadius: '8px', margin: '20px', fontSize: '0.9em' }}>\n+          <p style={{ fontWeight: 'bold' }}>⚠️ ADVERTENCIA DE SEGURIDAD (Solo Desarrollo):</p>\n+          <p>La clave de API de Gemini está en el código frontend. Esto NO es seguro para producción.</p>\n+          <p>Para producción, envía el texto reconocido a un <strong>backend</strong> seguro que realice la llamada a la API de Gemini con tu clave.</p>\n+        </div>\n+      </main>\n+    </div>\n+  );\n+};\n+\n+export default MiComponenteBasico;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746987430246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,127 +1,1024 @@\n-import React, { useState, useRef } from 'react';\n-// Importa la librería cliente oficial de Google Generative AI para JS\n-import { GoogleGenerativeAI } from '@google/generative-ai';\n-// Importa el componente de reconocimiento de voz (renombrado)\n-import VoiceRecognition from './Componentes-Iniciado/Micro-enter';\n-// Importa el componente Navbar\n-import Navbar from '../../components/Navbar';\n-import SideBar from './Componentes-Iniciado/SideBar';\n-import './Logica.css';\n+// src/pages/LoggedIn/Logica.jsx (o LogicSectionPage.jsx)\n+import React, { useState, useEffect, useCallback, useRef } from 'react'; // Importa useCallback y useRef\n+// Importa tus componentes de UI\n+import Navbar from '../../components/Navbar'; // <-- Ajusta esta ruta si es necesario\n+import SideBar from './Componentes-Iniciado/SideBar'; // <-- Ajusta esta ruta si es necesario\n+// Importa tu componente VoiceRecognition\n+import VoiceRecognition from \"./Componentes-Iniciado/Micro-enter\"; // <-- Ajusta esta ruta si es necesario\n+// Importa tus funciones de API\n+// getAuthenticatedUserFromSession lee el user object de sessionStorage['user'] y lo parsea\n+import { getUserProgress, getLogicProblem, submitLogicAnswer, getAuthenticatedUserFromSession } from \"../../utils/api\"; // <-- Ajusta esta ruta si es necesario\n \n-// --- ¡¡¡ ADVERTENCIA DE SEGURIDAD !!! ---\n-// !!! NO PONGAS TU CLAVE DE API DIRECTAMENTE AQUÍ EN CÓDIGO PARA PRODUCCIÓN !!!\n-// Esto es solo para demostración. Para producción, la llamada a la API debe hacerse desde un BACKEND SEGURO.\n-const API_KEY = \"AIzaSyClAldN4Lvq3HjK1MgogyFdMzitzAqAkXM\";\n \n-const MiComponenteBasico = () => {\n-  // Estados para manejar la comunicación con Gemini\n-  const [geminiResponse, setGeminiResponse] = useState('');\n-  const [isLoadingGemini, setIsLoadingGemini] = useState(false);\n-  const [geminiError, setGeminiError] = useState('');\n+// ---> IMPORTA TU HOOK DEL CONTEXTO DE AUTENTICACIÓN <---\n+// Usamos 'user' y 'loading' del contexto. El token se lee de sessionStorage en api.js.\n+// 'user' del contexto nos dirá si el AuthContext considera al usuario logeado.\n+import { useAuth } from '../../context/AuthContext'; // <-- ¡AJUSTA LA RUTA A TU CONTEXTO!\n+import { use } from 'react';\n \n-  // Referencias para la comunicación con Gemini\n-  const genAiRef = useRef(null);\n-  const modelRef = useRef(null);\n-  const isGeminiCallingRef = useRef(false);\n+// TODO: Si usas react-router-dom para navegación de salida, impórtalo aquí\n+// import { useNavigate } from 'react-router-dom';\n \n-  // Configuración de Gemini\n-  const MODEL_NAME = 'gemini-2.0-flash';\n-  const generationConfig = {\n-    \"temperature\": 0.5,\n-  };\n \n-  // Contexto específico para esta sección - personalizable\n-  const CONTEXT_PREFIX = \"Eres un asistente experto en programación web. \";\n-  const PROMPT_PREFIX = CONTEXT_PREFIX + \"Responde de forma concisa a lo siguiente: \";\n+// Importa Web Speech API (aunque ya no la usemos directamente para hablar, puede ser útil para verificar disponibilidad o voces)\n+const SpeechSynthesis = window.speechSynthesis;\n+const SpeechSynthesisUtterance = window.SpeechSynthesisUtterance; // No se usa directamente en speakText ahora\n \n-  // Función para enviar el texto reconocido a Gemini\n-  const sendToGemini = async (text, isClearRequest = false) => {\n-    // Si es una solicitud de limpieza, simplemente resetear los estados\n-    if (isClearRequest) {\n-      setGeminiResponse('');\n-      setGeminiError('');\n-      return;\n+\n+// --- Definir los estados posibles de la interacción ---\n+const INTERACTION_STATES = {\n+    IDLE: 'idle', // Estado inicial, esperando que cargue el AuthContext\n+    LOADING_PROGRESS: 'loading_progress', // Cargando progreso del backend\n+    SHOWING_PROGRESS: 'showing_progress', // Progreso cargado y listo para ser leído/mostrado\n+    OFFERING_CHOICES: 'offering_choices', // Preguntando al usuario qué quiere hacer (practicar, progreso, salir)\n+    ASKING_DIFFICULTY: 'asking_difficulty', // Preguntando qué dificultad quiere practicar\n+    LOADING_PROBLEM: 'loading_problem', // Cargando un problema específico del backend\n+    PRESENTING_PROBLEM: 'presenting_problem', // Problema cargado y leído, esperando que el usuario grabe (tecla Enter)\n+    RECORDING_ANSWER: 'recording_answer', // El usuario está grabando (VoiceRecognition está activo)\n+    PROCESSING_ANSWER: 'processing_answer', // Enviando respuesta al backend, esperando LLM\n+    SHOWING_FEEDBACK: 'showing_feedback', // Feedback del LLM cargado y listo para ser leído/mostrado\n+    POST_FEEDBACK_CHOICES: 'post_feedback_choices', // Preguntando al usuario qué hacer después del feedback (otro, cambiar, salir)\n+    ERROR: 'error', // Algo salió mal, esperando instrucción de recuperación/salida\n+    EXITING: 'exiting' // Saliendo de la sección\n+};\n+\n+let repeticion = 1;\n+// --- Flag para Session Storage para primera visita ---\n+const LOGIC_VISIT_FLAG_KEY = 'hasVisitedLogicSection'; // Clave para sessionStorage\n+\n+// --- Helper para verificar si es la primera visita en esta sesión ---\n+const isFirstLogicVisit = () => {\n+    // Si la clave no existe en sessionStorage, es la primera visita\n+    return sessionStorage.getItem(LOGIC_VISIT_FLAG_KEY) === null;\n+};\n+\n+// --- Helper para marcar que ya visitamos la sección en esta sesión ---\n+const setLogicVisitFlag = () => {\n+    // Guardar cualquier valor para indicar que ya visitamos\n+    sessionStorage.setItem(LOGIC_VISIT_FLAG_KEY, 'true');\n+};\n+\n+\n+// --- Helper para leer texto por voz (llamando al backend) ---\n+// Esta función se define FUERA del componente principal.\n+// Devuelve el objeto Audio si la reproducción se inicia correctamente.\n+const speakText = async (text, onEndCallback = null) => {\n+    if (!text) {\n+        console.warn(\"[speakText] Llamada con texto vacío. Ignorando.\");\n+         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n+        return null; // Devolver null si no se intenta reproducir\n     }\n+    // Cancelar síntesis previa del navegador (la que usábamos antes, por si acaso)\n+    // SpeechSynthesis.cancel(); // Descomentar si antes usabas fallback TTS del navegador\n \n-    // Evitar enviar prompts vacíos o si ya hay una llamada en curso\n-    if (!text.trim() || isLoadingGemini || isGeminiCallingRef.current) {\n-      console.log(\"Saltando llamada a Gemini: texto vacío o ya hay una llamada en progreso.\");\n-      return;\n+    console.log(`[speakText] Solicitando voz al backend para: \"${text.substring(0, Math.min(text.length, 50))}\"...`);\n+\n+    // URL del endpoint de backend que genera voz.\n+    // Debe coincidir con la API_BASE_URL de tu api.js + el endpoint /tts.\n+    const API_TTS_URL = \"http://127.0.0.1:8003/auth/api/logic/tts\"; // <-- ¡AJUSTA ESTA URL!\n+\n+    const token = sessionStorage.getItem('access_token'); // Obtener token directamente de sessionStorage\n+    if (!token) {\n+         console.error(\"[speakText] ERROR: No se encontró token en sessionStorage['access_token'] para la llamada TTS al backend.\");\n+         // Opcional: Usar un TTS de fallback del navegador si no hay token o falla el backend\n+         // speakTextFallback(text, onEndCallback); // Necesitarías implementar esta función\n+         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n+         return null; // Devolver null si no hay token\n\\ No newline at end of file\n     }\n \n-    setIsLoadingGemini(true);\n-    isGeminiCallingRef.current = true;\n-    setGeminiResponse('');\n-    setGeminiError('');\n+    // console.log(\"[speakText] Token encontrado en sessionStorage. Haciendo fetch a backend TTS.\"); // Redundante con log anterior\n \n+\n     try {\n-      // Inicializar el cliente y el modelo si no existen ya\n-      if (!genAiRef.current) {\n-        if (!API_KEY) {\n-          throw new Error(\"API Key de Gemini no configurada correctamente.\");\n+        const response = await fetch(API_TTS_URL, {\n+            method: 'POST',\n+            headers: {\n+                'Content-Type': 'application/json', // El backend /tts espera JSON {\"text\": ...}\n+                'Authorization': `Bearer ${token}`, // Adjuntar el token\n+            },\n+            body: JSON.stringify({ text: text }), // Enviar el texto en un cuerpo JSON\n+        });\n+\n+        console.log(`[speakText] Fetch completado. Status: ${response.status} ${response.statusText}`);\n+\n+        if (!response.ok) {\n+            let errorDetail = `Backend TTS error: ${response.status} ${response.statusText}`;\n+             let errorBody = null;\n+             try {\n+                 errorBody = await response.json();\n+                 console.error(\"[speakText] Backend Error Body (Parsed):\", errorBody); // Log el cuerpo de error\n+                 if (errorBody && errorBody.detail) {\n+                     if (Array.isArray(errorBody.detail)) { errorDetail += \" - Validation Errors: \" + errorBody.detail.map(err => `${err.loc.join('.')}: ${err.msg}`).join(\"; \"); }\n+                     else { errorDetail += ` - Detail: ${errorBody.detail}`; }\n+                 } else { errorDetail += \" - No detailed error body provided.\"; }\n+             } catch (e) { console.error(\"[speakText] Failed to parse backend error body as JSON.\", e); }\n+            console.error(\"[speakText] ERROR: Llamada al backend TTS falló.\", errorDetail);\n+            // Opcional: Usar un TTS de fallback del navegador si falla el backend\n+            // speakTextFallback(text, onEndCallback);\n+             if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n+            return null; // Devolver null si la llamada falló\n         }\n-        genAiRef.current = new GoogleGenerativeAI(API_KEY);\n-      }\n-      if (!modelRef.current) {\n-        modelRef.current = genAiRef.current.getGenerativeModel({\n-          model: MODEL_NAME,\n-          generationConfig: generationConfig,\n+\n+        console.log(\"[speakText] Backend TTS respondió OK. Convirtiendo respuesta a Blob.\");\n+        const audioBlob = await response.blob();\n+        const audioUrl = URL.createObjectURL(audioBlob);\n+\n+        console.log(\"[speakText] Blob creado. Reproduciendo audio.\");\n+        const audio = new Audio(audioUrl);\n+\n+        // Configurar el callback para cuando termine la reproducción\n+        audio.onended = () => {\n+            console.log(\"[speakText] Audio playback finished.\");\n+            URL.revokeObjectURL(audioUrl); // Limpiar el Blob URL después de usarlo\n+            if (onEndCallback && typeof onEndCallback === 'function') {\n+                 onEndCallback(); // Ejecutar el callback al finalizar\n+            }\n+        };\n+\n+         // Configurar manejo de errores de reproducción de audio\n+        audio.onerror = (e) => {\n+             console.error(\"[speakText] ERROR: Audio playback error.\", e);\n+             URL.revokeObjectURL(audioUrl); // Limpiar el Blob URL en caso de error\n+              if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n+        };\n+\n+\n+        // Reproducir el audio\n+        audio.play().catch(playError => {\n+            // play() retorna una Promesa, capturar errores de reproducción (ej. navegador bloquea autoplay)\n+             console.error(\"[speakText] ERROR: Error starting audio playback.\", playError);\n+             // Limpiar el Blob URL\n+             URL.revokeObjectURL(audioUrl);\n+              if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n         });\n+\n+        return audio; // Devolver el objeto Audio si la reproducción se inicia (no garantiza que termine)\n+\n+    } catch (error) {\n+        // Este catch captura errores de red o errores lanzados antes de response.ok\n+        console.error(\"[speakText] ERROR: Error during fetch or initial processing.\", error);\n+        // Opcional: Usar un TTS de fallback del navegador si falla la llamada\n+        // speakTextFallback(text, onEndCallback);\n+         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n+        return null; // Devolver null si hubo un error en el fetch/proceso inicial\n+    }\n+};\n+\n+// Helper para manejar errores de flujo de interacción y pasar al estado ERROR (definida fuera)\n+// Ya no necesita speakText como argumento porque speakText es global\n+const handleInteractionErrorHelper = (errorMsg, setProblemError, setInteractionState, speakText, navigateToLogin = false, navigate = null) => { // speakText ya no se pasa, usar la función global\n+     console.error(\"[LogicPage] Interaction Error:\", errorMsg);\n+     // Solo seteamos el error visual/para TTS si no es el error de no autenticado que puede ser manejado por redirección\n+     if (errorMsg !== \"Debes iniciar sesión para acceder a esta sección.\") {\n+          setProblemError(errorMsg); // Usamos problemError para errores de flujo general\n+     }\n+     setInteractionState(INTERACTION_STATES.ERROR); // Pasar a estado ERROR\n+     // Aquí llamamos a speakText directamente (ya no se pasa como argumento)\n+     speakText(`Error del sistema: ${errorMsg}. Por favor, intenta de nuevo o sal con Escape.`, () => {\n+          if(navigateToLogin && navigate){\n+              // Implementar navegación de salida aquí si es un error de autenticación\n+              console.log(\"[LogicPage] Redirecting to login after auth error.\");\n+              navigate('/login'); // Ejemplo con react-router-dom\n+              // logout(); // Si la redirección también implica limpiar sesión actual\n+          }\n+     });\n+};\n+\n+\n+export const LogicSectionPage = () => {\n+  // --- Estado de la Sidebar (si lo usas, mantener esta parte) ---\n+   const [isSidebarExpanded, setIsSidebarExpanded] = useState(false);\n+   const handleSidebarToggle = useCallback((expanded) => { // Use useCallback for stability\n+     setIsSidebarExpanded(expanded);\n+   }, []); // Empty dependency array as it doesn't depend on anything else\n+\n+  // --- Obtener estado de autenticación del contexto ---\n+   // Usamos 'user' y 'loading' del contexto. El token se lee de sessionStorage en api.js.\n+   // 'user' del contexto nos dirá si el AuthContext considera al usuario logeado.\n+   const { user, loading: authLoading, logout } = useAuth();\n+   // Opcional: Loguear si el token existe en sessionStorage (para depuración)\n+   console.log(\"[LogicPage] Auth State (from Context):\", { user: user?.email, authLoading });\n+   console.log(\"[LogicPage] Token State (from SessionStorage):\", sessionStorage.getItem('access_token') ? 'exists' : 'null');\n+\n+\n+  // TODO: Si usas react-router-dom para navegación de salida, inicializa el hook aquí\n+  // const navigate = useNavigate();\n+\n+\n+  // --- Estado principal de la interacción ---\n+  const [interactionState, setInteractionState] = useState(INTERACTION_STATES.IDLE);\n+\n+  // --- Estados de datos ---\n+  const [userProgress, setUserProgress] = useState(null); // Progreso cargado\n+  const [currentProblem, setCurrentProblem] = useState(null); // Problema actual\n+  const [backendFeedback, setBackendFeedback] = useState(''); // Feedback del LLM\n+  const [recognizedText, setRecognizedText] = useState(''); // Texto de VoiceRecognition\n+\n+  // --- Estados de errores ---\n+  const [progressError, setProgressError] = useState(null); // Error al cargar progreso (No usado actualmente, se usa problemError)\n+  const [problemError, setProblemError] = useState(null); // Error cargar problem, mensaje \"no hay problem\", o error de flujo gral\n+  const [backendError, setBackendError] = useState(''); // Errores de submit_answer o reconocimiento vacío\n+\n+  // --- REFERENCIA PARA EL AUDIO ACTUALMENTE REPRODUCIÉNDOSE ---\n+  const audioRef = useRef(null); // Para mantener la referencia del objeto Audio\n+\n+  // --- Helper para detener el audio actual y reproducir uno nuevo ---\n+  // Esta es la función que llamaremos DENTRO del componente para iniciar una reproducción.\n+  // Usa useCallback para que sea estable y no cause re-renders innecesarios.\n+  const speakAndStopOthers = useCallback(async (text, onEndCallback = null) => {\n+      // 1. Detener cualquier audio que se esté reproduciendo a través de esta referencia\n+      if (audioRef.current) {\n+          console.log(\"[speakAndStopOthers] Deteniendo audio previo.\");\n+          audioRef.current.pause(); // Pausar\n+          audioRef.current.currentTime = 0; // Resetear tiempo (opcional)\n+           // No limpiamos la referencia ni el URL aquí, speakText lo hará al terminar/error si devuelve el objeto audio.\n       }\n \n-      // Construir el prompt completo con el prefijo del contexto\n-      const fullPrompt = PROMPT_PREFIX + text;\n-      console.log(\"Enviando a Gemini:\", fullPrompt);\n+       // Llamar a la función speakText global que hace el fetch y crea el Audio object\n+       // speakText AHORA DEBE DEVOLVER el objeto Audio si la llamada y creación fueron exitosas.\n+       const audioObject = await speakText(text, onEndCallback); // Pasar el callback original\n \n-      // Llamar a la API usando streaming\n-      const result = await modelRef.current.generateContentStream(fullPrompt);\n+       // Si speakText devolvió el objeto Audio, guardarlo en la referencia\n+       if (audioObject) {\n+            audioRef.current = audioObject;\n+       } else {\n+            // Si speakText devolvió null (error o texto vacío), asegurar que la referencia se limpia\n+            audioRef.current = null;\n+       }\n \n-      // Procesar el stream de respuesta\n-      let responseText = '';\n-      for await (const chunk of result.stream) {\n-        const chunkText = chunk.text() || '';\n-        responseText += chunkText;\n-        setGeminiResponse(prev => prev + chunkText);\n+   }, []); // Dependencias: ninguna si speakText es global y no usa estados/props\n+\n+\n+    // --- Helper para manejar errores de flujo de interacción (Usar useCallback) ---\n+    const handleInteractionError = useCallback((errorMsg, navigateToLogin = false) => {\n+        // Pasa null por navigate si no lo usas/necesitas aquí, o pasa el hook navigate si lo usas:\n+        // const navigate = useNavigate(); // <--- Descomentar si usas react-router-dom\n+        handleInteractionErrorHelper(errorMsg, setProblemError, setInteractionState, speakText, navigateToLogin, null); // O pasa 'navigate' si lo tienes\n+    }, [setProblemError, setInteractionState, speakText]); // Dependencias necesarias para el hook useCallback (añadir navigate si se usa)\n+\n+\n+  // --- Función para verificar si los datos mínimos de auth están en SessionStorage ---\n+  // Esta función reemplaza la verificación de 'token' en los triggers de los useEffect\n+  // Verificamos si las claves específicas de sessionStorage existen y tienen contenido.\n+  // Esto NO valida el contenido, solo si están presentes.\n+  const isAuthDataReadyForFlow = useCallback(() => {\n+       // Revisa si los campos clave existen en sessionStorage y no están vacíos.\n+       const tokenExists = typeof sessionStorage.getItem('access_token') === 'string' && sessionStorage.getItem('access_token').length > 0;\n+       const userJsonExists = typeof sessionStorage.getItem('user') === 'string' && sessionStorage.getItem('user').length > 0;\n+\n+       // Verificamos también si el AuthContext logró setear un user object.\n+       // Esto ayuda a asegurar que el AuthContext al menos intentó inicializarse.\n+        const userObjectExistsInContext = !!user; // user viene de useAuth()\n+\n+\n+       return tokenExists && userJsonExists && userObjectExistsInContext && !authLoading; // AuthContext debe haber terminado de cargar\n+\n+  }, [user, authLoading]); // Depende de si el user object en context cambia y si authLoading termina.\n+\n+\n+  // --- Función para cargar el progreso ---\n+  const loadProgress = useCallback(async () => {\n+         // SOLO ejecutar la llamada a la API si estamos en el estado correcto (LOADING_PROGRESS)\n+         if (interactionState !== INTERACTION_STATES.LOADING_PROGRESS) {\n+              console.log(`[LogicPage] loadProgress API call skipped. State is ${interactionState}.`);\n+              return; // No hacer la llamada API si no estamos en el estado LOADING_PROGRESS\n+         }\n+         // Si ya tenemos progreso y no estamos en un estado que requiera recarga (ej. después de resolver)\n+         // podemos saltar la llamada API, pero debemos asegurar la transición al siguiente estado.\n+         if (userProgress && (interactionState !== INTERACTION_STATES.ERROR && interactionState !== INTERACTION_STATES.POST_FEEDBACK_CHOICES)) {\n+              console.log(\"[LogicPage] Progress already loaded. Skipping API call.\");\n+               // Si estábamos en LOADING_PROGRESS pero ya teníamos datos, pasar a mostrar.\n+               setInteractionState(INTERACTION_STATES.SHOWING_PROGRESS);\n+              return;\n+         }\n+\n+\n+         console.log(\"[LogicPage] Executing actual progress API call.\");\n+         // El estado ya debe ser LOADING_PROGRESS al llegar aquí.\n+\n+         // Verificamos ANTES de la llamada API que los datos de auth estén en SessionStorage.\n+         // La función getUserProgress (en api.js) también lo verifica internamente llamando a getAuthTokenFromSession.\n+         if (!isAuthDataReadyForFlow()) { // <-- Usamos la nueva verificación aquí\n+              console.error(\"[LogicPage] loadProgress API call attempted without sufficient auth data in SessionStorage!\");\n+               // Esto no debería pasar si el flujo de estados es correcto, pero es una seguridad.\n+              handleInteractionError(\"No se encontraron datos de inicio de sesión válidos. Por favor, inicia sesión de nuevo.\", true); // Redirigir/error\n+              return;\n+         }\n+\n+\n+         try {\n+           // LLAMADA API - SIN PASAR TOKEN (ya lo obtiene internamente de sessionStorage)\n+           const progressData = await getUserProgress();\n+           setUserProgress(progressData);\n+           console.log(\"[LogicPage] Progress API call successful.\");\n+           setInteractionState(INTERACTION_STATES.SHOWING_PROGRESS); // Transición después de cargar\n+\n+         } catch (error) {\n+           console.error(\"[LogicPage] Progress API call failed:\", error);\n+            // Si es un error 401 de API, significa que el token de sessionStorage es inválido/expirado (el backend lo rechazó)\n+            // Asumiendo que el error tiene una propiedad status (puede variar según cómo manejes los errores de fetch/axios)\n+             if (error && error.status === 401) {\n+                  handleInteractionError(\"Tu sesión ha expirado. Por favor, inicia sesión de nuevo.\", true); // Redirigir/error\n+             } else {\n+                 handleInteractionError(`No se pudo cargar el progreso. ${error.message || 'Error desconocido'}`); // Transición a ERROR\n+             }\n+\n+         }\n+    }, [userProgress, interactionState, handleInteractionError, getUserProgress, setUserProgress, setInteractionState, isAuthDataReadyForFlow]); // Dependencias. Asegurarse de que getUserProgress es estable.\n+\n+\n+  // --- useEffect para la Inicialización (Controla el flujo inicial IDLE -> OFFERING_CHOICES o ERROR) ---\n+  // Este efecto solo reacciona a cambios en el estado de autenticación y al estado IDLE\n+  useEffect(() => {\n+      console.log(\"[LogicPage] Auth state or interactionState changed.\", { user: user?.email, authLoading, interactionState });\n+\n+      // Si Auth context termina de cargar Y estamos en el estado inicial IDLE\n+      if (!authLoading && interactionState === INTERACTION_STATES.IDLE) {\n+          // Check if required auth data EXISTS IN SESSIONSTORAGE para iniciar el flujo\n+          if (isAuthDataReadyForFlow()) { // <-- Usamos la nueva verificación\n+            // Datos de autenticación necesarios encontrados en SessionStorage, START the flow\n+            console.log(\"[LogicPage] Auth finished, auth data found in SessionStorage. Offering initial choices.\");\n+            setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); // <-- CAMBIO CLAVE: Ir directo a ofrecer opciones\n+            \n+          } else {\n+            // Auth finished loading, but NO required data found in SessionStorage. User is NOT authenticated for this section.\n+            console.warn(\"[LogicPage] Auth finished loading, but NO auth data found in SessionStorage. User not authenticated for this section.\");\n+            // Set a message and transition to ERROR state (marking it as an auth error)\n+            handleInteractionError(\"Debes iniciar sesión para acceder a esta sección.\", true); // Pasar true para posible redirección\n+          }\n+        } else if (interactionState === INTERACTION_STATES.OFFERING_CHOICES) {\n+            // Auth finished loading, and we are in IDLE state. This means we are ready to offer choices.\n+            speakAndStopOthers(\"¿Quieres practicar lógica, escuchar tu progreso, o salir?\")\n+            }\n+        else {\n+            // Auth finished loading, but we are NOT in IDLE state.\n+            // This means the flow was already started (or in ERROR etc.). Do nothing in this effect.\n+            console.log(`[LogicPage] Auth finished, but state is ${interactionState}. Initial load already handled.`);\n+        }\n       }\n+      // If authLoading is true, the component is still initializing auth, do nothing in this effect yet.\n \n-      console.log(\"Respuesta de Gemini finalizada.\");\n+  , [user, authLoading, interactionState, handleInteractionError, setInteractionState, isAuthDataReadyForFlow]); // Dependencias (Usamos user en lugar de token)\n \n-    } catch (e) {\n-      console.error(\"Error llamando a la API de Gemini:\", e);\n-      setGeminiError(`Error de Gemini: ${e.message || 'Desconocido'}. Verifica tu API key y la consola.`);\n-      setGeminiResponse('');\n-    } finally {\n-      setIsLoadingGemini(false);\n-      isGeminiCallingRef.current = false;\n+\n+  // --- useEffect que se activa cuando el estado es LOADING_PROGRESS para llamar a la API ---\n+  // Este useEffect es DISPARADO AHORA SOLO por el comando \"progreso\" en handleTextRecognized.\n+  // Su lógica interna sigue llamando a loadProgress API call cuando el estado es LOADING_PROGRESS\n+  useEffect(() => {\n+       if (interactionState === INTERACTION_STATES.LOADING_PROGRESS) {\n+           console.log(\"[LogicPage] Entering LOADING_PROGRESS state. Initiating API call.\");\n+           loadProgress();\n+       }\n+\n+  }, [interactionState, loadProgress]); // Dependencia: se ejecuta cuando interactionState cambia a LOADING_PROGRESS (y loadProgress es estable)\n+\n+\n+  // --- useEffect para leer el progreso y pasar a OFERTAR OPCIONES ---\n+  // Se activa cuando el estado es SHOWING_PROGRESS\n+  useEffect(() => {\n+       if (interactionState === INTERACTION_STATES.SHOWING_PROGRESS && userProgress) {\n+           console.log(\"[LogicPage] Entering SHOWING_PROGRESS state. Reading progress.\");\n+           // LINE 231 (CORRECTED): Ensure correct template literal syntax\n+           let progressText = `Tu progreso. Total resueltos: ${userProgress.total_solved}. Promedio general: ${userProgress.overall_average_grade !== null ? userProgress.overall_average_grade.toFixed(2) : 'N/A'}. `;\n+           Object.entries(userProgress.progress_by_difficulty).forEach(([level, data]) => {\n+                progressText += `Nivel ${level}: ${data.solved_count} resueltos${data.solved_count > 0 ? `, promedio ${data.average_grade.toFixed(2)}` : ''}. `;\n+           });\n+           // Leer el progreso y, al terminar, pasar al estado OFFERING_CHOICES\n+           speakAndStopOthers(progressText, () => {\n+                console.log(\"[LogicPage] Reading progress finished. Offering choices.\");\n+                setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); // Transición después de leer\n+           });\n+\n+       }\n+  }, [interactionState, userProgress, setInteractionState, speakAndStopOthers]); // Depende de interactionState, userProgress, setInteractionState, y speakAndStopOthers\n+\n+\n+// --- Función para cargar un nuevo problema ---\n+const loadNewProblem = useCallback(async (difficulty = null) => {\n+    console.log(`[LogicPage] loadNewProblem - INICIO. Dificultad: ${difficulty}. Estado actual de interacción: ${interactionState}`);\n+\n+    // Verificamos que los datos de auth estén en SessionStorage antes de intentar API call\n+    if (!isAuthDataReadyForFlow()) {\n+        console.error(\"[LogicPage] loadNewProblem - Falla la verificación isAuthDataReadyForFlow.\");\n+        handleInteractionError(\"No hay datos de inicio de sesión disponibles en SessionStorage para cargar problema.\", true); // Redirigir/error\n+        return;\n     }\n-  };\n \n+    // Evitar múltiples cargas o llamadas si ya estamos en proceso\n+    if (interactionState === INTERACTION_STATES.LOADING_PROBLEM || interactionState === INTERACTION_STATES.PROCESSING_ANSWER) {\n+        console.warn(`[LogicPage] loadNewProblem - Se intentó cargar pero ya estaba en estado: ${interactionState}. Se ignora.`);\n+        return;\n+    }\n+\n+    console.log(\"[LogicPage] loadNewProblem - Estableciendo estado a LOADING_PROBLEM y reseteando estados relevantes.\");\n+    setInteractionState(INTERACTION_STATES.LOADING_PROBLEM); // Nuevo estado: Cargando problema\n+    setProblemError(null); // Limpiar errores anteriores de problema/no hay problemas\n+    setCurrentProblem(null); // Limpiar problema anterior\n+    console.log(\"[LogicPage] loadNewProblem - currentProblem reseteado a null.\"); // LOG CLAVE\n+    setRecognizedText(''); // Limpiar input anterior de voz\n+    setBackendFeedback(''); // Limpiar feedback anterior\n+    setBackendError(''); // Limpiar errores de submit_answer/reconocimiento\n+\n+    try {\n+        console.log(\"[LogicPage] loadNewProblem - Llamando a getLogicProblem con dificultad:\", difficulty);\n+        const problemData = await getLogicProblem(difficulty);\n+        // Usar JSON.stringify para ver la estructura completa si es un objeto complejo.\n+        // Si problemData puede ser undefined o null, tener cuidado con stringify.\n+        console.log(\"[LogicPage] loadNewProblem - Datos recibidos de getLogicProblem:\", typeof problemData === 'object' ? JSON.stringify(problemData) : problemData); // LOG CLAVE\n+\n+        if (problemData && problemData._id) { // Asegúrate que aquí es _id\n+            setCurrentProblem(problemData);\n+            console.log(\"[LogicPage] loadNewProblem - setCurrentProblem EJECUTADO con datos. ID del Problema:\", problemData._id); // LOG CLAVE\n+            setInteractionState(INTERACTION_STATES.PRESENTING_PROBLEM); // Indicar que el problema está listo para ser leído\n+            console.log(\"[LogicPage] loadNewProblem - Estado cambiado a PRESENTING_PROBLEM.\");\n+        } else if (problemData && problemData.message) { // Si tiene un 'message', es el mensaje de no hay problemas\n+            setCurrentProblem(null); // Asegurar que no haya problema actual\n+            setProblemError(problemData.message); // Almacenar el mensaje\n+            console.warn(\"[LogicPage] loadNewProblem - No hay problemas disponibles. Mensaje:\", problemData.message);\n+            speakAndStopOthers(`Mensaje del sistema. ${problemData.message}`, () => {\n+                console.log(\"[LogicPage] loadNewProblem - Mensaje 'No hay problemas' leído. Cambiando estado a OFFERING_CHOICES.\");\n+                setInteractionState(INTERACTION_STATES.OFFERING_CHOICES);\n+            });\n+        } else {\n+            // Es posible que problemData sea null, undefined, o un formato inesperado\n+            console.error(\"[LogicPage] loadNewProblem - problemData no tiene _id ni message. problemData recibido:\", typeof problemData === 'object' ? JSON.stringify(problemData) : problemData); // LOG CLAVE\n+            handleInteractionError(\"Error inesperado al obtener problema: Formato de respuesta desconocido o datos incompletos.\");\n+        }\n+    } catch (error) {\n+        console.error(\"[LogicPage] loadNewProblem - ERROR en el bloque try-catch:\", error);\n+        if (error && error.status === 401) {\n+            handleInteractionError(\"Tu sesión ha expirado. Por favor, inicia sesión de nuevo.\", true);\n+        } else {\n+            handleInteractionError(`No se pudo obtener un nuevo problema. ${error.message || 'Error desconocido'}`);\n+        }\n+    }\n+}, [interactionState, handleInteractionError, /*getLogicProblem,*/ /*setInteractionState,*/ /*setCurrentProblem,*/ /*setProblemError,*/ /*setRecognizedText,*/ /*setBackendFeedback,*/ /*setBackendError,*/ isAuthDataReadyForFlow, speakAndStopOthers]);\n+// NOTA SOBRE DEPENDENCIAS:\n+// Las dependencias comentadas son las funciones de estado (setX) o funciones importadas que usualmente son estables.\n+// ESlint puede quejarse si no están, pero si sabes que son estables, a veces se omiten para evitar re-creaciones innecesarias del callback.\n+// Sin embargo, es más seguro incluirlas todas como las tenías originalmente si no estás seguro:\n+// [interactionState, handleInteractionError, getLogicProblem, setInteractionState, setCurrentProblem, setProblemError, setRecognizedText, setBackendFeedback, setBackendError, isAuthDataReadyForFlow, speakAndStopOthers]\n+\n+   // --- useEffect para leer el problema y pasar a PRESENTING_PROBLEM ---\n+   // Se activa cuando el estado es PRESENTING_PROBLEM\n+   useEffect(() => {\n+        if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM && currentProblem && currentProblem.text) {\n+            console.log(\"[LogicPage] Entering PRESENTING_PROBLEM state. Reading problem.\");\n+            // Leer el problema y, al terminar, decir al usuario cómo grabar.\n+            // El estado se mantiene en PRESENTING_PROBLEM hasta que VoiceRecognition actúe (grabe/suelte Enter).\n+            speakAndStopOthers(`Problema. Dificultad ${currentProblem.difficulty}. ${currentProblem.text}. Presiona y mantén Enter para grabar tu respuesta.`, () => {\n+                  console.log(\"[LogicPage] Instruction to record read.\");\n+                  // No hacemos transición de estado aquí. La transición RECORDING_ANSWER\n+                  // la manejará handleListeningStatusChange (if implementamos la prop).\n+            });\n+\n+        }\n+   }, [interactionState, currentProblem, speakAndStopOthers]); // Dependencias\n+\n+\n+\n+    // --- Función para manejar el envío de la respuesta ---\n+    // Es llamada desde handleTextRecognized cuando el estado es PRESENTING_PROBLEM y hay texto\n+    const handleAnswerSubmission = useCallback(async (answerText, problemId) => {\n+         // Verificamos que los datos de auth estén en SessionStorage antes de intentar API call\n+         if (!isAuthDataReadyForFlow() || !problemId || !answerText) { // <-- Usamos la nueva verificación\n+             handleInteractionError(\"Faltan datos (autenticación o respuesta/problema) para enviar la respuesta.\");\n+             setInteractionState(INTERACTION_STATES.ERROR); // Asegurarse de ir a ERROR si faltan datos\n+             return;\n+         }\n+          // Solo procesar si estábamos en estado PRESENTING_PROBLEM esperando respuesta\n+          // OJO: Podríamos estar en RECORDING_ANSWER si handleTextRecognized se llama justo al terminar de grabar\n+          if (interactionState !== INTERACTION_STATES.PRESENTING_PROBLEM && interactionState !== INTERACTION_STATES.RECORDING_ANSWER) {\n+               console.warn(\"[LogicPage] handleAnswerSubmission called in incorrect state:\", interactionState);\n+               return; // Solo procesar si estábamos esperando una respuesta al problema\n+          }\n+\n+         setInteractionState(INTERACTION_STATES.PROCESSING_ANSWER); // Nuevo estado: Procesando respuesta\n+         setBackendError(''); // Limpiar errores anteriores de submit_answer\n+\n+\n+         try {\n+           // LLAMADA API - SIN PASAR TOKEN (ya lo obtiene internamente)\n+           const feedbackResponse = await submitLogicAnswer(problemId, answerText); // <-- YA NO PASAMOS TOKEN AQUÍ\n+\n+           // La respuesta del backend debe tener el formato del LLM: { analysis: \"...\", grade: X }\n+           if (feedbackResponse && typeof feedbackResponse.analysis === 'string' && typeof feedbackResponse.grade === 'number') {\n+                // Almacenar feedback para mostrar/leer\n+                setBackendFeedback(`Análisis: ${feedbackResponse.analysis} | Calificación: ${feedbackResponse.grade}/5.`); // Añadimos punto final para TTS\n+                console.log(\"[LogicPage] Feedback recibido:\", feedbackResponse);\n+                 // Transición de estado después de recibir feedback\n+                setInteractionState(INTERACTION_STATES.SHOWING_FEEDBACK); // Indicar que el feedback está listo para ser leído\n+\n+                // Opcional: Recargar el progreso en segundo plano (sin esperar await) para la siguiente visualización\n+                getUserProgress().then(setUserProgress).catch(e => console.error(\"Error reloading progress silently:\", e));\n+\n+           } else if (feedbackResponse && typeof feedbackResponse.detail === 'string') {\n+                // Si el backend devuelve un error de HTTP con detalle\n+                 handleInteractionError(`Error del backend: ${feedbackResponse.detail}`);\n+           }\n+           else {\n+                // Formato de respuesta de feedback inesperado\n+                handleInteractionError(\"Error: Formato de feedback del backend inesperado.\");\n+           }\n+\n+         } catch (error) {\n+           console.error(\"[LogicPage] Error al enviar respuesta al backend:\", error);\n+            // Si es un error 401 de API\n+             if (error && error.status === 401) {\n+                  handleInteractionError(\"Tu sesión ha expirado. Por favor, inicia sesión de nuevo.\", true); // Redirigir/error\n+             } else {\n+                 handleInteractionError(`Error al procesar respuesta: ${error.message || 'Error desconocido'}`);\n+             }\n+         }\n+         // Nota: El estado se actualiza en el try/catch. Si todo falla, se va al estado ERROR.\n+         // El estado PROCESSING_ANSWER se mantiene hasta que una de las ramas try/catch/error lo cambie.\n+    }, [interactionState, handleInteractionError, submitLogicAnswer, setInteractionState, setBackendFeedback, setBackendError, getUserProgress, setUserProgress, isAuthDataReadyForFlow]); // Dependencias\n+\n+\n+    // --- useEffect para leer el feedback y pasar a POST_FEEDBACK_CHOICES ---\n+    // Se activa cuando el estado es SHOWING_FEEDBACK\n+    useEffect(() => {\n+       if (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && backendFeedback) {\n+           console.log(\"[LogicPage] Entering SHOWING_FEEDBACK state. Reading feedback.\");\n+           // Leer feedback y, al terminar, pasar al estado POST_FEEDBACK_CHOICES\n+            speakAndStopOthers(`Feedback del asistente. ${backendFeedback}`, () => { // <-- USAR speakAndStopOthers\n+                 console.log(\"[LogicPage] Reading feedback finished. Offering post-feedback choices.\");\n+                 setInteractionState(INTERACTION_STATES.POST_FEEDBACK_CHOICES); // Transición después de leer\n+                 // Al pasar a POST_FEEDBACK_CHOICES, la función handleTextRecognized\n+                 // interpretará los comandos \"otro\", \"cambiar\", \"salir\", \"progreso\".\n+                 // Opcional: Decir por voz las opciones principales después del feedback\n+                  speakAndStopOthers(\"¿Quieres otro problema, cambiar dificultad, escuchar tu progreso, o salir?\"); // Es útil para guiar al usuario\n+            });\n+       } else if (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && backendError) {\n+            // Si hay un error de backend que llegó a SHOWING_FEEDBACK\n+            console.log(\"[LogicPage] Entering SHOWING_FEEDBACK state with backend error.\", backendError);\n+             // No leer el error de \"no voz detectada\"\n+             if (backendError !== \"No se detectó voz. Intenta hablar más claro.\") {\n+                  speakAndStopOthers(`Error del sistema. ${backendError}. Por favor, intenta de nuevo o sal con Escape.`, () => { // <-- USAR speakAndStopOthers\n+                      // Después de leer el error, pasar a un estado donde se pueda salir o reintentar\n+                      console.log(\"[LogicPage] Reading backend error finished. Transitioning to ERROR.\");\n+                      setInteractionState(INTERACTION_STATES.ERROR); // Pasar a estado ERROR\n+                  });\n+             } else {\n+                 // Si el error fue solo \"no detectó voz\", volver al estado de presentar problema para reintentar\n+                 console.log(\"[LogicPage] Reading 'no speech' error. Returning to PRESENTING_PROBLEM.\");\n+                 // Limpiamos el error para que no se muestre visualmente persistentemente\n+                 setBackendError(''); // Limpiar el error\n+                 setInteractionState(INTERACTION_STATES.PRESENTING_PROBLEM); // Volver a esperar grabación\n+                  speakAndStopOthers(\"No detecté tu respuesta. Intenta de nuevo. Presiona y mantén Enter para grabar.\"); // <-- USAR speakAndStopOthers\n+             }\n+       }\n+    }, [interactionState, backendFeedback, backendError, setInteractionState, setBackendError, speakAndStopOthers]); // Dependencias\n+\n+\n+    // --- Función para manejar el texto reconocido (el INTERPRETE DE COMANDOS) ---\n+    // Es llamada por VoiceRecognition cuando la grabación termina y hay texto o está vacía\n+    const handleTextRecognized = useCallback(async (text, isClearRequest = false) => {\n+       // Guardar el texto reconocido solo si no es una solicitud de limpieza total\n+       if (!isClearRequest) {\n+            setRecognizedText(text); // Actualizar el estado local del texto reconocido\n+             // Opcional: Leer el texto reconocido al usuario para confirmación si lo deseas en algún estado\n+             // if (interactionState === INTERACTION_STATES.SOME_STATE_TO_CONFIRM_INPUT) { speakAndStopOthers(`Dijiste: ${text}`); } // <-- USAR speakAndStopOthers si se hace\n+       }\n+\n+       // Limpiar el estado de backendError si fue por voz vacía de la vez anterior\n+       // Esto asegura que el mensaje visual y el estado de error se limpien\n+       if (backendError === \"No se detectó voz. Intenta hablar más claro.\") {\n+            setBackendError('');\n+       }\n+\n+\n+       // Lógica para limpiar la UI (si VoiceRecognition tiene un botón de limpiar que llama a esto)\n+       if (isClearRequest) {\n+           console.log(\"[LogicPage] Clear request received from VoiceRecognition.\");\n+           setRecognizedText('');\n+           setBackendFeedback('');\n+           setBackendError('');\n+           setProblemError(null); // Limpiar errores de problema/flujo\n+           // Volver a un estado neutral o el de ofrecer opciones principal\n+           setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); // Ejemplo: Volver a ofrecer opciones\n+            speakAndStopOthers(\"Conversación limpiada. ¿Quieres practicar lógica, escuchar tu progreso, o salir?\"); // <-- USAR speakAndStopOthers\n+           return;\n+       }\n+\n+       const lowerText = text.toLowerCase().trim();\n+\n+       // Si no hay texto reconocido válido después de la grabación (y no fue una solicitud de limpieza)\n+       if (!lowerText) {\n+            console.warn(\"[LogicPage] Grabación finalizada sin texto reconocido después de trim.\");\n+            // Si estábamos en un estado que esperaba una respuesta hablada (que no sea la respuesta al problema)\n+            if (interactionState === INTERACTION_STATES.ASKING_DIFFICULTY ||\n+                interactionState === INTERACTION_STATES.OFFERING_CHOICES ||\n+                interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES ||\n+                interactionState === INTERACTION_STATES.ERROR) // También si esperábamos un comando de error/salida\n+             {\n+                 // Decir que no se entendió y repetir las opciones/pregunta\n+                 speakAndStopOthers(\"No detecté voz. Por favor, repite tu elección.\"); // <-- USAR speakAndStopOthers\n+                 // Mantener el estado actual para esperar otra respuesta hablada\n+             } else if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM || interactionState === INTERACTION_STATES.RECORDING_ANSWER) { // Aceptar también si VR termina antes de que el estado cambie a RECORDING_ANSWER\n+                 // Si estábamos esperando la respuesta al problema pero no se detectó voz\n+                  setBackendError(\"No se detectó voz. Intenta hablar más claro.\"); // Usamos backendError para este mensaje\n+                  // El useEffect de leer feedback/error lo leerá y nos devolverá a PRESENTING_PROBLEM\n+             } else {\n+                  // En otros estados (ej. LOADING, SHOWING_PROGRESS, PROCESSING_ANSWER, RECORDING_ANSWER), simplemente ignorar voz vacía.\n+                  console.log(\"Voz vacía ignorada en estado:\", interactionState);\n+             }\n+            return; // Salir de la función si no hay texto para procesar\n+       }\n+\n+        // --- Interpretación de Comandos Basada en el Estado ---\n+        console.log(`[LogicPage] Procesando texto \"${lowerText}\" en estado: ${interactionState}`);\n+\n+\n+       switch (interactionState) {\n+           case INTERACTION_STATES.OFFERING_CHOICES: // Esperando \"practicar\", \"progreso\", \"salir\"\n+               if (lowerText.includes('practicar') || lowerText.includes('ejercicio')) {\n+                   setInteractionState(INTERACTION_STATES.ASKING_DIFFICULTY);\n+                   speakAndStopOthers(\"Okay. ¿Qué dificultad quieres practicar: básico, intermedio o avanzado?\"); // <-- USAR speakAndStopOthers\n+               } else if (lowerText.includes('progreso') || lowerText.includes('estadísticas')) {\n+                   // Volver a leer el progreso. Pasamos por SHOWING_PROGRESS.\n+                   setInteractionState(INTERACTION_STATES.LOADING_PROGRESS); // Transicionar a LOADING_PROGRESS para forzar recarga/relectura\n+               } else if (lowerText.includes('salir') || lowerText.includes('adiós')) {\n+                   setInteractionState(INTERACTION_STATES.EXITING);\n+                   speakAndStopOthers(\"Adiós. Espero verte pronto.\", () => { /* ... */ }); // <-- USAR speakAndStopOthers\n+               } else {\n+                   // Comando no reconocido en este estado\n+                   speakAndStopOthers(\"No entendí. ¿Quieres practicar lógica, escuchar tu progreso, o salir?\"); // <-- USAR speakAndStopOthers\n+                   // Mantener el estado OFFERING_CHOICES\n+               }\n+               break;\n+\n+           case INTERACTION_STATES.ASKING_DIFFICULTY: // Esperando \"básico\", \"intermedio\", \"avanzado\"\n+                if (lowerText.includes('básico') || lowerText.includes('basico')) {\n+                   loadNewProblem('basico'); // loadNewProblem cambiará el estado a LOADING_PROBLEM\n+               } else if (lowerText.includes('intermedio')) {\n+                   loadNewProblem('intermedio'); // loadNewProblem cambiará el estado\n+               } else if (lowerText.includes('avanzado')) {\n+                   loadNewProblem('avanzado'); // loadNewProblem cambiará el estado\n+               } else {\n+                   // Dificultad no reconocida\n+                   speakAndStopOthers(\"Dificultad no válida. Por favor, di básico, intermedio o avanzado.\"); // <-- USAR speakAndStopOthers\n+                   // Mantener el estado ASKING_DIFFICULTY\n+               }\n+               break;\n+\n+           case INTERACTION_STATES.PRESENTING_PROBLEM: // Esperando la respuesta al problema (la grabación ya terminó)\n+           case INTERACTION_STATES.RECORDING_ANSWER: // Aceptar también si VR termina antes de que el estado cambie a RECORDING_ANSWER\n+               // Si llegamos aquí con texto, es la respuesta al problema.\n+               if (lowerText) { // Asegurarse de que la transcripción no esté vacía después de trim\n+                   // Verificar si tenemos un currentProblem válido antes de intentar submit\n+                    if (currentProblem && currentProblem.id) {\n+                       handleAnswerSubmission(lowerText, currentProblem.id); // Llamar a la función de submit\n+                    } else {\n+                         console.warn(\"[LogicPage] Texto reconocido pero no hay currentProblem.id válido. Ignorando.\");\n+                          // Podríamos informar al usuario por voz que no hay problema activo\n+                          // speakAndStopOthers(\"No hay un problema activo para responder.\"); // <-- USAR speakAndStopOthers si se hace\n+                    }\n+               } else {\n+                   console.warn(\"[LogicPage] Texto de respuesta al problema vacío después de trim.\");\n+                   // Ya se maneja el error de \"No detectó voz\" arriba.\n+               }\n+               break;\n+\n+           case INTERACTION_STATES.POST_FEEDBACK_CHOICES: // Feedback leído, esperando \"otro\", \"cambiar\", \"salir\", \"progreso\"\n+                if (lowerText.includes('otro') || lowerText.includes('siguiente')) {\n+                    // Cargar otro problema del MISMO NIVEL\n+                    const nextDifficulty = currentProblem?.difficulty; // Usar la dificultad del problema recién resuelto\n+                    if (nextDifficulty) {\n+                         speakAndStopOthers(\"Okay, buscando otro problema...\", () => { // <-- USAR speakAndStopOthers\n+                              loadNewProblem(nextDifficulty); // Cargar siguiente del mismo nivel\n+                         });\n+                    } else {\n+                         // Si no sabemos la dificultad del problema anterior, pedirla de nuevo (caso raro)\n+                         speakAndStopOthers(\"Okay, otro problema...\", () => { // <-- USAR speakAndStopOthers\n+                              setInteractionState(INTERACTION_STATES.ASKING_DIFFICULTY);\n+                              speakAndStopOthers(\"¿Qué dificultad quieres practicar?\"); // <-- USAR speakAndStopOthers\n+                         });\n+                    }\n+                } else if (lowerText.includes('cambiar') || lowerText.includes('dificultad')) {\n+                    // Pedir cambiar dificultad\n+                    setInteractionState(INTERACTION_STATES.ASKING_DIFFICULTY);\n+                    speakAndStopOthers(\"Okay. ¿Qué dificultad quieres practicar: básico, intermedio o avanzado?\"); // <-- USAR speakAndStopOthers\n+                } else if (lowerText.includes('salir') || lowerText.includes('adiós')) {\n+                    setInteractionState(INTERACTION_STATES.EXITING);\n+                   speakAndStopOthers(\"Adiós. Espero verte pronto.\", () => { /* ... */ }); // <-- USAR speakAndStopOthers\n+                } else if (lowerText.includes('progreso') || lowerText.includes('estadísticas')) {\n+                     // Leer progreso y volver a ofrecer opciones post-feedback\n+                    speakAndStopOthers(\"Okay, revisemos tu progreso.\", () => { // <-- USAR speakAndStopOthers\n+                         // Mostrar progreso (ya debería estar cargado). El useEffect se encargará de leerlo y volver a OFFERING_CHOICES\n+                         // Si queremos que después de leer progreso vuelva a POST_FEEDBACK_CHOICES, necesitaríamos lógica adicional.\n+                         // Por simplicidad, lo mandamos a LOADING_PROGRESS para releerlo y luego a OFFERING_CHOICES.\n+                         setInteractionState(INTERACTION_STATES.LOADING_PROGRESS); // Dispara la carga/relectura\n+                    });\n+                }\n+                else {\n+                    // Comando no reconocido en este estado\n+                    speakAndStopOthers(\"No entendí. ¿Quieres otro problema, cambiar dificultad, escuchar tu progreso, o salir?\"); // <-- USAR speakAndStopOthers\n+                    // Mantener el estado POST_FEEDBACK_CHOICES\n+                }\n+               break;\n+\n+           case INTERACTION_STATES.ERROR: // En estado de error, esperando comando de recuperación/salida\n+                if (lowerText.includes('salir') || lowerText.includes('adiós')) {\n+                     setInteractionState(INTERACTION_STATES.EXITING);\n+                       speakAndStopOthers(\"Okay, saliendo.\", () => { /* ... */ }); // <-- USAR speakAndStopOthers\n+                } else if (lowerText.includes('intentar') || lowerText.includes('empezar') || lowerText.includes('inicio') || lowerText.includes('reiniciar')) {\n+                     // Intentar reiniciar el flujo\n+                      speakAndStopOthers(\"Okay, intentemos desde el inicio.\", () => { // <-- USAR speakAndStopOthers\n+                           // Limpiar estados relevantes\n+                           setCurrentProblem(null);\n+                           setProblemError(null);\n+                           setBackendFeedback('');\n+                           setBackendError('');\n+                           setRecognizedText('');\n+                           setUserProgress(null); // Forzar recarga de progreso\n+                           // Volver al inicio del flujo principal (cargar progreso)\n+                           setInteractionState(INTERACTION_STATES.LOADING_PROGRESS); // Dispara la carga/relectura\n+                      });\n+                }\n+                else {\n+                     // Comando no reconocido en estado de error\n+                     speakAndStopOthers(\"No entendí. ¿Quieres salir, o intentar desde el inicio?\"); // <-- USAR speakAndStopOthers\n+                     // Mantener estado ERROR\n+                }\n+               break;\n+\n+           default: // Ignorar voz en otros estados (IDLE, LOADING, PROCESSING, RECORDING)\n+               console.log(`[LogicPage] Texto \"${lowerText}\" ignorado en estado: ${interactionState}`);\n+               break;\n+       }\n+    }, [interactionState, currentProblem, backendError, loadNewProblem, handleAnswerSubmission, setInteractionState, setRecognizedText, setBackendFeedback, setBackendError, setProblemError, setCurrentProblem, setUserProgress, handleInteractionError, speakAndStopOthers]); // Dependencias\n+\n+\n+    // --- Manejar el cambio de estado de escucha de VoiceRecognition (NUEVO) ---\n+    // Necesitas pasar esta función a tu componente VoiceRecognition como prop onListeningChange\n+    // VoiceRecognition debe llamar a esta prop con true/false\n+    const handleListeningStatusChange = useCallback((isListening) => {\n+        // Si VoiceRecognition empieza a escuchar y estábamos esperando la grabación de respuesta\n+        if (isListening && interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n+            console.log(\"[LogicPage] VoiceRecognition started listening. Transitioning to RECORDING_ANSWER.\");\n+            setInteractionState(INTERACTION_STATES.RECORDING_ANSWER); // Pasar a estado grabando\n+        } else if (!isListening && interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n+            // Si VoiceRecognition deja de escuchar y estábamos grabando\n+            console.log(\"[LogicPage] VoiceRecognition stopped listening. Awaiting text processing from handleTextRecognized.\");\n+            // handleTextRecognized se llamará automáticamente por VoiceRecognition al terminar la grabación.\n+            // El estado se mantendrá en RECORDING_ANSWER brevemente o pasará directamente a PROCESSING_ANSWER\n+            // si hay texto. Si no hay texto, handleTextRecognized lo maneja.\n+        } else {\n+            // Ignorar cambios de estado de escucha en otros estados\n+            // console.log(`[LogicPage] VoiceRecognition listening status (${isListening}) change ignored in state: ${interactionState}`);\n+        }\n+    }, [interactionState, setInteractionState]); // Dependencias\n+\n+\n+    // --- Implementar listener de teclado general (para acciones como Escape y Enter de flujo) ---\n+    useEffect(() => {\n+        const handleKeyDown = (event) => {\n+             // No procesar si un input/textarea tiene foco (si tuvieras alguno)\n+             if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {\n+                 return;\n+             }\n+\n+            // Ignorar eventos de teclado si está en un estado de carga o procesamiento crítico donde no queremos interrupción.\n+            // O si está grabando (Enter lo maneja VR, Escape podría ser útil pero puede ser confuso)\n+            if (interactionState === INTERACTION_STATES.LOADING_PROGRESS ||\n+                interactionState === INTERACTION_STATES.LOADING_PROBLEM ||\n+                interactionState === INTERACTION_STATES.PROCESSING_ANSWER ||\n+                interactionState === INTERACTION_STATES.EXITING\n+               ) {\n+                 // console.log(`[LogicPage] Keyboard event (${event.key}) ignored during critical state: ${interactionState}`);\n+                return;\n+               }\n+\n+            // --- Manejar tecla Escape ---\n+             if (event.key === 'Escape') {\n+                // Permitir salir desde cualquier estado excepto los críticos ya filtrados\n+                 console.log(\"[LogicPage] Escape pressed. Initiating exit.\");\n+                 SpeechSynthesis.cancel(); // Limpiar cualquier TTS que esté hablando (menos crítico ahora con speakAndStopOthers, pero buena práctica)\n+                 // Asegurar que cualquier audio de backend también se detenga\n+                 if (audioRef.current) {\n+                      audioRef.current.pause();\n+                      audioRef.current.currentTime = 0;\n+                       if (audioRef.current.url) URL.revokeObjectURL(audioRef.current.url);\n+                      audioRef.current = null;\n+                 }\n+                 // Asegurar que el micrófono se detenga si estaba activo\n+                  setInterruptTrigger(prev => prev + 1);\n+\n+\n+                 setInteractionState(INTERACTION_STATES.EXITING);\n+                  speakAndStopOthers(\"Saliendo de la sección de lógica. Adiós.\", () => { // <-- USAR speakAndStopOthers\n+                      // TODO: Implementar navegación para salir de la sección\n+                      console.log(\"[LogicPage] Implementación de navegación de salida.\");\n+                       // const navigate = useNavigate(); navigate('/'); // Ejemplo con react-router-dom, requiere el hook useNavigate\n+                       // logout(); // Si salir también implica hacer logout también\n+                  });\n+                 event.preventDefault(); // Prevenir comportamiento por defecto\n+                 return; // No procesar Enter si ya se presionó Escape\n+             }\n+\n+            if (event.key === 'Enter') {\n+                // 1. Si ya se está grabando, VoiceRecognition lo maneja (para detener).\n+                //    Logica.jsx no hace nada.\n+                if (interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n+                    console.log(\"[LogicPage] Enter pressed during RECORDING_ANSWER. Handled by VoiceRecognition.\");\n+                    // VoiceRecognition.jsx debe llamar a event.preventDefault() si lo necesita.\n+                    return;\n+                }\n+\n+                // 2. Si estamos en un estado donde VoiceRecognition está visible y esperando\n+                //    Enter para INICIAR la grabación, Logica.jsx tampoco debe interferir.\n+                const isVoiceRecognitionActiveAndWaitingToStart = [\n+                    INTERACTION_STATES.OFFERING_CHOICES,\n+                    INTERACTION_STATES.ASKING_DIFFICULTY,\n+                    INTERACTION_STATES.PRESENTING_PROBLEM,\n+                    INTERACTION_STATES.POST_FEEDBACK_CHOICES,\n+                    INTERACTION_STATES.ERROR\n+                    // Asegúrate de que esta lista coincida con los estados donde VR está\n+                    // activo y Enter inicia la grabación.\n+                ].includes(interactionState);\n+\n+                if (isVoiceRecognitionActiveAndWaitingToStart) {\n+                    console.log(`[LogicPage] Enter pressed in state ${interactionState}. VoiceRecognition should handle this to START recording. Logica.jsx takes no action.`);\n+                    // VoiceRecognition.jsx debe llamar a event.preventDefault() si lo necesita.\n+                    return;\n+                }\n+\n+                // 3. Si llegamos aquí, Enter NO es para el micrófono en este momento.\n+                //    Y como NO quieres que Enter repita audios desde Logica.jsx,\n+                //    eliminamos toda la lógica que hacía eso.\n+                //    Lo que sigue es lo que puedes borrar de tu bloque original:\n+                //\n+                //    console.log(\"[LogicPage] Enter pressed outside recording. Repeating prompt or triggering action.\"); // <-- BORRAR o cambiar mensaje\n+                //    event.preventDefault(); // <-- BORRAR si Enter no debe hacer nada globalmente, o mantener si quieres prevenir default action siempre.\n+                //\n+                //    // TODAS LAS SIGUIENTES CONDICIONES if/else if QUE LLAMAN A speakAndStopOthers DEBEN SER BORRADAS:\n+                //    // if (interactionState === INTERACTION_STATES.ASKING_DIFFICULTY) { ... } <--- BORRAR\n+                //    // else if (interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES) { ... } <--- BORRAR\n+                //    // else if (interactionState === INTERACTION_STATES.ERROR && problemError) { ... } <--- BORRAR\n+                //    // else if (interactionState === INTERACTION_STATES.SHOWING_PROGRESS && userProgress) { ... } <--- BORRAR\n+                //    // else if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM && currentProblem) { ... } <--- BORRAR (esta ya estaría cubierta por la guarda de arriba de todas formas)\n+                //    // else if (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && backendFeedback) { ... } <--- BORRAR\n+\n+                // En su lugar, puedes dejar un log para saber que se presionó Enter\n+                // y no se tomó acción deliberadamente, o incluso no hacer nada.\n+                console.log(`[LogicPage] Enter pressed in state ${interactionState}. No TTS repeat action defined in Logica.jsx for Enter.`);\n+                // Opcional: Si quieres que Enter no haga absolutamente nada (como scroll, submit de form si existiera)\n+                // en estos otros casos, puedes dejar un event.preventDefault();\n+                // event.preventDefault();\n+            }\n+\n+                 // Opcional: Implementar que Enter *después* de feedback pase al siguiente problema sin voz\n+                 // if (interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.SHOWING_FEEDBACK) {\n+                 //     console.log(\"[LogicPage] Enter pressed after feedback. Loading next problem.\");\n+                 //      const nextDifficulty = currentProblem?.difficulty;\n+                 //      if (nextDifficulty) { loadNewProblem(nextDifficulty); } else { setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); speakText(\"¿Qué dificultad quieres practicar?\"); }\n+                 // }\n+\n+\n+                 event.preventDefault(); // Prevenir comportamiento por defecto del Enter (ej. en formularios)\n+            }\n+        \n+\n+        window.addEventListener('keydown', handleKeyDown);\n+        return () => {\n+            window.removeEventListener('keydown', handleKeyDown);\n+            SpeechSynthesis.cancel(); // Limpiar TTS al desmontar\n+        };\n+    }, [interactionState, speakAndStopOthers, handleInteractionError, loadNewProblem, userProgress, currentProblem, backendFeedback, problemError]); // Dependencias\n+\n+\n+    // Define los anchos de la sidebar (si los usas para layout)\n+    const sidebarCollapsedWidth = 60; // px\n+    const sidebarExpandedWidth = 250; // px\n+    const mainContentPaddingLeft = isSidebarExpanded ? sidebarExpandedWidth : sidebarCollapsedWidth;\n+\n+\n+    // --- Lógica de renderizado condicional ---\n+    // Mostramos diferentes mensajes o componentes según el estado de interacción\n   return (\n-    <div className=\"app-container\">\n-      <SideBar />\n-      <main className=\"content\">\n+    // Contenedor principal\n+    \n+    <div className=\"flex min-h-screen bg-gradient-to-br from-gray-50 to-gray-100\">\n+      {/* SideBar (si lo usas) */}\n+      {/* ASEGÚRATE DE QUE ESTA LÍNEA NO ESTÉ COMENTADA Y LA RUTA SEA CORRECTA */}\n+      <SideBar isExpanded={isSidebarExpanded} onToggleExpansion={handleSidebarToggle} />\n+\n+      {/* Contenedor del Contenido Principal */}\n+      <main\n+        className=\"flex-1 min-w-0 overflow-x-hidden\"\n+        style={{ paddingLeft: `${mainContentPaddingLeft}px`, transition: 'padding-left 0.3s ease' }}\n+      >\n+        {/* Navbar (si lo usas) */}\n+         {/* ASEGÚRATE DE QUE ESTA LÍNEA NO ESTÉ COMENTADA Y LA RUTA SEA CORRECTA */}\n         <Navbar />\n \n-        <h1>Centro de ayuda de programación</h1>\n-        <p>Haz preguntas sobre programación web y nuestro asistente te ayudará.</p>\n+        {/* Contenido específico de la Sección de Lógica */}\n+        <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\"> {/* CORREGIDO: lg-px-8 -> lg:px-8 */}\n+            <h1>Sección de Lógica de Programación</h1>\n+            <p>Aquí puedes practicar problemas de lógica. Tu progreso y las respuestas serán analizadas.</p>\n \n-        {/* Componente de reconocimiento de voz con props para la comunicación */}\n-        <VoiceRecognition \n-          onTextRecognized={sendToGemini}\n-          responseData={geminiResponse}\n-          isLoadingResponse={isLoadingGemini}\n-          responseError={geminiError}\n-        />\n+            {/* Mensajes de estado general o carga */}\n+            <div style={{ marginTop: '20px', fontWeight: 'bold', minHeight: '2em' }}>\n+                {/* Si el AuthContext está cargando */}\n+                {authLoading && interactionState === INTERACTION_STATES.IDLE && <p>Cargando datos de usuario...</p>}\n \n-        {/* ADVERTENCIA DE SEGURIDAD EN EL FRONTEND */}\n-        <div style={{ color: '#e65100', backgroundColor: '#fff3e0', borderColor: '#ffcc80', padding: '15px', border: '1px solid', borderRadius: '8px', margin: '20px', fontSize: '0.9em' }}>\n-          <p style={{ fontWeight: 'bold' }}>⚠️ ADVERTENCIA DE SEGURIDAD (Solo Desarrollo):</p>\n-          <p>La clave de API de Gemini está en el código frontend. Esto NO es seguro para producción.</p>\n-          <p>Para producción, envía el texto reconocido a un <strong>backend</strong> seguro que realice la llamada a la API de Gemini con tu clave.</p>\n+                {/* Mensajes basados en el estado de interacción */}\n+                {!authLoading && (\n+                    <>\n+                       {/* Mostrar IDLE si no hay user object O si no hay datos de auth en sessionStorage */}\n+                       {interactionState === INTERACTION_STATES.IDLE && !isAuthDataReadyForFlow() && <p>Iniciando sección de lógica...</p>}\n+\n+                       {interactionState === INTERACTION_STATES.LOADING_PROGRESS && <p>Cargando progreso...</p>}\n+                       {interactionState === INTERACTION_STATES.SHOWING_PROGRESS && <p>Mostrando tu progreso...</p>}\n+                       {interactionState === INTERACTION_STATES.OFFERING_CHOICES && <p>Di: \"practicar\", \"progreso\" o \"salir\".</p>}\n+                       {interactionState === INTERACTION_STATES.ASKING_DIFFICULTY && <p>Di la dificultad: \"básico\", \"intermedio\" o \"avanzado\".</p>}\n+                       {interactionState === INTERACTION_STATES.LOADING_PROBLEM && <p>Cargando problema...</p>}\n+                       {interactionState === INTERACTION_STATES.PRESENTING_PROBLEM && <p>Problema cargado. Esperando grabación...</p>}\n+                       {interactionState === INTERACTION_STATES.RECORDING_ANSWER && <p style={{color: 'green'}}>🎙️ Grabando respuesta... (Suelta 'Enter' para terminar)</p>}\n+                       {interactionState === INTERACTION_STATES.PROCESSING_ANSWER && <p>Procesando respuesta...</p>}\n+                       {interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && <p>Mostrando feedback...</p>}\n+                       {interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES && <p>Di: \"otro problema\", \"cambiar dificultad, escuchar tu progreso, o salir\".</p>}\n+                       {interactionState === INTERACTION_STATES.EXITING && <p>Saliendo...</p>}\n+                    </>\n+                )}\n+                 {/* Mostrar error general de flujo si el estado es ERROR */}\n+                 {interactionState === INTERACTION_STATES.ERROR && problemError && (\n+                     <p style={{ color: 'red', fontWeight: 'bold' }}>{problemError}. Di \"intentar de nuevo\" o \"salir\".</p>\n+                 )}\n+            </div>\n+\n+\n+            {/* Mostrar Progreso del Usuario - Solo si ha sido cargado y el estado lo permite */}\n+            {userProgress && (interactionState === INTERACTION_STATES.SHOWING_PROGRESS || interactionState === INTERACTION_STATES.OFFERING_CHOICES || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && (\n+                 <div style={{ marginTop: '20px', border: '1px solid #ccc', padding: '15px', background: '#f9f9f9' }}>\n+                     <h2>Tu Progreso</h2>\n+                     {userProgress && ( // Asegurarse de que userProgress no sea null\n+                         <div>\n+                             <p>Total resueltos: {userProgress.total_solved}</p>\n+                             <p>Promedio general: {userProgress.overall_average_grade !== null ? userProgress.overall_average_grade.toFixed(2) : 'N/A'}</p>\n+                             <ul>\n+                                 {Object.entries(userProgress.progress_by_difficulty).map(([level, data]) => (\n+                                     <li key={level}>\n+                                         {level.charAt(0).toUpperCase() + level.slice(1)}: {data.solved_count} resueltos {data.solved_count > 0 ? `(Promedio: ${data.average_grade.toFixed(2)})` : ''}\n+                                     </li>\n+                                 ))}\n+                             </ul>\n+                         </div>\n+                     )}\n+                 </div>\n+             )}\n+\n+             {/* Mostrar Problema Actual - Solo si ha sido cargado y el estado lo permite */}\n+            {currentProblem && (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM || interactionState === INTERACTION_STATES.RECORDING_ANSWER || interactionState === INTERACTION_STATES.PROCESSING_ANSWER || interactionState === INTERACTION_STATES.SHOWING_FEEDBACK || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && (\n+                <div style={{ marginTop: '20px', border: '2px solid blue', padding: '15px', background: '#eaf6ff' }}>\n+                    <h3>Problema de Lógica (Dificultad: {currentProblem.difficulty})</h3>\n+                    <p style={{ whiteSpace: 'pre-wrap' }}>{currentProblem.text}</p>\n+                </div>\n+            )}\n+\n+            {/* Integrar tu componente VoiceRecognition */}\n+            {/* Mostrarlo solo en los estados donde esperamos INPUT de voz del usuario */}\n+             {(interactionState === INTERACTION_STATES.OFFERING_CHOICES ||\n+               interactionState === INTERACTION_STATES.ASKING_DIFFICULTY ||\n+               interactionState === INTERACTION_STATES.PRESENTING_PROBLEM ||\n+               interactionState === INTERACTION_STATES.RECORDING_ANSWER ||\n+               interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES ||\n+               interactionState === INTERACTION_STATES.ERROR\n+             ) && !authLoading && ( // Añadir !authLoading para evitar mostrarlo mientras carga auth\n+                 <div style={{marginTop: '25px'}}>\n+                     <VoiceRecognition\n+                        onTextRecognized={handleTextRecognized}\n+                        isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n+                        backendError={backendError === \"No se detectó voz. Intenta hablar más claro.\" ? backendError : ''} // Mostrar solo error de no voz aquí\n+                        responseData={''} // No mostrar feedback del LLM directamente en VR, lo mostramos abajo\n+                        onListeningChange={handleListeningStatusChange}\n+                        //key={interactionState}\n+                     />\n+                 </div>\n+             )}\n+\n+             {/* Mostrar el feedback del backend (análisis/calificación) si está disponible */}\n+             {backendFeedback && (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && (\n+                 <div style={{ marginTop: '20px', border: '2px solid green', padding: '15px', background: '#eafaf9' }}>\n+                     <h3>Feedback del Asistente:</h3>\n+                     <p style={{ whiteSpace: 'pre-wrap' }}>{backendFeedback}</p>\n+                 </div>\n+             )}\n+             {/* Mostrar error específico si es el de \"no detectó voz\" */}\n+              {(interactionState === INTERACTION_STATES.PRESENTING_PROBLEM || interactionState === INTERACTION_STATES.RECORDING_ANSWER || interactionState === INTERACTION_STATES.PROCESSING_ANSWER) && backendError === \"No se detectó voz. Intenta hablar más claro.\" && (\n+                   <p style={{ color: 'orange', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>\n+              )}\n+             {/* Mostrar error general de submit/backend si existe y no es el de voz vacía */}\n+             {(interactionState === INTERACTION_STATES.PROCESSING_ANSWER || interactionState === INTERACTION_STATES.SHOWING_FEEDBACK || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && backendError && backendError !== \"No se detectó voz. Intenta hablar más claro.\" && (\n+                 <p style={{ color: 'red', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>\n+            )}\n+\n+\n         </div>\n       </main>\n     </div>\n   );\n };\n \n-export default MiComponenteBasico;\n+export default LogicSectionPage;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746998303749,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -985,18 +985,31 @@\n                interactionState === INTERACTION_STATES.RECORDING_ANSWER ||\n                interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES ||\n                interactionState === INTERACTION_STATES.ERROR\n              ) && !authLoading && ( // Añadir !authLoading para evitar mostrarlo mientras carga auth\n-                 <div style={{marginTop: '25px'}}>\n-                     <VoiceRecognition\n-                        onTextRecognized={handleTextRecognized}\n-                        isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n-                        backendError={backendError === \"No se detectó voz. Intenta hablar más claro.\" ? backendError : ''} // Mostrar solo error de no voz aquí\n-                        responseData={''} // No mostrar feedback del LLM directamente en VR, lo mostramos abajo\n-                        onListeningChange={handleListeningStatusChange}\n-                        //key={interactionState}\n-                     />\n-                 </div>\n+            // Dentro del return de LogicSectionPage.jsx\n+\n+            <div style={{marginTop: '25px'}}>\n+                <p style={{textAlign: 'center', fontWeight:'bold', marginBottom:'10px'}}>Control de Voz:</p>\n+                {(() => {\n+                    // Usamos el ID del problema actual para la key.\n+                    // Si no hay problema, usamos un valor constante.\n+                    const vrKey = currentProblem?._id || 'no-problem-active';\n+                    // El console.log que añadimos antes para depurar la key ya no es necesario aquí si confías en esta lógica.\n+                    // console.log(`>>> LOGICPAGE RENDER: Renderizando VR con key: \"${vrKey}\" | Estado: ${interactionState}`);\n+                    return (\n+                        <VoiceRecognition\n+                            onTextRecognized={handleTextRecognized}\n+                            isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n+                            // backendError y responseData no se usan por VoiceRecognition actualmente\n+                            onListeningChange={handleListeningStatusChange}\n+                            key={vrKey} // <-- ¡AÑADIR/RESTAURAR ESTA KEY ESTABLE!\n+                        />\n+                    );\n+                })()}\n+                 {recognizedText && <p style={{marginTop: '10px', fontSize: '0.9em', color: '#555'}}>Texto reconocido: \"{recognizedText}\"</p>}\n+                 {backendError && <p style={{ color: 'orange', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>}\n+             </div>\n              )}\n \n              {/* Mostrar el feedback del backend (análisis/calificación) si está disponible */}\n              {backendFeedback && (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && (\n"
                },
                {
                    "date": 1746998376316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -753,25 +753,25 @@\n     // --- Manejar el cambio de estado de escucha de VoiceRecognition (NUEVO) ---\n     // Necesitas pasar esta función a tu componente VoiceRecognition como prop onListeningChange\n     // VoiceRecognition debe llamar a esta prop con true/false\n     const handleListeningStatusChange = useCallback((isListening) => {\n-        // Si VoiceRecognition empieza a escuchar y estábamos esperando la grabación de respuesta\n+        console.log(\"[LogicPage] Micrófono:\", isListening ? \"ESCUCHANDO\" : \"DETENIDO\");\n+        if (isListening) speakAndStopOthers(\"\", () => {}); // Detener TTS si empezamos a grabar\n+\n         if (isListening && interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n-            console.log(\"[LogicPage] VoiceRecognition started listening. Transitioning to RECORDING_ANSWER.\");\n-            setInteractionState(INTERACTION_STATES.RECORDING_ANSWER); // Pasar a estado grabando\n+             setStatusMessage(\"🎙️ Grabando tu respuesta...\");\n+             setBackendError('');\n+             speakAndStopOthers(\"Adelante.\", () => { // Prompt corto\n+                  setInteractionState(INTERACTION_STATES.RECORDING_ANSWER); // <-- ASEGÚRATE QUE ESTÉ ACTIVA\n+             });\n         } else if (!isListening && interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n-            // Si VoiceRecognition deja de escuchar y estábamos grabando\n-            console.log(\"[LogicPage] VoiceRecognition stopped listening. Awaiting text processing from handleTextRecognized.\");\n-            // handleTextRecognized se llamará automáticamente por VoiceRecognition al terminar la grabación.\n-            // El estado se mantendrá en RECORDING_ANSWER brevemente o pasará directamente a PROCESSING_ANSWER\n-            // si hay texto. Si no hay texto, handleTextRecognized lo maneja.\n-        } else {\n-            // Ignorar cambios de estado de escucha en otros estados\n-            // console.log(`[LogicPage] VoiceRecognition listening status (${isListening}) change ignored in state: ${interactionState}`);\n+             setStatusMessage(\"Grabación terminada, procesando...\");\n+        } else if (!isListening) {\n+             setStatusMessage(prev => prev.startsWith(\"🎙️\") ? \"Grabación detenida. Esperando comando...\" : prev);\n         }\n-    }, [interactionState, setInteractionState]); // Dependencias\n+    // eslint-disable-next-line react-hooks/exhaustive-deps\n+    }, [interactionState, speakAndStopOthers, setStatusMessage, setInteractionState, setBackendError]); // Añadir setters si los usas directamente\n \n-\n     // --- Implementar listener de teclado general (para acciones como Escape y Enter de flujo) ---\n     useEffect(() => {\n         const handleKeyDown = (event) => {\n              // No procesar si un input/textarea tiene foco (si tuvieras alguno)\n"
                },
                {
                    "date": 1746998435774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -763,14 +763,14 @@\n              speakAndStopOthers(\"Adelante.\", () => { // Prompt corto\n                   setInteractionState(INTERACTION_STATES.RECORDING_ANSWER); // <-- ASEGÚRATE QUE ESTÉ ACTIVA\n              });\n         } else if (!isListening && interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n-             setStatusMessage(\"Grabación terminada, procesando...\");\n+             console.log(\"[LogicPage] Micrófono detenido. Procesando respuesta...\");\n         } else if (!isListening) {\n-             setStatusMessage(prev => prev.startsWith(\"🎙️\") ? \"Grabación detenida. Esperando comando...\" : prev);\n+             console.log(\"[LogicPage] Micrófono detenido, pero no estábamos grabando.\");\n         }\n     // eslint-disable-next-line react-hooks/exhaustive-deps\n-    }, [interactionState, speakAndStopOthers, setStatusMessage, setInteractionState, setBackendError]); // Añadir setters si los usas directamente\n+    }, [interactionState, speakAndStopOthers, setInteractionState, setBackendError]); // Añadir setters si los usas directamente\n \n     // --- Implementar listener de teclado general (para acciones como Escape y Enter de flujo) ---\n     useEffect(() => {\n         const handleKeyDown = (event) => {\n"
                },
                {
                    "date": 1747000550295,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -749,29 +749,33 @@\n        }\n     }, [interactionState, currentProblem, backendError, loadNewProblem, handleAnswerSubmission, setInteractionState, setRecognizedText, setBackendFeedback, setBackendError, setProblemError, setCurrentProblem, setUserProgress, handleInteractionError, speakAndStopOthers]); // Dependencias\n \n \n-    // --- Manejar el cambio de estado de escucha de VoiceRecognition (NUEVO) ---\n-    // Necesitas pasar esta función a tu componente VoiceRecognition como prop onListeningChange\n-    // VoiceRecognition debe llamar a esta prop con true/false\n-    const handleListeningStatusChange = useCallback((isListening) => {\n-        console.log(\"[LogicPage] Micrófono:\", isListening ? \"ESCUCHANDO\" : \"DETENIDO\");\n-        if (isListening) speakAndStopOthers(\"\", () => {}); // Detener TTS si empezamos a grabar\n+// Dentro de LogicSectionPage.jsx\n \n-        if (isListening && interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n-             setStatusMessage(\"🎙️ Grabando tu respuesta...\");\n-             setBackendError('');\n-             speakAndStopOthers(\"Adelante.\", () => { // Prompt corto\n-                  setInteractionState(INTERACTION_STATES.RECORDING_ANSWER); // <-- ASEGÚRATE QUE ESTÉ ACTIVA\n-             });\n-        } else if (!isListening && interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n-             console.log(\"[LogicPage] Micrófono detenido. Procesando respuesta...\");\n-        } else if (!isListening) {\n-             console.log(\"[LogicPage] Micrófono detenido, pero no estábamos grabando.\");\n-        }\n-    // eslint-disable-next-line react-hooks/exhaustive-deps\n-    }, [interactionState, speakAndStopOthers, setInteractionState, setBackendError]); // Añadir setters si los usas directamente\n+const handleListeningStatusChange = useCallback((isListening) => {\n+    console.log(\"[LogicPage] Micrófono:\", isListening ? \"ESCUCHANDO\" : \"DETENIDO\");\n+    if (isListening) {\n+        speakAndStopOthers(\"\", () => {}); // Detener cualquier TTS en curso\n+    }\n \n+    if (isListening && interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n+         // Esta línea (761 según tu log si speakAndStopOthers no estuviera) causaba el error\n+         // si setStatusMessage no estaba en las dependencias.\n+         setBackendError(''); // También necesita estar en dependencias\n+         speakAndStopOthers(\"Adelante.\", () => { // Prompt auditivo muy corto\n+              setInteractionState(INTERACTION_STATES.RECORDING_ANSWER); // También necesita estar en dependencias\n+         });\n+    } else if (!isListening && interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n+         console.log(\"[LogicPage] Grabación detenida. Esperando comando...\");\n+    } else if (!isListening) {\n+         // Esto previene que el mensaje se quede en \"Grabando...\" si se aborta desde otro estado.\n+         console.log(\"[LogicPage] Grabación detenida en estado no esperado:\", interactionState);\n+    }\n+// eslint-disable-next-line react-hooks/exhaustive-deps\n+}, [interactionState, speakAndStopOthers, setStatusMessage, setInteractionState, setBackendError]);\n+\n+\n     // --- Implementar listener de teclado general (para acciones como Escape y Enter de flujo) ---\n     useEffect(() => {\n         const handleKeyDown = (event) => {\n              // No procesar si un input/textarea tiene foco (si tuvieras alguno)\n"
                },
                {
                    "date": 1747000575597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -771,9 +771,9 @@\n          // Esto previene que el mensaje se quede en \"Grabando...\" si se aborta desde otro estado.\n          console.log(\"[LogicPage] Grabación detenida en estado no esperado:\", interactionState);\n     }\n // eslint-disable-next-line react-hooks/exhaustive-deps\n-}, [interactionState, speakAndStopOthers, setStatusMessage, setInteractionState, setBackendError]);\n+}, [interactionState, speakAndStopOthers,setInteractionState, setBackendError]);\n \n \n     // --- Implementar listener de teclado general (para acciones como Escape y Enter de flujo) ---\n     useEffect(() => {\n"
                },
                {
                    "date": 1747000636193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -749,33 +749,28 @@\n        }\n     }, [interactionState, currentProblem, backendError, loadNewProblem, handleAnswerSubmission, setInteractionState, setRecognizedText, setBackendFeedback, setBackendError, setProblemError, setCurrentProblem, setUserProgress, handleInteractionError, speakAndStopOthers]); // Dependencias\n \n \n-// Dentro de LogicSectionPage.jsx\n+    // --- Manejar el cambio de estado de escucha de VoiceRecognition (NUEVO) ---\n+    // Necesitas pasar esta función a tu componente VoiceRecognition como prop onListeningChange\n+    // VoiceRecognition debe llamar a esta prop con true/false\n+    const handleListeningStatusChange = useCallback((isListening) => {\n+        console.log(\"[LogicPage] Micrófono:\", isListening ? \"ESCUCHANDO\" : \"DETENIDO\");\n+        if (isListening) speakAndStopOthers(\"\", () => {}); // Detener TTS si empezamos a grabar\n \n-const handleListeningStatusChange = useCallback((isListening) => {\n-    console.log(\"[LogicPage] Micrófono:\", isListening ? \"ESCUCHANDO\" : \"DETENIDO\");\n-    if (isListening) {\n-        speakAndStopOthers(\"\", () => {}); // Detener cualquier TTS en curso\n-    }\n+        if (isListening && interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n+             setBackendError('');\n+             speakAndStopOthers(\"Adelante.\", () => { // Prompt corto\n+                  setInteractionState(INTERACTION_STATES.RECORDING_ANSWER); // <-- ASEGÚRATE QUE ESTÉ ACTIVA\n+             });\n+        } else if (!isListening && interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n+             console.log(\"[LogicPage] Micrófono detenido. Procesando respuesta...\");\n+        } else if (!isListening) {\n+             console.log(\"[LogicPage] Micrófono detenido, pero no estábamos grabando.\");\n+        }\n+    // eslint-disable-next-line react-hooks/exhaustive-deps\n+    }, [interactionState, speakAndStopOthers, setInteractionState, setBackendError]); // Añadir setters si los usas directamente\n \n-    if (isListening && interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n-         // Esta línea (761 según tu log si speakAndStopOthers no estuviera) causaba el error\n-         // si setStatusMessage no estaba en las dependencias.\n-         setBackendError(''); // También necesita estar en dependencias\n-         speakAndStopOthers(\"Adelante.\", () => { // Prompt auditivo muy corto\n-              setInteractionState(INTERACTION_STATES.RECORDING_ANSWER); // También necesita estar en dependencias\n-         });\n-    } else if (!isListening && interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n-         console.log(\"[LogicPage] Grabación detenida. Esperando comando...\");\n-    } else if (!isListening) {\n-         // Esto previene que el mensaje se quede en \"Grabando...\" si se aborta desde otro estado.\n-         console.log(\"[LogicPage] Grabación detenida en estado no esperado:\", interactionState);\n-    }\n-// eslint-disable-next-line react-hooks/exhaustive-deps\n-}, [interactionState, speakAndStopOthers,setInteractionState, setBackendError]);\n-\n-\n     // --- Implementar listener de teclado general (para acciones como Escape y Enter de flujo) ---\n     useEffect(() => {\n         const handleKeyDown = (event) => {\n              // No procesar si un input/textarea tiene foco (si tuvieras alguno)\n"
                },
                {
                    "date": 1747000863855,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1000,9 +1000,9 @@\n                             onTextRecognized={handleTextRecognized}\n                             isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n                             // backendError y responseData no se usan por VoiceRecognition actualmente\n                             onListeningChange={handleListeningStatusChange}\n-                            key={vrKey} // <-- ¡AÑADIR/RESTAURAR ESTA KEY ESTABLE!\n+                            key={currentProblem?._id || 'no-problem-active'}\n                         />\n                     );\n                 })()}\n                  {recognizedText && <p style={{marginTop: '10px', fontSize: '0.9em', color: '#555'}}>Texto reconocido: \"{recognizedText}\"</p>}\n"
                },
                {
                    "date": 1747000926216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -749,27 +749,41 @@\n        }\n     }, [interactionState, currentProblem, backendError, loadNewProblem, handleAnswerSubmission, setInteractionState, setRecognizedText, setBackendFeedback, setBackendError, setProblemError, setCurrentProblem, setUserProgress, handleInteractionError, speakAndStopOthers]); // Dependencias\n \n \n-    // --- Manejar el cambio de estado de escucha de VoiceRecognition (NUEVO) ---\n-    // Necesitas pasar esta función a tu componente VoiceRecognition como prop onListeningChange\n-    // VoiceRecognition debe llamar a esta prop con true/false\n     const handleListeningStatusChange = useCallback((isListening) => {\n-        console.log(\"[LogicPage] Micrófono:\", isListening ? \"ESCUCHANDO\" : \"DETENIDO\");\n-        if (isListening) speakAndStopOthers(\"\", () => {}); // Detener TTS si empezamos a grabar\n-\n-        if (isListening && interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n-             setBackendError('');\n-             speakAndStopOthers(\"Adelante.\", () => { // Prompt corto\n-                  setInteractionState(INTERACTION_STATES.RECORDING_ANSWER); // <-- ASEGÚRATE QUE ESTÉ ACTIVA\n-             });\n-        } else if (!isListening && interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n-             console.log(\"[LogicPage] Micrófono detenido. Procesando respuesta...\");\n-        } else if (!isListening) {\n-             console.log(\"[LogicPage] Micrófono detenido, pero no estábamos grabando.\");\n+        console.log(\"[LogicPage] Micrófono callback:\", isListening ? \"EMPEZÓ A ESCUCHAR\" : \"TERMINÓ DE ESCUCHAR\");\n+    \n+        if (isListening) {\n+            // El micrófono ha comenzado a escuchar\n+            speakAndStopOthers(\"\", null); // Detener cualquier TTS en curso, sin callback\n+            if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n+                console.log(\"[LogicPage] Micrófono INICIADO. Esperando respuesta al problema...\");\n+                setBackendError('');\n+                // El cambio a RECORDING_ANSWER se hará después del prompt \"Adelante\"\n+                speakAndStopOthers(\"Adelante.\", () => {\n+                    // Solo cambiar a RECORDING_ANSWER si todavía estamos en PRESENTING_PROBLEM\n+                    // para evitar cambios de estado si el usuario detuvo el mic muy rápido.\n+                    setInteractionState(prevInteractionState =>\n+                        prevInteractionState === INTERACTION_STATES.PRESENTING_PROBLEM\n+                            ? INTERACTION_STATES.RECORDING_ANSWER\n+                            : prevInteractionState\n+                    );\n+                });\n+            }\n+        } else {\n+            // El micrófono ha terminado de escuchar (onend o onerror en VoiceRecognition)\n+            if (interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n+                console.log(\"[LogicPage] Micrófono DETENIDO. Procesando respuesta...\");\n+                // VoiceRecognition llamará a onTextRecognized que manejará el siguiente estado.\n+            } else {\n+                 // Si deja de escuchar y no estábamos grabando (ej. error al iniciar),\n+                 // resetear el mensaje si se quedó en \"Grabando...\"\n+                 console.log(\"[LogicPage] Micrófono DETENIDO pero no estábamos grabando. Limpiando mensaje.\");\n+            }\n         }\n     // eslint-disable-next-line react-hooks/exhaustive-deps\n-    }, [interactionState, speakAndStopOthers, setInteractionState, setBackendError]); // Añadir setters si los usas directamente\n+    }, [interactionState, speakAndStopOthers, setInteractionState, setBackendError]);\n \n     // --- Implementar listener de teclado general (para acciones como Escape y Enter de flujo) ---\n     useEffect(() => {\n         const handleKeyDown = (event) => {\n"
                },
                {
                    "date": 1747001287955,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -759,17 +759,15 @@\n             if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n                 console.log(\"[LogicPage] Micrófono INICIADO. Esperando respuesta al problema...\");\n                 setBackendError('');\n                 // El cambio a RECORDING_ANSWER se hará después del prompt \"Adelante\"\n-                speakAndStopOthers(\"Adelante.\", () => {\n-                    // Solo cambiar a RECORDING_ANSWER si todavía estamos en PRESENTING_PROBLEM\n-                    // para evitar cambios de estado si el usuario detuvo el mic muy rápido.\n-                    setInteractionState(prevInteractionState =>\n-                        prevInteractionState === INTERACTION_STATES.PRESENTING_PROBLEM\n-                            ? INTERACTION_STATES.RECORDING_ANSWER\n-                            : prevInteractionState\n-                    );\n-                });\n+                // Solo cambiar a RECORDING_ANSWER si todavía estamos en PRESENTING_PROBLEM\n+                // para evitar cambios de estado si el usuario detuvo el mic muy rápido.\n+                setInteractionState(prevInteractionState =>\n+                    prevInteractionState === INTERACTION_STATES.PRESENTING_PROBLEM\n+                        ? INTERACTION_STATES.RECORDING_ANSWER\n+                        : prevInteractionState\n+                );\n             }\n         } else {\n             // El micrófono ha terminado de escuchar (onend o onerror en VoiceRecognition)\n             if (interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n"
                },
                {
                    "date": 1747001598670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -753,34 +753,35 @@\n     const handleListeningStatusChange = useCallback((isListening) => {\n         console.log(\"[LogicPage] Micrófono callback:\", isListening ? \"EMPEZÓ A ESCUCHAR\" : \"TERMINÓ DE ESCUCHAR\");\n     \n         if (isListening) {\n-            // El micrófono ha comenzado a escuchar\n-            speakAndStopOthers(\"\", null); // Detener cualquier TTS en curso, sin callback\n             if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n                 console.log(\"[LogicPage] Micrófono INICIADO. Esperando respuesta al problema...\");\n                 setBackendError('');\n                 // El cambio a RECORDING_ANSWER se hará después del prompt \"Adelante\"\n                 // Solo cambiar a RECORDING_ANSWER si todavía estamos en PRESENTING_PROBLEM\n-                // para evitar cambios de estado si el usuario detuvo el mic muy rápido.\n                 setInteractionState(prevInteractionState =>\n                     prevInteractionState === INTERACTION_STATES.PRESENTING_PROBLEM\n                         ? INTERACTION_STATES.RECORDING_ANSWER\n                         : prevInteractionState\n                 );\n+                // Importante: Reproducir \"Adelante\" DESPUÉS de cambiar el estado\n+                // Usar setTimeout para asegurar que el audio anterior se haya detenido\n+                setTimeout(() => {\n+                    speakAndStopOthers(\"Adelante.\");\n+                }, 100);\n             }\n         } else {\n             // El micrófono ha terminado de escuchar (onend o onerror en VoiceRecognition)\n             if (interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n                 console.log(\"[LogicPage] Micrófono DETENIDO. Procesando respuesta...\");\n                 // VoiceRecognition llamará a onTextRecognized que manejará el siguiente estado.\n             } else {\n-                 // Si deja de escuchar y no estábamos grabando (ej. error al iniciar),\n-                 // resetear el mensaje si se quedó en \"Grabando...\"\n-                 console.log(\"[LogicPage] Micrófono DETENIDO pero no estábamos grabando. Limpiando mensaje.\");\n+                // Si deja de escuchar y no estábamos grabando (ej. error al iniciar),\n+                // resetear el mensaje si se quedó en \"Grabando...\"\n+                console.log(\"[LogicPage] Micrófono DETENIDO pero no estábamos grabando. Limpiando mensaje.\");\n             }\n         }\n-    // eslint-disable-next-line react-hooks/exhaustive-deps\n     }, [interactionState, speakAndStopOthers, setInteractionState, setBackendError]);\n \n     // --- Implementar listener de teclado general (para acciones como Escape y Enter de flujo) ---\n     useEffect(() => {\n"
                },
                {
                    "date": 1747001798697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -756,20 +756,15 @@\n         if (isListening) {\n             if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n                 console.log(\"[LogicPage] Micrófono INICIADO. Esperando respuesta al problema...\");\n                 setBackendError('');\n-                // El cambio a RECORDING_ANSWER se hará después del prompt \"Adelante\"\n-                // Solo cambiar a RECORDING_ANSWER si todavía estamos en PRESENTING_PROBLEM\n+                // Cambiar a RECORDING_ANSWER sin reproducir audio para evitar conflictos\n                 setInteractionState(prevInteractionState =>\n                     prevInteractionState === INTERACTION_STATES.PRESENTING_PROBLEM\n                         ? INTERACTION_STATES.RECORDING_ANSWER\n                         : prevInteractionState\n                 );\n-                // Importante: Reproducir \"Adelante\" DESPUÉS de cambiar el estado\n-                // Usar setTimeout para asegurar que el audio anterior se haya detenido\n-                setTimeout(() => {\n-                    speakAndStopOthers(\"Adelante.\");\n-                }, 100);\n+                // Eliminamos la reproducción de \"Adelante\" que parece estar causando conflictos\n             }\n         } else {\n             // El micrófono ha terminado de escuchar (onend o onerror en VoiceRecognition)\n             if (interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n@@ -780,9 +775,9 @@\n                 // resetear el mensaje si se quedó en \"Grabando...\"\n                 console.log(\"[LogicPage] Micrófono DETENIDO pero no estábamos grabando. Limpiando mensaje.\");\n             }\n         }\n-    }, [interactionState, speakAndStopOthers, setInteractionState, setBackendError]);\n+    }, [interactionState, setInteractionState, setBackendError]);\n \n     // --- Implementar listener de teclado general (para acciones como Escape y Enter de flujo) ---\n     useEffect(() => {\n         const handleKeyDown = (event) => {\n"
                },
                {
                    "date": 1747002244361,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -996,24 +996,14 @@\n             // Dentro del return de LogicSectionPage.jsx\n \n             <div style={{marginTop: '25px'}}>\n                 <p style={{textAlign: 'center', fontWeight:'bold', marginBottom:'10px'}}>Control de Voz:</p>\n-                {(() => {\n-                    // Usamos el ID del problema actual para la key.\n-                    // Si no hay problema, usamos un valor constante.\n-                    const vrKey = currentProblem?._id || 'no-problem-active';\n-                    // El console.log que añadimos antes para depurar la key ya no es necesario aquí si confías en esta lógica.\n-                    // console.log(`>>> LOGICPAGE RENDER: Renderizando VR con key: \"${vrKey}\" | Estado: ${interactionState}`);\n-                    return (\n-                        <VoiceRecognition\n-                            onTextRecognized={handleTextRecognized}\n-                            isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n-                            // backendError y responseData no se usan por VoiceRecognition actualmente\n-                            onListeningChange={handleListeningStatusChange}\n-                            key={currentProblem?._id || 'no-problem-active'}\n-                        />\n-                    );\n-                })()}\n+                <VoiceRecognition\n+                    onTextRecognized={handleTextRecognized}\n+                    isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n+                    onListeningChange={handleListeningStatusChange}\n+                    // Eliminamos la key dinámica que causa el remontaje\n+                />\n                  {recognizedText && <p style={{marginTop: '10px', fontSize: '0.9em', color: '#555'}}>Texto reconocido: \"{recognizedText}\"</p>}\n                  {backendError && <p style={{ color: 'orange', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>}\n              </div>\n              )}\n"
                },
                {
                    "date": 1747002891002,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -997,13 +997,13 @@\n \n             <div style={{marginTop: '25px'}}>\n                 <p style={{textAlign: 'center', fontWeight:'bold', marginBottom:'10px'}}>Control de Voz:</p>\n                 <VoiceRecognition\n-                    onTextRecognized={handleTextRecognized}\n-                    isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n-                    onListeningChange={handleListeningStatusChange}\n-                    // Eliminamos la key dinámica que causa el remontaje\n-                />\n+                                onTextRecognized={handleTextRecognized}\n+                                isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n+                                onListeningChange={handleListeningStatusChange}\n+                                key={vrKey} // <-- ¡ASEGÚRATE QUE ESTA LÍNEA ESTÉ ASÍ!\n+                            />\n                  {recognizedText && <p style={{marginTop: '10px', fontSize: '0.9em', color: '#555'}}>Texto reconocido: \"{recognizedText}\"</p>}\n                  {backendError && <p style={{ color: 'orange', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>}\n              </div>\n              )}\n"
                },
                {
                    "date": 1747002913574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -997,13 +997,13 @@\n \n             <div style={{marginTop: '25px'}}>\n                 <p style={{textAlign: 'center', fontWeight:'bold', marginBottom:'10px'}}>Control de Voz:</p>\n                 <VoiceRecognition\n-                                onTextRecognized={handleTextRecognized}\n-                                isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n-                                onListeningChange={handleListeningStatusChange}\n-                                key={vrKey} // <-- ¡ASEGÚRATE QUE ESTA LÍNEA ESTÉ ASÍ!\n-                            />\n+                    onTextRecognized={handleTextRecognized}\n+                    isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n+                    onListeningChange={handleListeningStatusChange}\n+                    // Eliminamos la key dinámica que causa el remontaje\n+                />\n                  {recognizedText && <p style={{marginTop: '10px', fontSize: '0.9em', color: '#555'}}>Texto reconocido: \"{recognizedText}\"</p>}\n                  {backendError && <p style={{ color: 'orange', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>}\n              </div>\n              )}\n"
                },
                {
                    "date": 1747003600900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -666,10 +666,10 @@\n            case INTERACTION_STATES.RECORDING_ANSWER: // Aceptar también si VR termina antes de que el estado cambie a RECORDING_ANSWER\n                // Si llegamos aquí con texto, es la respuesta al problema.\n                if (lowerText) { // Asegurarse de que la transcripción no esté vacía después de trim\n                    // Verificar si tenemos un currentProblem válido antes de intentar submit\n-                    if (currentProblem && currentProblem.id) {\n-                       handleAnswerSubmission(lowerText, currentProblem.id); // Llamar a la función de submit\n+                    if (currentProblem && currentProblem._id) {\n+                       handleAnswerSubmission(lowerText, currentProblem._id); // Llamar a la función de submit\n                     } else {\n                          console.warn(\"[LogicPage] Texto reconocido pero no hay currentProblem.id válido. Ignorando.\");\n                           // Podríamos informar al usuario por voz que no hay problema activo\n                           // speakAndStopOthers(\"No hay un problema activo para responder.\"); // <-- USAR speakAndStopOthers si se hace\n"
                },
                {
                    "date": 1747004504036,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1034 @@\n+// src/pages/LoggedIn/Logica.jsx (o LogicSectionPage.jsx)\n+import React, { useState, useEffect, useCallback, useRef } from 'react'; // Importa useCallback y useRef\n+// Importa tus componentes de UI\n+import Navbar from '../../components/Navbar'; // <-- Ajusta esta ruta si es necesario\n+import SideBar from './Componentes-Iniciado/SideBar'; // <-- Ajusta esta ruta si es necesario\n+// Importa tu componente VoiceRecognition\n+import VoiceRecognition from \"./Componentes-Iniciado/Micro-enter\"; // <-- Ajusta esta ruta si es necesario\n+// Importa tus funciones de API\n+// getAuthenticatedUserFromSession lee el user object de sessionStorage['user'] y lo parsea\n+import { getUserProgress, getLogicProblem, submitLogicAnswer, getAuthenticatedUserFromSession } from \"../../utils/api\"; // <-- Ajusta esta ruta si es necesario\n+\n+\n+// ---> IMPORTA TU HOOK DEL CONTEXTO DE AUTENTICACIÓN <---\n+// Usamos 'user' y 'loading' del contexto. El token se lee de sessionStorage en api.js.\n+// 'user' del contexto nos dirá si el AuthContext considera al usuario logeado.\n+import { useAuth } from '../../context/AuthContext'; // <-- ¡AJUSTA LA RUTA A TU CONTEXTO!\n+import { use } from 'react';\n+\n+// TODO: Si usas react-router-dom para navegación de salida, impórtalo aquí\n+// import { useNavigate } from 'react-router-dom';\n+\n+\n+// Importa Web Speech API (aunque ya no la usemos directamente para hablar, puede ser útil para verificar disponibilidad o voces)\n+const SpeechSynthesis = window.speechSynthesis;\n+const SpeechSynthesisUtterance = window.SpeechSynthesisUtterance; // No se usa directamente en speakText ahora\n+\n+\n+// --- Definir los estados posibles de la interacción ---\n+const INTERACTION_STATES = {\n+    IDLE: 'idle', // Estado inicial, esperando que cargue el AuthContext\n+    LOADING_PROGRESS: 'loading_progress', // Cargando progreso del backend\n+    SHOWING_PROGRESS: 'showing_progress', // Progreso cargado y listo para ser leído/mostrado\n+    OFFERING_CHOICES: 'offering_choices', // Preguntando al usuario qué quiere hacer (practicar, progreso, salir)\n+    ASKING_DIFFICULTY: 'asking_difficulty', // Preguntando qué dificultad quiere practicar\n+    LOADING_PROBLEM: 'loading_problem', // Cargando un problema específico del backend\n+    PRESENTING_PROBLEM: 'presenting_problem', // Problema cargado y leído, esperando que el usuario grabe (tecla Enter)\n+    RECORDING_ANSWER: 'recording_answer', // El usuario está grabando (VoiceRecognition está activo)\n+    PROCESSING_ANSWER: 'processing_answer', // Enviando respuesta al backend, esperando LLM\n+    SHOWING_FEEDBACK: 'showing_feedback', // Feedback del LLM cargado y listo para ser leído/mostrado\n+    POST_FEEDBACK_CHOICES: 'post_feedback_choices', // Preguntando al usuario qué hacer después del feedback (otro, cambiar, salir)\n+    ERROR: 'error', // Algo salió mal, esperando instrucción de recuperación/salida\n+    EXITING: 'exiting' // Saliendo de la sección\n+};\n+\n+let repeticion = 1;\n+// --- Flag para Session Storage para primera visita ---\n+const LOGIC_VISIT_FLAG_KEY = 'hasVisitedLogicSection'; // Clave para sessionStorage\n+\n+// --- Helper para verificar si es la primera visita en esta sesión ---\n+const isFirstLogicVisit = () => {\n+    // Si la clave no existe en sessionStorage, es la primera visita\n+    return sessionStorage.getItem(LOGIC_VISIT_FLAG_KEY) === null;\n+};\n+\n+// --- Helper para marcar que ya visitamos la sección en esta sesión ---\n+const setLogicVisitFlag = () => {\n+    // Guardar cualquier valor para indicar que ya visitamos\n+    sessionStorage.setItem(LOGIC_VISIT_FLAG_KEY, 'true');\n+};\n+\n+\n+// --- Helper para leer texto por voz (llamando al backend) ---\n+// Esta función se define FUERA del componente principal.\n+// Devuelve el objeto Audio si la reproducción se inicia correctamente.\n+const speakText = async (text, onEndCallback = null) => {\n+    if (!text) {\n+        console.warn(\"[speakText] Llamada con texto vacío. Ignorando.\");\n+         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n+        return null; // Devolver null si no se intenta reproducir\n+    }\n+    // Cancelar síntesis previa del navegador (la que usábamos antes, por si acaso)\n+    // SpeechSynthesis.cancel(); // Descomentar si antes usabas fallback TTS del navegador\n+\n+    console.log(`[speakText] Solicitando voz al backend para: \"${text.substring(0, Math.min(text.length, 50))}\"...`);\n+\n+    // URL del endpoint de backend que genera voz.\n+    // Debe coincidir con la API_BASE_URL de tu api.js + el endpoint /tts.\n+    const API_TTS_URL = \"http://127.0.0.1:8003/auth/api/logic/tts\"; // <-- ¡AJUSTA ESTA URL!\n+\n+    const token = sessionStorage.getItem('access_token'); // Obtener token directamente de sessionStorage\n+    if (!token) {\n+         console.error(\"[speakText] ERROR: No se encontró token en sessionStorage['access_token'] para la llamada TTS al backend.\");\n+         // Opcional: Usar un TTS de fallback del navegador si no hay token o falla el backend\n+         // speakTextFallback(text, onEndCallback); // Necesitarías implementar esta función\n+         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n+         return null; // Devolver null si no hay token\n+    }\n+\n+    // console.log(\"[speakText] Token encontrado en sessionStorage. Haciendo fetch a backend TTS.\"); // Redundante con log anterior\n+\n+\n+    try {\n+        const response = await fetch(API_TTS_URL, {\n+            method: 'POST',\n+            headers: {\n+                'Content-Type': 'application/json', // El backend /tts espera JSON {\"text\": ...}\n+                'Authorization': `Bearer ${token}`, // Adjuntar el token\n+            },\n+            body: JSON.stringify({ text: text }), // Enviar el texto en un cuerpo JSON\n+        });\n+\n+        console.log(`[speakText] Fetch completado. Status: ${response.status} ${response.statusText}`);\n+\n+        if (!response.ok) {\n+            let errorDetail = `Backend TTS error: ${response.status} ${response.statusText}`;\n+             let errorBody = null;\n+             try {\n+                 errorBody = await response.json();\n+                 console.error(\"[speakText] Backend Error Body (Parsed):\", errorBody); // Log el cuerpo de error\n+                 if (errorBody && errorBody.detail) {\n+                     if (Array.isArray(errorBody.detail)) { errorDetail += \" - Validation Errors: \" + errorBody.detail.map(err => `${err.loc.join('.')}: ${err.msg}`).join(\"; \"); }\n+                     else { errorDetail += ` - Detail: ${errorBody.detail}`; }\n+                 } else { errorDetail += \" - No detailed error body provided.\"; }\n+             } catch (e) { console.error(\"[speakText] Failed to parse backend error body as JSON.\", e); }\n+            console.error(\"[speakText] ERROR: Llamada al backend TTS falló.\", errorDetail);\n+            // Opcional: Usar un TTS de fallback del navegador si falla el backend\n+            // speakTextFallback(text, onEndCallback);\n+             if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n+            return null; // Devolver null si la llamada falló\n+        }\n+\n+        console.log(\"[speakText] Backend TTS respondió OK. Convirtiendo respuesta a Blob.\");\n+        const audioBlob = await response.blob();\n+        const audioUrl = URL.createObjectURL(audioBlob);\n+\n+        console.log(\"[speakText] Blob creado. Reproduciendo audio.\");\n+        const audio = new Audio(audioUrl);\n+\n+        // Configurar el callback para cuando termine la reproducción\n+        audio.onended = () => {\n+            console.log(\"[speakText] Audio playback finished.\");\n+            URL.revokeObjectURL(audioUrl); // Limpiar el Blob URL después de usarlo\n+            if (onEndCallback && typeof onEndCallback === 'function') {\n+                 onEndCallback(); // Ejecutar el callback al finalizar\n+            }\n+        };\n+\n+         // Configurar manejo de errores de reproducción de audio\n+        audio.onerror = (e) => {\n+             console.error(\"[speakText] ERROR: Audio playback error.\", e);\n+             URL.revokeObjectURL(audioUrl); // Limpiar el Blob URL en caso de error\n+              if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n+        };\n+\n+\n+        // Reproducir el audio\n+        audio.play().catch(playError => {\n+            // play() retorna una Promesa, capturar errores de reproducción (ej. navegador bloquea autoplay)\n+             console.error(\"[speakText] ERROR: Error starting audio playback.\", playError);\n+             // Limpiar el Blob URL\n+             URL.revokeObjectURL(audioUrl);\n+              if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n+        });\n+\n+        return audio; // Devolver el objeto Audio si la reproducción se inicia (no garantiza que termine)\n+\n+    } catch (error) {\n+        // Este catch captura errores de red o errores lanzados antes de response.ok\n+        console.error(\"[speakText] ERROR: Error during fetch or initial processing.\", error);\n+        // Opcional: Usar un TTS de fallback del navegador si falla la llamada\n+        // speakTextFallback(text, onEndCallback);\n+         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n+        return null; // Devolver null si hubo un error en el fetch/proceso inicial\n+    }\n+};\n+\n+// Helper para manejar errores de flujo de interacción y pasar al estado ERROR (definida fuera)\n+// Ya no necesita speakText como argumento porque speakText es global\n+const handleInteractionErrorHelper = (errorMsg, setProblemError, setInteractionState, speakText, navigateToLogin = false, navigate = null) => { // speakText ya no se pasa, usar la función global\n+     console.error(\"[LogicPage] Interaction Error:\", errorMsg);\n+     // Solo seteamos el error visual/para TTS si no es el error de no autenticado que puede ser manejado por redirección\n+     if (errorMsg !== \"Debes iniciar sesión para acceder a esta sección.\") {\n+          setProblemError(errorMsg); // Usamos problemError para errores de flujo general\n+     }\n+     setInteractionState(INTERACTION_STATES.ERROR); // Pasar a estado ERROR\n+     // Aquí llamamos a speakText directamente (ya no se pasa como argumento)\n+     speakText(`Error del sistema: ${errorMsg}. Por favor, intenta de nuevo o sal con Escape.`, () => {\n+          if(navigateToLogin && navigate){\n+              // Implementar navegación de salida aquí si es un error de autenticación\n+              console.log(\"[LogicPage] Redirecting to login after auth error.\");\n+              navigate('/login'); // Ejemplo con react-router-dom\n+              // logout(); // Si la redirección también implica limpiar sesión actual\n+          }\n+     });\n+};\n+\n+\n+export const LogicSectionPage = () => {\n+  // --- Estado de la Sidebar (si lo usas, mantener esta parte) ---\n+   const [isSidebarExpanded, setIsSidebarExpanded] = useState(false);\n+   const handleSidebarToggle = useCallback((expanded) => { // Use useCallback for stability\n+     setIsSidebarExpanded(expanded);\n+   }, []); // Empty dependency array as it doesn't depend on anything else\n+\n+  // --- Obtener estado de autenticación del contexto ---\n+   // Usamos 'user' y 'loading' del contexto. El token se lee de sessionStorage en api.js.\n+   // 'user' del contexto nos dirá si el AuthContext considera al usuario logeado.\n+   const { user, loading: authLoading, logout } = useAuth();\n+   // Opcional: Loguear si el token existe en sessionStorage (para depuración)\n+   console.log(\"[LogicPage] Auth State (from Context):\", { user: user?.email, authLoading });\n+   console.log(\"[LogicPage] Token State (from SessionStorage):\", sessionStorage.getItem('access_token') ? 'exists' : 'null');\n+\n+\n+  // TODO: Si usas react-router-dom para navegación de salida, inicializa el hook aquí\n+  // const navigate = useNavigate();\n+\n+\n+  // --- Estado principal de la interacción ---\n+  const [interactionState, setInteractionState] = useState(INTERACTION_STATES.IDLE);\n+\n+  // --- Estados de datos ---\n+  const [userProgress, setUserProgress] = useState(null); // Progreso cargado\n+  const [currentProblem, setCurrentProblem] = useState(null); // Problema actual\n+  const [backendFeedback, setBackendFeedback] = useState(''); // Feedback del LLM\n+  const [recognizedText, setRecognizedText] = useState(''); // Texto de VoiceRecognition\n+\n+  // --- Estados de errores ---\n+  const [progressError, setProgressError] = useState(null); // Error al cargar progreso (No usado actualmente, se usa problemError)\n+  const [problemError, setProblemError] = useState(null); // Error cargar problem, mensaje \"no hay problem\", o error de flujo gral\n+  const [backendError, setBackendError] = useState(''); // Errores de submit_answer o reconocimiento vacío\n+\n+  // --- REFERENCIA PARA EL AUDIO ACTUALMENTE REPRODUCIÉNDOSE ---\n+  const audioRef = useRef(null); // Para mantener la referencia del objeto Audio\n+\n+  // --- Helper para detener el audio actual y reproducir uno nuevo ---\n+  // Esta es la función que llamaremos DENTRO del componente para iniciar una reproducción.\n+  // Usa useCallback para que sea estable y no cause re-renders innecesarios.\n+  const speakAndStopOthers = useCallback(async (text, onEndCallback = null) => {\n+      // 1. Detener cualquier audio que se esté reproduciendo a través de esta referencia\n+      if (audioRef.current) {\n+          console.log(\"[speakAndStopOthers] Deteniendo audio previo.\");\n+          audioRef.current.pause(); // Pausar\n+          audioRef.current.currentTime = 0; // Resetear tiempo (opcional)\n+           // No limpiamos la referencia ni el URL aquí, speakText lo hará al terminar/error si devuelve el objeto audio.\n+      }\n+\n+       // Llamar a la función speakText global que hace el fetch y crea el Audio object\n+       // speakText AHORA DEBE DEVOLVER el objeto Audio si la llamada y creación fueron exitosas.\n+       const audioObject = await speakText(text, onEndCallback); // Pasar el callback original\n+\n+       // Si speakText devolvió el objeto Audio, guardarlo en la referencia\n+       if (audioObject) {\n+            audioRef.current = audioObject;\n+       } else {\n+            // Si speakText devolvió null (error o texto vacío), asegurar que la referencia se limpia\n+            audioRef.current = null;\n+       }\n+\n+   }, []); // Dependencias: ninguna si speakText es global y no usa estados/props\n+\n+\n+    // --- Helper para manejar errores de flujo de interacción (Usar useCallback) ---\n+    const handleInteractionError = useCallback((errorMsg, navigateToLogin = false) => {\n+        // Pasa null por navigate si no lo usas/necesitas aquí, o pasa el hook navigate si lo usas:\n+        // const navigate = useNavigate(); // <--- Descomentar si usas react-router-dom\n+        handleInteractionErrorHelper(errorMsg, setProblemError, setInteractionState, speakText, navigateToLogin, null); // O pasa 'navigate' si lo tienes\n+    }, [setProblemError, setInteractionState, speakText]); // Dependencias necesarias para el hook useCallback (añadir navigate si se usa)\n+\n+\n+  // --- Función para verificar si los datos mínimos de auth están en SessionStorage ---\n+  // Esta función reemplaza la verificación de 'token' en los triggers de los useEffect\n+  // Verificamos si las claves específicas de sessionStorage existen y tienen contenido.\n+  // Esto NO valida el contenido, solo si están presentes.\n+  const isAuthDataReadyForFlow = useCallback(() => {\n+       // Revisa si los campos clave existen en sessionStorage y no están vacíos.\n+       const tokenExists = typeof sessionStorage.getItem('access_token') === 'string' && sessionStorage.getItem('access_token').length > 0;\n+       const userJsonExists = typeof sessionStorage.getItem('user') === 'string' && sessionStorage.getItem('user').length > 0;\n+\n+       // Verificamos también si el AuthContext logró setear un user object.\n+       // Esto ayuda a asegurar que el AuthContext al menos intentó inicializarse.\n+        const userObjectExistsInContext = !!user; // user viene de useAuth()\n+\n+\n+       return tokenExists && userJsonExists && userObjectExistsInContext && !authLoading; // AuthContext debe haber terminado de cargar\n+\n+  }, [user, authLoading]); // Depende de si el user object en context cambia y si authLoading termina.\n+\n+\n+  // --- Función para cargar el progreso ---\n+  const loadProgress = useCallback(async () => {\n+         // SOLO ejecutar la llamada a la API si estamos en el estado correcto (LOADING_PROGRESS)\n+         if (interactionState !== INTERACTION_STATES.LOADING_PROGRESS) {\n+              console.log(`[LogicPage] loadProgress API call skipped. State is ${interactionState}.`);\n+              return; // No hacer la llamada API si no estamos en el estado LOADING_PROGRESS\n+         }\n+         // Si ya tenemos progreso y no estamos en un estado que requiera recarga (ej. después de resolver)\n+         // podemos saltar la llamada API, pero debemos asegurar la transición al siguiente estado.\n+         if (userProgress && (interactionState !== INTERACTION_STATES.ERROR && interactionState !== INTERACTION_STATES.POST_FEEDBACK_CHOICES)) {\n+              console.log(\"[LogicPage] Progress already loaded. Skipping API call.\");\n+               // Si estábamos en LOADING_PROGRESS pero ya teníamos datos, pasar a mostrar.\n+               setInteractionState(INTERACTION_STATES.SHOWING_PROGRESS);\n+              return;\n+         }\n+\n+\n+         console.log(\"[LogicPage] Executing actual progress API call.\");\n+         // El estado ya debe ser LOADING_PROGRESS al llegar aquí.\n+\n+         // Verificamos ANTES de la llamada API que los datos de auth estén en SessionStorage.\n+         // La función getUserProgress (en api.js) también lo verifica internamente llamando a getAuthTokenFromSession.\n+         if (!isAuthDataReadyForFlow()) { // <-- Usamos la nueva verificación aquí\n+              console.error(\"[LogicPage] loadProgress API call attempted without sufficient auth data in SessionStorage!\");\n+               // Esto no debería pasar si el flujo de estados es correcto, pero es una seguridad.\n+              handleInteractionError(\"No se encontraron datos de inicio de sesión válidos. Por favor, inicia sesión de nuevo.\", true); // Redirigir/error\n+              return;\n+         }\n+\n+\n+         try {\n+           // LLAMADA API - SIN PASAR TOKEN (ya lo obtiene internamente de sessionStorage)\n+           const progressData = await getUserProgress();\n+           setUserProgress(progressData);\n+           console.log(\"[LogicPage] Progress API call successful.\");\n+           setInteractionState(INTERACTION_STATES.SHOWING_PROGRESS); // Transición después de cargar\n+\n+         } catch (error) {\n+           console.error(\"[LogicPage] Progress API call failed:\", error);\n+            // Si es un error 401 de API, significa que el token de sessionStorage es inválido/expirado (el backend lo rechazó)\n+            // Asumiendo que el error tiene una propiedad status (puede variar según cómo manejes los errores de fetch/axios)\n+             if (error && error.status === 401) {\n+                  handleInteractionError(\"Tu sesión ha expirado. Por favor, inicia sesión de nuevo.\", true); // Redirigir/error\n+             } else {\n+                 handleInteractionError(`No se pudo cargar el progreso. ${error.message || 'Error desconocido'}`); // Transición a ERROR\n+             }\n+\n+         }\n+    }, [userProgress, interactionState, handleInteractionError, getUserProgress, setUserProgress, setInteractionState, isAuthDataReadyForFlow]); // Dependencias. Asegurarse de que getUserProgress es estable.\n+\n+\n+  // --- useEffect para la Inicialización (Controla el flujo inicial IDLE -> OFFERING_CHOICES o ERROR) ---\n+  // Este efecto solo reacciona a cambios en el estado de autenticación y al estado IDLE\n+  useEffect(() => {\n+      console.log(\"[LogicPage] Auth state or interactionState changed.\", { user: user?.email, authLoading, interactionState });\n+\n+      // Si Auth context termina de cargar Y estamos en el estado inicial IDLE\n+      if (!authLoading && interactionState === INTERACTION_STATES.IDLE) {\n+          // Check if required auth data EXISTS IN SESSIONSTORAGE para iniciar el flujo\n+          if (isAuthDataReadyForFlow()) { // <-- Usamos la nueva verificación\n+            // Datos de autenticación necesarios encontrados en SessionStorage, START the flow\n+            console.log(\"[LogicPage] Auth finished, auth data found in SessionStorage. Offering initial choices.\");\n+            setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); // <-- CAMBIO CLAVE: Ir directo a ofrecer opciones\n+            \n+          } else {\n+            // Auth finished loading, but NO required data found in SessionStorage. User is NOT authenticated for this section.\n+            console.warn(\"[LogicPage] Auth finished loading, but NO auth data found in SessionStorage. User not authenticated for this section.\");\n+            // Set a message and transition to ERROR state (marking it as an auth error)\n+            handleInteractionError(\"Debes iniciar sesión para acceder a esta sección.\", true); // Pasar true para posible redirección\n+          }\n+        } else if (interactionState === INTERACTION_STATES.OFFERING_CHOICES) {\n+            // Auth finished loading, and we are in IDLE state. This means we are ready to offer choices.\n+            speakAndStopOthers(\"¿Quieres practicar lógica, escuchar tu progreso, o salir?\")\n+            }\n+        else {\n+            // Auth finished loading, but we are NOT in IDLE state.\n+            // This means the flow was already started (or in ERROR etc.). Do nothing in this effect.\n+            console.log(`[LogicPage] Auth finished, but state is ${interactionState}. Initial load already handled.`);\n+        }\n+      }\n+      // If authLoading is true, the component is still initializing auth, do nothing in this effect yet.\n+\n+  , [user, authLoading, interactionState, handleInteractionError, setInteractionState, isAuthDataReadyForFlow]); // Dependencias (Usamos user en lugar de token)\n+\n+\n+  // --- useEffect que se activa cuando el estado es LOADING_PROGRESS para llamar a la API ---\n+  // Este useEffect es DISPARADO AHORA SOLO por el comando \"progreso\" en handleTextRecognized.\n+  // Su lógica interna sigue llamando a loadProgress API call cuando el estado es LOADING_PROGRESS\n+  useEffect(() => {\n+       if (interactionState === INTERACTION_STATES.LOADING_PROGRESS) {\n+           console.log(\"[LogicPage] Entering LOADING_PROGRESS state. Initiating API call.\");\n+           loadProgress();\n+       }\n+\n+  }, [interactionState, loadProgress]); // Dependencia: se ejecuta cuando interactionState cambia a LOADING_PROGRESS (y loadProgress es estable)\n+\n+\n+  // --- useEffect para leer el progreso y pasar a OFERTAR OPCIONES ---\n+  // Se activa cuando el estado es SHOWING_PROGRESS\n+  useEffect(() => {\n+       if (interactionState === INTERACTION_STATES.SHOWING_PROGRESS && userProgress) {\n+           console.log(\"[LogicPage] Entering SHOWING_PROGRESS state. Reading progress.\");\n+           // LINE 231 (CORRECTED): Ensure correct template literal syntax\n+           let progressText = `Tu progreso. Total resueltos: ${userProgress.total_solved}. Promedio general: ${userProgress.overall_average_grade !== null ? userProgress.overall_average_grade.toFixed(2) : 'N/A'}. `;\n+           Object.entries(userProgress.progress_by_difficulty).forEach(([level, data]) => {\n+                progressText += `Nivel ${level}: ${data.solved_count} resueltos${data.solved_count > 0 ? `, promedio ${data.average_grade.toFixed(2)}` : ''}. `;\n+           });\n+           // Leer el progreso y, al terminar, pasar al estado OFFERING_CHOICES\n+           speakAndStopOthers(progressText, () => {\n+                console.log(\"[LogicPage] Reading progress finished. Offering choices.\");\n+                setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); // Transición después de leer\n+           });\n+\n+       }\n+  }, [interactionState, userProgress, setInteractionState, speakAndStopOthers]); // Depende de interactionState, userProgress, setInteractionState, y speakAndStopOthers\n+\n+\n+// --- Función para cargar un nuevo problema ---\n+const loadNewProblem = useCallback(async (difficulty = null) => {\n+    console.log(`[LogicPage] loadNewProblem - INICIO. Dificultad: ${difficulty}. Estado actual de interacción: ${interactionState}`);\n+\n+    // Verificamos que los datos de auth estén en SessionStorage antes de intentar API call\n+    if (!isAuthDataReadyForFlow()) {\n+        console.error(\"[LogicPage] loadNewProblem - Falla la verificación isAuthDataReadyForFlow.\");\n+        handleInteractionError(\"No hay datos de inicio de sesión disponibles en SessionStorage para cargar problema.\", true); // Redirigir/error\n+        return;\n+    }\n+\n+    // Evitar múltiples cargas o llamadas si ya estamos en proceso\n+    if (interactionState === INTERACTION_STATES.LOADING_PROBLEM || interactionState === INTERACTION_STATES.PROCESSING_ANSWER) {\n+        console.warn(`[LogicPage] loadNewProblem - Se intentó cargar pero ya estaba en estado: ${interactionState}. Se ignora.`);\n+        return;\n+    }\n+\n+    console.log(\"[LogicPage] loadNewProblem - Estableciendo estado a LOADING_PROBLEM y reseteando estados relevantes.\");\n+    setInteractionState(INTERACTION_STATES.LOADING_PROBLEM); // Nuevo estado: Cargando problema\n+    setProblemError(null); // Limpiar errores anteriores de problema/no hay problemas\n+    setCurrentProblem(null); // Limpiar problema anterior\n+    console.log(\"[LogicPage] loadNewProblem - currentProblem reseteado a null.\"); // LOG CLAVE\n+    setRecognizedText(''); // Limpiar input anterior de voz\n+    setBackendFeedback(''); // Limpiar feedback anterior\n+    setBackendError(''); // Limpiar errores de submit_answer/reconocimiento\n+\n+    try {\n+        console.log(\"[LogicPage] loadNewProblem - Llamando a getLogicProblem con dificultad:\", difficulty);\n+        const problemData = await getLogicProblem(difficulty);\n+        // Usar JSON.stringify para ver la estructura completa si es un objeto complejo.\n+        // Si problemData puede ser undefined o null, tener cuidado con stringify.\n+        console.log(\"[LogicPage] loadNewProblem - Datos recibidos de getLogicProblem:\", typeof problemData === 'object' ? JSON.stringify(problemData) : problemData); // LOG CLAVE\n+\n+        if (problemData && problemData._id) { // Asegúrate que aquí es _id\n+            setCurrentProblem(problemData);\n+            console.log(\"[LogicPage] loadNewProblem - setCurrentProblem EJECUTADO con datos. ID del Problema:\", problemData._id); // LOG CLAVE\n+            setInteractionState(INTERACTION_STATES.PRESENTING_PROBLEM); // Indicar que el problema está listo para ser leído\n+            console.log(\"[LogicPage] loadNewProblem - Estado cambiado a PRESENTING_PROBLEM.\");\n+        } else if (problemData && problemData.message) { // Si tiene un 'message', es el mensaje de no hay problemas\n+            setCurrentProblem(null); // Asegurar que no haya problema actual\n+            setProblemError(problemData.message); // Almacenar el mensaje\n+            console.warn(\"[LogicPage] loadNewProblem - No hay problemas disponibles. Mensaje:\", problemData.message);\n+            speakAndStopOthers(`Mensaje del sistema. ${problemData.message}`, () => {\n+                console.log(\"[LogicPage] loadNewProblem - Mensaje 'No hay problemas' leído. Cambiando estado a OFFERING_CHOICES.\");\n+                setInteractionState(INTERACTION_STATES.OFFERING_CHOICES);\n+            });\n+        } else {\n+            // Es posible que problemData sea null, undefined, o un formato inesperado\n+            console.error(\"[LogicPage] loadNewProblem - problemData no tiene _id ni message. problemData recibido:\", typeof problemData === 'object' ? JSON.stringify(problemData) : problemData); // LOG CLAVE\n+            handleInteractionError(\"Error inesperado al obtener problema: Formato de respuesta desconocido o datos incompletos.\");\n+        }\n+    } catch (error) {\n+        console.error(\"[LogicPage] loadNewProblem - ERROR en el bloque try-catch:\", error);\n+        if (error && error.status === 401) {\n+            handleInteractionError(\"Tu sesión ha expirado. Por favor, inicia sesión de nuevo.\", true);\n+        } else {\n+            handleInteractionError(`No se pudo obtener un nuevo problema. ${error.message || 'Error desconocido'}`);\n+        }\n+    }\n+}, [interactionState, handleInteractionError, /*getLogicProblem,*/ /*setInteractionState,*/ /*setCurrentProblem,*/ /*setProblemError,*/ /*setRecognizedText,*/ /*setBackendFeedback,*/ /*setBackendError,*/ isAuthDataReadyForFlow, speakAndStopOthers]);\n+// NOTA SOBRE DEPENDENCIAS:\n+// Las dependencias comentadas son las funciones de estado (setX) o funciones importadas que usualmente son estables.\n+// ESlint puede quejarse si no están, pero si sabes que son estables, a veces se omiten para evitar re-creaciones innecesarias del callback.\n+// Sin embargo, es más seguro incluirlas todas como las tenías originalmente si no estás seguro:\n+// [interactionState, handleInteractionError, getLogicProblem, setInteractionState, setCurrentProblem, setProblemError, setRecognizedText, setBackendFeedback, setBackendError, isAuthDataReadyForFlow, speakAndStopOthers]\n+\n+   // --- useEffect para leer el problema y pasar a PRESENTING_PROBLEM ---\n+   // Se activa cuando el estado es PRESENTING_PROBLEM\n+   useEffect(() => {\n+        if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM && currentProblem && currentProblem.text) {\n+            console.log(\"[LogicPage] Entering PRESENTING_PROBLEM state. Reading problem.\");\n+            // Leer el problema y, al terminar, decir al usuario cómo grabar.\n+            // El estado se mantiene en PRESENTING_PROBLEM hasta que VoiceRecognition actúe (grabe/suelte Enter).\n+            speakAndStopOthers(`Problema. Dificultad ${currentProblem.difficulty}. ${currentProblem.text}. Presiona y mantén Enter para grabar tu respuesta.`, () => {\n+                  console.log(\"[LogicPage] Instruction to record read.\");\n+                  // No hacemos transición de estado aquí. La transición RECORDING_ANSWER\n+                  // la manejará handleListeningStatusChange (if implementamos la prop).\n+            });\n+\n+        }\n+   }, [interactionState, currentProblem, speakAndStopOthers]); // Dependencias\n+\n+\n+\n+    // --- Función para manejar el envío de la respuesta ---\n+    // Es llamada desde handleTextRecognized cuando el estado es PRESENTING_PROBLEM y hay texto\n+    const handleAnswerSubmission = useCallback(async (answerText, problemId) => {\n+         // Verificamos que los datos de auth estén en SessionStorage antes de intentar API call\n+         if (!isAuthDataReadyForFlow() || !problemId || !answerText) { // <-- Usamos la nueva verificación\n+             handleInteractionError(\"Faltan datos (autenticación o respuesta/problema) para enviar la respuesta.\");\n+             setInteractionState(INTERACTION_STATES.ERROR); // Asegurarse de ir a ERROR si faltan datos\n+             return;\n+         }\n+          // Solo procesar si estábamos en estado PRESENTING_PROBLEM esperando respuesta\n+          // OJO: Podríamos estar en RECORDING_ANSWER si handleTextRecognized se llama justo al terminar de grabar\n+          if (interactionState !== INTERACTION_STATES.PRESENTING_PROBLEM && interactionState !== INTERACTION_STATES.RECORDING_ANSWER) {\n+               console.warn(\"[LogicPage] handleAnswerSubmission called in incorrect state:\", interactionState);\n+               return; // Solo procesar si estábamos esperando una respuesta al problema\n+          }\n+\n+         setInteractionState(INTERACTION_STATES.PROCESSING_ANSWER); // Nuevo estado: Procesando respuesta\n+         setBackendError(''); // Limpiar errores anteriores de submit_answer\n+\n+\n+         try {\n+           // LLAMADA API - SIN PASAR TOKEN (ya lo obtiene internamente)\n+           const feedbackResponse = await submitLogicAnswer(problemId, answerText); // <-- YA NO PASAMOS TOKEN AQUÍ\n+\n+           // La respuesta del backend debe tener el formato del LLM: { analysis: \"...\", grade: X }\n+           if (feedbackResponse && typeof feedbackResponse.analysis === 'string' && typeof feedbackResponse.grade === 'number') {\n+                // Almacenar feedback para mostrar/leer\n+                setBackendFeedback(`Análisis: ${feedbackResponse.analysis} | Calificación: ${feedbackResponse.grade}/10.`); // Añadimos punto final para TTS\n+                console.log(\"[LogicPage] Feedback recibido:\", feedbackResponse);\n+                 // Transición de estado después de recibir feedback\n+                setInteractionState(INTERACTION_STATES.SHOWING_FEEDBACK); // Indicar que el feedback está listo para ser leído\n+\n+                // Opcional: Recargar el progreso en segundo plano (sin esperar await) para la siguiente visualización\n+                getUserProgress().then(setUserProgress).catch(e => console.error(\"Error reloading progress silently:\", e));\n+\n+           } else if (feedbackResponse && typeof feedbackResponse.detail === 'string') {\n+                // Si el backend devuelve un error de HTTP con detalle\n+                 handleInteractionError(`Error del backend: ${feedbackResponse.detail}`);\n+           }\n+           else {\n+                // Formato de respuesta de feedback inesperado\n+                handleInteractionError(\"Error: Formato de feedback del backend inesperado.\");\n+           }\n+\n+         } catch (error) {\n+           console.error(\"[LogicPage] Error al enviar respuesta al backend:\", error);\n+            // Si es un error 401 de API\n+             if (error && error.status === 401) {\n+                  handleInteractionError(\"Tu sesión ha expirado. Por favor, inicia sesión de nuevo.\", true); // Redirigir/error\n+             } else {\n+                 handleInteractionError(`Error al procesar respuesta: ${error.message || 'Error desconocido'}`);\n+             }\n+         }\n+         // Nota: El estado se actualiza en el try/catch. Si todo falla, se va al estado ERROR.\n+         // El estado PROCESSING_ANSWER se mantiene hasta que una de las ramas try/catch/error lo cambie.\n+    }, [interactionState, handleInteractionError, submitLogicAnswer, setInteractionState, setBackendFeedback, setBackendError, getUserProgress, setUserProgress, isAuthDataReadyForFlow]); // Dependencias\n+\n+\n+    // --- useEffect para leer el feedback y pasar a POST_FEEDBACK_CHOICES ---\n+    // Se activa cuando el estado es SHOWING_FEEDBACK\n+    useEffect(() => {\n+       if (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && backendFeedback) {\n+           console.log(\"[LogicPage] Entering SHOWING_FEEDBACK state. Reading feedback.\");\n+           // Leer feedback y, al terminar, pasar al estado POST_FEEDBACK_CHOICES\n+            speakAndStopOthers(`Feedback del asistente. ${backendFeedback}`, () => { // <-- USAR speakAndStopOthers\n+                 console.log(\"[LogicPage] Reading feedback finished. Offering post-feedback choices.\");\n+                 setInteractionState(INTERACTION_STATES.POST_FEEDBACK_CHOICES); // Transición después de leer\n+                 // Al pasar a POST_FEEDBACK_CHOICES, la función handleTextRecognized\n+                 // interpretará los comandos \"otro\", \"cambiar\", \"salir\", \"progreso\".\n+                 // Opcional: Decir por voz las opciones principales después del feedback\n+                  speakAndStopOthers(\"¿Quieres otro problema, cambiar dificultad, escuchar tu progreso, o salir?\"); // Es útil para guiar al usuario\n+            });\n+       } else if (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && backendError) {\n+            // Si hay un error de backend que llegó a SHOWING_FEEDBACK\n+            console.log(\"[LogicPage] Entering SHOWING_FEEDBACK state with backend error.\", backendError);\n+             // No leer el error de \"no voz detectada\"\n+             if (backendError !== \"No se detectó voz. Intenta hablar más claro.\") {\n+                  speakAndStopOthers(`Error del sistema. ${backendError}. Por favor, intenta de nuevo o sal con Escape.`, () => { // <-- USAR speakAndStopOthers\n+                      // Después de leer el error, pasar a un estado donde se pueda salir o reintentar\n+                      console.log(\"[LogicPage] Reading backend error finished. Transitioning to ERROR.\");\n+                      setInteractionState(INTERACTION_STATES.ERROR); // Pasar a estado ERROR\n+                  });\n+             } else {\n+                 // Si el error fue solo \"no detectó voz\", volver al estado de presentar problema para reintentar\n+                 console.log(\"[LogicPage] Reading 'no speech' error. Returning to PRESENTING_PROBLEM.\");\n+                 // Limpiamos el error para que no se muestre visualmente persistentemente\n+                 setBackendError(''); // Limpiar el error\n+                 setInteractionState(INTERACTION_STATES.PRESENTING_PROBLEM); // Volver a esperar grabación\n+                  speakAndStopOthers(\"No detecté tu respuesta. Intenta de nuevo. Presiona y mantén Enter para grabar.\"); // <-- USAR speakAndStopOthers\n+             }\n+       }\n+    }, [interactionState, backendFeedback, backendError, setInteractionState, setBackendError, speakAndStopOthers]); // Dependencias\n+\n+\n+    // --- Función para manejar el texto reconocido (el INTERPRETE DE COMANDOS) ---\n+    // Es llamada por VoiceRecognition cuando la grabación termina y hay texto o está vacía\n+    const handleTextRecognized = useCallback(async (text, isClearRequest = false) => {\n+       // Guardar el texto reconocido solo si no es una solicitud de limpieza total\n+       if (!isClearRequest) {\n+            setRecognizedText(text); // Actualizar el estado local del texto reconocido\n+             // Opcional: Leer el texto reconocido al usuario para confirmación si lo deseas en algún estado\n+             // if (interactionState === INTERACTION_STATES.SOME_STATE_TO_CONFIRM_INPUT) { speakAndStopOthers(`Dijiste: ${text}`); } // <-- USAR speakAndStopOthers si se hace\n+       }\n+\n+       // Limpiar el estado de backendError si fue por voz vacía de la vez anterior\n+       // Esto asegura que el mensaje visual y el estado de error se limpien\n+       if (backendError === \"No se detectó voz. Intenta hablar más claro.\") {\n+            setBackendError('');\n+       }\n+\n+\n+       // Lógica para limpiar la UI (si VoiceRecognition tiene un botón de limpiar que llama a esto)\n+       if (isClearRequest) {\n+           console.log(\"[LogicPage] Clear request received from VoiceRecognition.\");\n+           setRecognizedText('');\n+           setBackendFeedback('');\n+           setBackendError('');\n+           setProblemError(null); // Limpiar errores de problema/flujo\n+           // Volver a un estado neutral o el de ofrecer opciones principal\n+           setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); // Ejemplo: Volver a ofrecer opciones\n+            speakAndStopOthers(\"Conversación limpiada. ¿Quieres practicar lógica, escuchar tu progreso, o salir?\"); // <-- USAR speakAndStopOthers\n+           return;\n+       }\n+\n+       const lowerText = text.toLowerCase().trim();\n+\n+       // Si no hay texto reconocido válido después de la grabación (y no fue una solicitud de limpieza)\n+       if (!lowerText) {\n+            console.warn(\"[LogicPage] Grabación finalizada sin texto reconocido después de trim.\");\n+            // Si estábamos en un estado que esperaba una respuesta hablada (que no sea la respuesta al problema)\n+            if (interactionState === INTERACTION_STATES.ASKING_DIFFICULTY ||\n+                interactionState === INTERACTION_STATES.OFFERING_CHOICES ||\n+                interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES ||\n+                interactionState === INTERACTION_STATES.ERROR) // También si esperábamos un comando de error/salida\n+             {\n+                 // Decir que no se entendió y repetir las opciones/pregunta\n+                 speakAndStopOthers(\"No detecté voz. Por favor, repite tu elección.\"); // <-- USAR speakAndStopOthers\n+                 // Mantener el estado actual para esperar otra respuesta hablada\n+             } else if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM || interactionState === INTERACTION_STATES.RECORDING_ANSWER) { // Aceptar también si VR termina antes de que el estado cambie a RECORDING_ANSWER\n+                 // Si estábamos esperando la respuesta al problema pero no se detectó voz\n+                  setBackendError(\"No se detectó voz. Intenta hablar más claro.\"); // Usamos backendError para este mensaje\n+                  // El useEffect de leer feedback/error lo leerá y nos devolverá a PRESENTING_PROBLEM\n+             } else {\n+                  // En otros estados (ej. LOADING, SHOWING_PROGRESS, PROCESSING_ANSWER, RECORDING_ANSWER), simplemente ignorar voz vacía.\n+                  console.log(\"Voz vacía ignorada en estado:\", interactionState);\n+             }\n+            return; // Salir de la función si no hay texto para procesar\n+       }\n+\n+        // --- Interpretación de Comandos Basada en el Estado ---\n+        console.log(`[LogicPage] Procesando texto \"${lowerText}\" en estado: ${interactionState}`);\n+\n+\n+       switch (interactionState) {\n+           case INTERACTION_STATES.OFFERING_CHOICES: // Esperando \"practicar\", \"progreso\", \"salir\"\n+               if (lowerText.includes('practicar') || lowerText.includes('ejercicio')) {\n+                   setInteractionState(INTERACTION_STATES.ASKING_DIFFICULTY);\n+                   speakAndStopOthers(\"Okay. ¿Qué dificultad quieres practicar: básico, intermedio o avanzado?\"); // <-- USAR speakAndStopOthers\n+               } else if (lowerText.includes('progreso') || lowerText.includes('estadísticas')) {\n+                   // Volver a leer el progreso. Pasamos por SHOWING_PROGRESS.\n+                   setInteractionState(INTERACTION_STATES.LOADING_PROGRESS); // Transicionar a LOADING_PROGRESS para forzar recarga/relectura\n+               } else if (lowerText.includes('salir') || lowerText.includes('adiós')) {\n+                   setInteractionState(INTERACTION_STATES.EXITING);\n+                   speakAndStopOthers(\"Adiós. Espero verte pronto.\", () => { /* ... */ }); // <-- USAR speakAndStopOthers\n+               } else {\n+                   // Comando no reconocido en este estado\n+                   speakAndStopOthers(\"No entendí. ¿Quieres practicar lógica, escuchar tu progreso, o salir?\"); // <-- USAR speakAndStopOthers\n+                   // Mantener el estado OFFERING_CHOICES\n+               }\n+               break;\n+\n+           case INTERACTION_STATES.ASKING_DIFFICULTY: // Esperando \"básico\", \"intermedio\", \"avanzado\"\n+                if (lowerText.includes('básico') || lowerText.includes('basico')) {\n+                   loadNewProblem('basico'); // loadNewProblem cambiará el estado a LOADING_PROBLEM\n+               } else if (lowerText.includes('intermedio')) {\n+                   loadNewProblem('intermedio'); // loadNewProblem cambiará el estado\n+               } else if (lowerText.includes('avanzado')) {\n+                   loadNewProblem('avanzado'); // loadNewProblem cambiará el estado\n+               } else {\n+                   // Dificultad no reconocida\n+                   speakAndStopOthers(\"Dificultad no válida. Por favor, di básico, intermedio o avanzado.\"); // <-- USAR speakAndStopOthers\n+                   // Mantener el estado ASKING_DIFFICULTY\n+               }\n+               break;\n+\n+           case INTERACTION_STATES.PRESENTING_PROBLEM: // Esperando la respuesta al problema (la grabación ya terminó)\n+           case INTERACTION_STATES.RECORDING_ANSWER: // Aceptar también si VR termina antes de que el estado cambie a RECORDING_ANSWER\n+               // Si llegamos aquí con texto, es la respuesta al problema.\n+               if (lowerText) { // Asegurarse de que la transcripción no esté vacía después de trim\n+                   // Verificar si tenemos un currentProblem válido antes de intentar submit\n+                    if (currentProblem && currentProblem._id) {\n+                       handleAnswerSubmission(lowerText, currentProblem._id); // Llamar a la función de submit\n+                    } else {\n+                         console.warn(\"[LogicPage] Texto reconocido pero no hay currentProblem.id válido. Ignorando.\");\n+                          // Podríamos informar al usuario por voz que no hay problema activo\n+                          // speakAndStopOthers(\"No hay un problema activo para responder.\"); // <-- USAR speakAndStopOthers si se hace\n+                    }\n+               } else {\n+                   console.warn(\"[LogicPage] Texto de respuesta al problema vacío después de trim.\");\n+                   // Ya se maneja el error de \"No detectó voz\" arriba.\n+               }\n+               break;\n+\n+           case INTERACTION_STATES.POST_FEEDBACK_CHOICES: // Feedback leído, esperando \"otro\", \"cambiar\", \"salir\", \"progreso\"\n+                if (lowerText.includes('otro') || lowerText.includes('siguiente')) {\n+                    // Cargar otro problema del MISMO NIVEL\n+                    const nextDifficulty = currentProblem?.difficulty; // Usar la dificultad del problema recién resuelto\n+                    if (nextDifficulty) {\n+                         speakAndStopOthers(\"Okay, buscando otro problema...\", () => { // <-- USAR speakAndStopOthers\n+                              loadNewProblem(nextDifficulty); // Cargar siguiente del mismo nivel\n+                         });\n+                    } else {\n+                         // Si no sabemos la dificultad del problema anterior, pedirla de nuevo (caso raro)\n+                         speakAndStopOthers(\"Okay, otro problema...\", () => { // <-- USAR speakAndStopOthers\n+                              setInteractionState(INTERACTION_STATES.ASKING_DIFFICULTY);\n+                              speakAndStopOthers(\"¿Qué dificultad quieres practicar?\"); // <-- USAR speakAndStopOthers\n+                         });\n+                    }\n+                } else if (lowerText.includes('cambiar') || lowerText.includes('dificultad')) {\n+                    // Pedir cambiar dificultad\n+                    setInteractionState(INTERACTION_STATES.ASKING_DIFFICULTY);\n+                    speakAndStopOthers(\"Okay. ¿Qué dificultad quieres practicar: básico, intermedio o avanzado?\"); // <-- USAR speakAndStopOthers\n+                } else if (lowerText.includes('salir') || lowerText.includes('adiós')) {\n+                    setInteractionState(INTERACTION_STATES.EXITING);\n+                   speakAndStopOthers(\"Adiós. Espero verte pronto.\", () => { /* ... */ }); // <-- USAR speakAndStopOthers\n+                } else if (lowerText.includes('progreso') || lowerText.includes('estadísticas')) {\n+                     // Leer progreso y volver a ofrecer opciones post-feedback\n+                    speakAndStopOthers(\"Okay, revisemos tu progreso.\", () => { // <-- USAR speakAndStopOthers\n+                         // Mostrar progreso (ya debería estar cargado). El useEffect se encargará de leerlo y volver a OFFERING_CHOICES\n+                         // Si queremos que después de leer progreso vuelva a POST_FEEDBACK_CHOICES, necesitaríamos lógica adicional.\n+                         // Por simplicidad, lo mandamos a LOADING_PROGRESS para releerlo y luego a OFFERING_CHOICES.\n+                         setInteractionState(INTERACTION_STATES.LOADING_PROGRESS); // Dispara la carga/relectura\n+                    });\n+                }\n+                else {\n+                    // Comando no reconocido en este estado\n+                    speakAndStopOthers(\"No entendí. ¿Quieres otro problema, cambiar dificultad, escuchar tu progreso, o salir?\"); // <-- USAR speakAndStopOthers\n+                    // Mantener el estado POST_FEEDBACK_CHOICES\n+                }\n+               break;\n+\n+           case INTERACTION_STATES.ERROR: // En estado de error, esperando comando de recuperación/salida\n+                if (lowerText.includes('salir') || lowerText.includes('adiós')) {\n+                     setInteractionState(INTERACTION_STATES.EXITING);\n+                       speakAndStopOthers(\"Okay, saliendo.\", () => { /* ... */ }); // <-- USAR speakAndStopOthers\n+                } else if (lowerText.includes('intentar') || lowerText.includes('empezar') || lowerText.includes('inicio') || lowerText.includes('reiniciar')) {\n+                     // Intentar reiniciar el flujo\n+                      speakAndStopOthers(\"Okay, intentemos desde el inicio.\", () => { // <-- USAR speakAndStopOthers\n+                           // Limpiar estados relevantes\n+                           setCurrentProblem(null);\n+                           setProblemError(null);\n+                           setBackendFeedback('');\n+                           setBackendError('');\n+                           setRecognizedText('');\n+                           setUserProgress(null); // Forzar recarga de progreso\n+                           // Volver al inicio del flujo principal (cargar progreso)\n+                           setInteractionState(INTERACTION_STATES.LOADING_PROGRESS); // Dispara la carga/relectura\n+                      });\n+                }\n+                else {\n+                     // Comando no reconocido en estado de error\n+                     speakAndStopOthers(\"No entendí. ¿Quieres salir, o intentar desde el inicio?\"); // <-- USAR speakAndStopOthers\n+                     // Mantener estado ERROR\n+                }\n+               break;\n+\n+           default: // Ignorar voz en otros estados (IDLE, LOADING, PROCESSING, RECORDING)\n+               console.log(`[LogicPage] Texto \"${lowerText}\" ignorado en estado: ${interactionState}`);\n+               break;\n+       }\n+    }, [interactionState, currentProblem, backendError, loadNewProblem, handleAnswerSubmission, setInteractionState, setRecognizedText, setBackendFeedback, setBackendError, setProblemError, setCurrentProblem, setUserProgress, handleInteractionError, speakAndStopOthers]); // Dependencias\n+\n+\n+    const handleListeningStatusChange = useCallback((isListening) => {\n+        console.log(\"[LogicPage] Micrófono callback:\", isListening ? \"EMPEZÓ A ESCUCHAR\" : \"TERMINÓ DE ESCUCHAR\");\n+    \n+        if (isListening) {\n+            if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n+                console.log(\"[LogicPage] Micrófono INICIADO. Esperando respuesta al problema...\");\n+                setBackendError('');\n+                // Cambiar a RECORDING_ANSWER sin reproducir audio para evitar conflictos\n+                setInteractionState(prevInteractionState =>\n+                    prevInteractionState === INTERACTION_STATES.PRESENTING_PROBLEM\n+                        ? INTERACTION_STATES.RECORDING_ANSWER\n+                        : prevInteractionState\n+                );\n+                // Eliminamos la reproducción de \"Adelante\" que parece estar causando conflictos\n+            }\n+        } else {\n+            // El micrófono ha terminado de escuchar (onend o onerror en VoiceRecognition)\n+            if (interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n+                console.log(\"[LogicPage] Micrófono DETENIDO. Procesando respuesta...\");\n+                // VoiceRecognition llamará a onTextRecognized que manejará el siguiente estado.\n+            } else {\n+                // Si deja de escuchar y no estábamos grabando (ej. error al iniciar),\n+                // resetear el mensaje si se quedó en \"Grabando...\"\n+                console.log(\"[LogicPage] Micrófono DETENIDO pero no estábamos grabando. Limpiando mensaje.\");\n+            }\n+        }\n+    }, [interactionState, setInteractionState, setBackendError]);\n+\n+    // --- Implementar listener de teclado general (para acciones como Escape y Enter de flujo) ---\n+    useEffect(() => {\n+        const handleKeyDown = (event) => {\n+             // No procesar si un input/textarea tiene foco (si tuvieras alguno)\n+             if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {\n+                 return;\n+             }\n+\n+            // Ignorar eventos de teclado si está en un estado de carga o procesamiento crítico donde no queremos interrupción.\n+            // O si está grabando (Enter lo maneja VR, Escape podría ser útil pero puede ser confuso)\n+            if (interactionState === INTERACTION_STATES.LOADING_PROGRESS ||\n+                interactionState === INTERACTION_STATES.LOADING_PROBLEM ||\n+                interactionState === INTERACTION_STATES.PROCESSING_ANSWER ||\n+                interactionState === INTERACTION_STATES.EXITING\n+               ) {\n+                 // console.log(`[LogicPage] Keyboard event (${event.key}) ignored during critical state: ${interactionState}`);\n+                return;\n+               }\n+\n+            // --- Manejar tecla Escape ---\n+             if (event.key === 'Escape') {\n+                // Permitir salir desde cualquier estado excepto los críticos ya filtrados\n+                 console.log(\"[LogicPage] Escape pressed. Initiating exit.\");\n+                 SpeechSynthesis.cancel(); // Limpiar cualquier TTS que esté hablando (menos crítico ahora con speakAndStopOthers, pero buena práctica)\n+                 // Asegurar que cualquier audio de backend también se detenga\n+                 if (audioRef.current) {\n+                      audioRef.current.pause();\n+                      audioRef.current.currentTime = 0;\n+                       if (audioRef.current.url) URL.revokeObjectURL(audioRef.current.url);\n+                      audioRef.current = null;\n+                 }\n+                 // Asegurar que el micrófono se detenga si estaba activo\n+                  setInterruptTrigger(prev => prev + 1);\n+\n+\n+                 setInteractionState(INTERACTION_STATES.EXITING);\n+                  speakAndStopOthers(\"Saliendo de la sección de lógica. Adiós.\", () => { // <-- USAR speakAndStopOthers\n+                      // TODO: Implementar navegación para salir de la sección\n+                      console.log(\"[LogicPage] Implementación de navegación de salida.\");\n+                       // const navigate = useNavigate(); navigate('/'); // Ejemplo con react-router-dom, requiere el hook useNavigate\n+                       // logout(); // Si salir también implica hacer logout también\n+                  });\n+                 event.preventDefault(); // Prevenir comportamiento por defecto\n+                 return; // No procesar Enter si ya se presionó Escape\n+             }\n+\n+            if (event.key === 'Enter') {\n+                // 1. Si ya se está grabando, VoiceRecognition lo maneja (para detener).\n+                //    Logica.jsx no hace nada.\n+                if (interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n+                    console.log(\"[LogicPage] Enter pressed during RECORDING_ANSWER. Handled by VoiceRecognition.\");\n+                    // VoiceRecognition.jsx debe llamar a event.preventDefault() si lo necesita.\n+                    return;\n+                }\n+\n+                // 2. Si estamos en un estado donde VoiceRecognition está visible y esperando\n+                //    Enter para INICIAR la grabación, Logica.jsx tampoco debe interferir.\n+                const isVoiceRecognitionActiveAndWaitingToStart = [\n+                    INTERACTION_STATES.OFFERING_CHOICES,\n+                    INTERACTION_STATES.ASKING_DIFFICULTY,\n+                    INTERACTION_STATES.PRESENTING_PROBLEM,\n+                    INTERACTION_STATES.POST_FEEDBACK_CHOICES,\n+                    INTERACTION_STATES.ERROR\n+                    // Asegúrate de que esta lista coincida con los estados donde VR está\n+                    // activo y Enter inicia la grabación.\n+                ].includes(interactionState);\n+\n+                if (isVoiceRecognitionActiveAndWaitingToStart) {\n+                    console.log(`[LogicPage] Enter pressed in state ${interactionState}. VoiceRecognition should handle this to START recording. Logica.jsx takes no action.`);\n+                    // VoiceRecognition.jsx debe llamar a event.preventDefault() si lo necesita.\n+                    return;\n+                }\n+\n+                // 3. Si llegamos aquí, Enter NO es para el micrófono en este momento.\n+                //    Y como NO quieres que Enter repita audios desde Logica.jsx,\n+                //    eliminamos toda la lógica que hacía eso.\n+                //    Lo que sigue es lo que puedes borrar de tu bloque original:\n+                //\n+                //    console.log(\"[LogicPage] Enter pressed outside recording. Repeating prompt or triggering action.\"); // <-- BORRAR o cambiar mensaje\n+                //    event.preventDefault(); // <-- BORRAR si Enter no debe hacer nada globalmente, o mantener si quieres prevenir default action siempre.\n+                //\n+                //    // TODAS LAS SIGUIENTES CONDICIONES if/else if QUE LLAMAN A speakAndStopOthers DEBEN SER BORRADAS:\n+                //    // if (interactionState === INTERACTION_STATES.ASKING_DIFFICULTY) { ... } <--- BORRAR\n+                //    // else if (interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES) { ... } <--- BORRAR\n+                //    // else if (interactionState === INTERACTION_STATES.ERROR && problemError) { ... } <--- BORRAR\n+                //    // else if (interactionState === INTERACTION_STATES.SHOWING_PROGRESS && userProgress) { ... } <--- BORRAR\n+                //    // else if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM && currentProblem) { ... } <--- BORRAR (esta ya estaría cubierta por la guarda de arriba de todas formas)\n+                //    // else if (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && backendFeedback) { ... } <--- BORRAR\n+\n+                // En su lugar, puedes dejar un log para saber que se presionó Enter\n+                // y no se tomó acción deliberadamente, o incluso no hacer nada.\n+                console.log(`[LogicPage] Enter pressed in state ${interactionState}. No TTS repeat action defined in Logica.jsx for Enter.`);\n+                // Opcional: Si quieres que Enter no haga absolutamente nada (como scroll, submit de form si existiera)\n+                // en estos otros casos, puedes dejar un event.preventDefault();\n+                // event.preventDefault();\n+            }\n+\n+                 // Opcional: Implementar que Enter *después* de feedback pase al siguiente problema sin voz\n+                 // if (interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.SHOWING_FEEDBACK) {\n+                 //     console.log(\"[LogicPage] Enter pressed after feedback. Loading next problem.\");\n+                 //      const nextDifficulty = currentProblem?.difficulty;\n+                 //      if (nextDifficulty) { loadNewProblem(nextDifficulty); } else { setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); speakText(\"¿Qué dificultad quieres practicar?\"); }\n+                 // }\n+\n+\n+                 event.preventDefault(); // Prevenir comportamiento por defecto del Enter (ej. en formularios)\n+            }\n+        \n+\n+        window.addEventListener('keydown', handleKeyDown);\n+        return () => {\n+            window.removeEventListener('keydown', handleKeyDown);\n+            SpeechSynthesis.cancel(); // Limpiar TTS al desmontar\n+        };\n+    }, [interactionState, speakAndStopOthers, handleInteractionError, loadNewProblem, userProgress, currentProblem, backendFeedback, problemError]); // Dependencias\n+\n+\n+    // Define los anchos de la sidebar (si los usas para layout)\n+    const sidebarCollapsedWidth = 60; // px\n+    const sidebarExpandedWidth = 250; // px\n+    const mainContentPaddingLeft = isSidebarExpanded ? sidebarExpandedWidth : sidebarCollapsedWidth;\n+\n+\n+    // --- Lógica de renderizado condicional ---\n+    // Mostramos diferentes mensajes o componentes según el estado de interacción\n+  return (\n+    // Contenedor principal\n+    \n+    <div className=\"flex min-h-screen bg-gradient-to-br from-gray-50 to-gray-100\">\n+      {/* SideBar (si lo usas) */}\n+      {/* ASEGÚRATE DE QUE ESTA LÍNEA NO ESTÉ COMENTADA Y LA RUTA SEA CORRECTA */}\n+      <SideBar isExpanded={isSidebarExpanded} onToggleExpansion={handleSidebarToggle} />\n+\n+      {/* Contenedor del Contenido Principal */}\n+      <main\n+        className=\"flex-1 min-w-0 overflow-x-hidden\"\n+        style={{ paddingLeft: `${mainContentPaddingLeft}px`, transition: 'padding-left 0.3s ease' }}\n+      >\n+        {/* Navbar (si lo usas) */}\n+         {/* ASEGÚRATE DE QUE ESTA LÍNEA NO ESTÉ COMENTADA Y LA RUTA SEA CORRECTA */}\n+        <Navbar />\n+\n+        {/* Contenido específico de la Sección de Lógica */}\n+        <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\"> {/* CORREGIDO: lg-px-8 -> lg:px-8 */}\n+            <h1>Sección de Lógica de Programación</h1>\n+            <p>Aquí puedes practicar problemas de lógica. Tu progreso y las respuestas serán analizadas.</p>\n+\n+            {/* Mensajes de estado general o carga */}\n+            <div style={{ marginTop: '20px', fontWeight: 'bold', minHeight: '2em' }}>\n+                {/* Si el AuthContext está cargando */}\n+                {authLoading && interactionState === INTERACTION_STATES.IDLE && <p>Cargando datos de usuario...</p>}\n+\n+                {/* Mensajes basados en el estado de interacción */}\n+                {!authLoading && (\n+                    <>\n+                       {/* Mostrar IDLE si no hay user object O si no hay datos de auth en sessionStorage */}\n+                       {interactionState === INTERACTION_STATES.IDLE && !isAuthDataReadyForFlow() && <p>Iniciando sección de lógica...</p>}\n+\n+                       {interactionState === INTERACTION_STATES.LOADING_PROGRESS && <p>Cargando progreso...</p>}\n+                       {interactionState === INTERACTION_STATES.SHOWING_PROGRESS && <p>Mostrando tu progreso...</p>}\n+                       {interactionState === INTERACTION_STATES.OFFERING_CHOICES && <p>Di: \"practicar\", \"progreso\" o \"salir\".</p>}\n+                       {interactionState === INTERACTION_STATES.ASKING_DIFFICULTY && <p>Di la dificultad: \"básico\", \"intermedio\" o \"avanzado\".</p>}\n+                       {interactionState === INTERACTION_STATES.LOADING_PROBLEM && <p>Cargando problema...</p>}\n+                       {interactionState === INTERACTION_STATES.PRESENTING_PROBLEM && <p>Problema cargado. Esperando grabación...</p>}\n+                       {interactionState === INTERACTION_STATES.RECORDING_ANSWER && <p style={{color: 'green'}}>🎙️ Grabando respuesta... (Suelta 'Enter' para terminar)</p>}\n+                       {interactionState === INTERACTION_STATES.PROCESSING_ANSWER && <p>Procesando respuesta...</p>}\n+                       {interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && <p>Mostrando feedback...</p>}\n+                       {interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES && <p>Di: \"otro problema\", \"cambiar dificultad, escuchar tu progreso, o salir\".</p>}\n+                       {interactionState === INTERACTION_STATES.EXITING && <p>Saliendo...</p>}\n+                    </>\n+                )}\n+                 {/* Mostrar error general de flujo si el estado es ERROR */}\n+                 {interactionState === INTERACTION_STATES.ERROR && problemError && (\n+                     <p style={{ color: 'red', fontWeight: 'bold' }}>{problemError}. Di \"intentar de nuevo\" o \"salir\".</p>\n+                 )}\n+            </div>\n+\n+\n+            {/* Mostrar Progreso del Usuario - Solo si ha sido cargado y el estado lo permite */}\n+            {userProgress && (interactionState === INTERACTION_STATES.SHOWING_PROGRESS || interactionState === INTERACTION_STATES.OFFERING_CHOICES || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && (\n+                 <div style={{ marginTop: '20px', border: '1px solid #ccc', padding: '15px', background: '#f9f9f9' }}>\n+                     <h2>Tu Progreso</h2>\n+                     {userProgress && ( // Asegurarse de que userProgress no sea null\n+                         <div>\n+                             <p>Total resueltos: {userProgress.total_solved}</p>\n+                             <p>Promedio general: {userProgress.overall_average_grade !== null ? userProgress.overall_average_grade.toFixed(2) : 'N/A'}</p>\n+                             <ul>\n+                                 {Object.entries(userProgress.progress_by_difficulty).map(([level, data]) => (\n+                                     <li key={level}>\n+                                         {level.charAt(0).toUpperCase() + level.slice(1)}: {data.solved_count} resueltos {data.solved_count > 0 ? `(Promedio: ${data.average_grade.toFixed(2)})` : ''}\n+                                     </li>\n+                                 ))}\n+                             </ul>\n+                         </div>\n+                     )}\n+                 </div>\n+             )}\n+\n+             {/* Mostrar Problema Actual - Solo si ha sido cargado y el estado lo permite */}\n+            {currentProblem && (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM || interactionState === INTERACTION_STATES.RECORDING_ANSWER || interactionState === INTERACTION_STATES.PROCESSING_ANSWER || interactionState === INTERACTION_STATES.SHOWING_FEEDBACK || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && (\n+                <div style={{ marginTop: '20px', border: '2px solid blue', padding: '15px', background: '#eaf6ff' }}>\n+                    <h3>Problema de Lógica (Dificultad: {currentProblem.difficulty})</h3>\n+                    <p style={{ whiteSpace: 'pre-wrap' }}>{currentProblem.text}</p>\n+                </div>\n+            )}\n+\n+            {/* Integrar tu componente VoiceRecognition */}\n+            {/* Mostrarlo solo en los estados donde esperamos INPUT de voz del usuario */}\n+             {(interactionState === INTERACTION_STATES.OFFERING_CHOICES ||\n+               interactionState === INTERACTION_STATES.ASKING_DIFFICULTY ||\n+               interactionState === INTERACTION_STATES.PRESENTING_PROBLEM ||\n+               interactionState === INTERACTION_STATES.RECORDING_ANSWER ||\n+               interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES ||\n+               interactionState === INTERACTION_STATES.ERROR\n+             ) && !authLoading && ( // Añadir !authLoading para evitar mostrarlo mientras carga auth\n+            // Dentro del return de LogicSectionPage.jsx\n+\n+            <div style={{marginTop: '25px'}}>\n+                <p style={{textAlign: 'center', fontWeight:'bold', marginBottom:'10px'}}>Control de Voz:</p>\n+                <VoiceRecognition\n+                    onTextRecognized={handleTextRecognized}\n+                    isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n+                    onListeningChange={handleListeningStatusChange}\n+                    // Eliminamos la key dinámica que causa el remontaje\n+                />\n+                 {recognizedText && <p style={{marginTop: '10px', fontSize: '0.9em', color: '#555'}}>Texto reconocido: \"{recognizedText}\"</p>}\n+                 {backendError && <p style={{ color: 'orange', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>}\n+             </div>\n+             )}\n+\n+             {/* Mostrar el feedback del backend (análisis/calificación) si está disponible */}\n+             {backendFeedback && (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && (\n+                 <div style={{ marginTop: '20px', border: '2px solid green', padding: '15px', background: '#eafaf9' }}>\n+                     <h3>Feedback del Asistente:</h3>\n+                     <p style={{ whiteSpace: 'pre-wrap' }}>{backendFeedback}</p>\n+                 </div>\n+             )}\n+             {/* Mostrar error específico si es el de \"no detectó voz\" */}\n+              {(interactionState === INTERACTION_STATES.PRESENTING_PROBLEM || interactionState === INTERACTION_STATES.RECORDING_ANSWER || interactionState === INTERACTION_STATES.PROCESSING_ANSWER) && backendError === \"No se detectó voz. Intenta hablar más claro.\" && (\n+                   <p style={{ color: 'orange', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>\n+              )}\n+             {/* Mostrar error general de submit/backend si existe y no es el de voz vacía */}\n+             {(interactionState === INTERACTION_STATES.PROCESSING_ANSWER || interactionState === INTERACTION_STATES.SHOWING_FEEDBACK || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && backendError && backendError !== \"No se detectó voz. Intenta hablar más claro.\" && (\n+                 <p style={{ color: 'red', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>\n+            )}\n+\n+\n+        </div>\n+      </main>\n+    </div>\n+  );\n+};\n+\n+export default LogicSectionPage;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1747004523316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -503,9 +503,9 @@\n \n            // La respuesta del backend debe tener el formato del LLM: { analysis: \"...\", grade: X }\n            if (feedbackResponse && typeof feedbackResponse.analysis === 'string' && typeof feedbackResponse.grade === 'number') {\n                 // Almacenar feedback para mostrar/leer\n-                setBackendFeedback(`Análisis: ${feedbackResponse.analysis} | Calificación: ${feedbackResponse.grade}/10.`); // Añadimos punto final para TTS\n+                setBackendFeedback(`Análisis: ${feedbackResponse.analysis} \\n Calificación: ${feedbackResponse.grade}/10.`); // Añadimos punto final para TTS\n                 console.log(\"[LogicPage] Feedback recibido:\", feedbackResponse);\n                  // Transición de estado después de recibir feedback\n                 setInteractionState(INTERACTION_STATES.SHOWING_FEEDBACK); // Indicar que el feedback está listo para ser leído\n \n@@ -1030,1039 +1030,5 @@\n     </div>\n   );\n };\n \n-export default LogicSectionPage;\n-// src/pages/LoggedIn/Logica.jsx (o LogicSectionPage.jsx)\n-import React, { useState, useEffect, useCallback, useRef } from 'react'; // Importa useCallback y useRef\n-// Importa tus componentes de UI\n-import Navbar from '../../components/Navbar'; // <-- Ajusta esta ruta si es necesario\n-import SideBar from './Componentes-Iniciado/SideBar'; // <-- Ajusta esta ruta si es necesario\n-// Importa tu componente VoiceRecognition\n-import VoiceRecognition from \"./Componentes-Iniciado/Micro-enter\"; // <-- Ajusta esta ruta si es necesario\n-// Importa tus funciones de API\n-// getAuthenticatedUserFromSession lee el user object de sessionStorage['user'] y lo parsea\n-import { getUserProgress, getLogicProblem, submitLogicAnswer, getAuthenticatedUserFromSession } from \"../../utils/api\"; // <-- Ajusta esta ruta si es necesario\n-\n-\n-// ---> IMPORTA TU HOOK DEL CONTEXTO DE AUTENTICACIÓN <---\n-// Usamos 'user' y 'loading' del contexto. El token se lee de sessionStorage en api.js.\n-// 'user' del contexto nos dirá si el AuthContext considera al usuario logeado.\n-import { useAuth } from '../../context/AuthContext'; // <-- ¡AJUSTA LA RUTA A TU CONTEXTO!\n-import { use } from 'react';\n-\n-// TODO: Si usas react-router-dom para navegación de salida, impórtalo aquí\n-// import { useNavigate } from 'react-router-dom';\n-\n-\n-// Importa Web Speech API (aunque ya no la usemos directamente para hablar, puede ser útil para verificar disponibilidad o voces)\n-const SpeechSynthesis = window.speechSynthesis;\n-const SpeechSynthesisUtterance = window.SpeechSynthesisUtterance; // No se usa directamente en speakText ahora\n-\n-\n-// --- Definir los estados posibles de la interacción ---\n-const INTERACTION_STATES = {\n-    IDLE: 'idle', // Estado inicial, esperando que cargue el AuthContext\n-    LOADING_PROGRESS: 'loading_progress', // Cargando progreso del backend\n-    SHOWING_PROGRESS: 'showing_progress', // Progreso cargado y listo para ser leído/mostrado\n-    OFFERING_CHOICES: 'offering_choices', // Preguntando al usuario qué quiere hacer (practicar, progreso, salir)\n-    ASKING_DIFFICULTY: 'asking_difficulty', // Preguntando qué dificultad quiere practicar\n-    LOADING_PROBLEM: 'loading_problem', // Cargando un problema específico del backend\n-    PRESENTING_PROBLEM: 'presenting_problem', // Problema cargado y leído, esperando que el usuario grabe (tecla Enter)\n-    RECORDING_ANSWER: 'recording_answer', // El usuario está grabando (VoiceRecognition está activo)\n-    PROCESSING_ANSWER: 'processing_answer', // Enviando respuesta al backend, esperando LLM\n-    SHOWING_FEEDBACK: 'showing_feedback', // Feedback del LLM cargado y listo para ser leído/mostrado\n-    POST_FEEDBACK_CHOICES: 'post_feedback_choices', // Preguntando al usuario qué hacer después del feedback (otro, cambiar, salir)\n-    ERROR: 'error', // Algo salió mal, esperando instrucción de recuperación/salida\n-    EXITING: 'exiting' // Saliendo de la sección\n-};\n-\n-let repeticion = 1;\n-// --- Flag para Session Storage para primera visita ---\n-const LOGIC_VISIT_FLAG_KEY = 'hasVisitedLogicSection'; // Clave para sessionStorage\n-\n-// --- Helper para verificar si es la primera visita en esta sesión ---\n-const isFirstLogicVisit = () => {\n-    // Si la clave no existe en sessionStorage, es la primera visita\n-    return sessionStorage.getItem(LOGIC_VISIT_FLAG_KEY) === null;\n-};\n-\n-// --- Helper para marcar que ya visitamos la sección en esta sesión ---\n-const setLogicVisitFlag = () => {\n-    // Guardar cualquier valor para indicar que ya visitamos\n-    sessionStorage.setItem(LOGIC_VISIT_FLAG_KEY, 'true');\n-};\n-\n-\n-// --- Helper para leer texto por voz (llamando al backend) ---\n-// Esta función se define FUERA del componente principal.\n-// Devuelve el objeto Audio si la reproducción se inicia correctamente.\n-const speakText = async (text, onEndCallback = null) => {\n-    if (!text) {\n-        console.warn(\"[speakText] Llamada con texto vacío. Ignorando.\");\n-         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n-        return null; // Devolver null si no se intenta reproducir\n-    }\n-    // Cancelar síntesis previa del navegador (la que usábamos antes, por si acaso)\n-    // SpeechSynthesis.cancel(); // Descomentar si antes usabas fallback TTS del navegador\n-\n-    console.log(`[speakText] Solicitando voz al backend para: \"${text.substring(0, Math.min(text.length, 50))}\"...`);\n-\n-    // URL del endpoint de backend que genera voz.\n-    // Debe coincidir con la API_BASE_URL de tu api.js + el endpoint /tts.\n-    const API_TTS_URL = \"http://127.0.0.1:8003/auth/api/logic/tts\"; // <-- ¡AJUSTA ESTA URL!\n-\n-    const token = sessionStorage.getItem('access_token'); // Obtener token directamente de sessionStorage\n-    if (!token) {\n-         console.error(\"[speakText] ERROR: No se encontró token en sessionStorage['access_token'] para la llamada TTS al backend.\");\n-         // Opcional: Usar un TTS de fallback del navegador si no hay token o falla el backend\n-         // speakTextFallback(text, onEndCallback); // Necesitarías implementar esta función\n-         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n-         return null; // Devolver null si no hay token\n-    }\n-\n-    // console.log(\"[speakText] Token encontrado en sessionStorage. Haciendo fetch a backend TTS.\"); // Redundante con log anterior\n-\n-\n-    try {\n-        const response = await fetch(API_TTS_URL, {\n-            method: 'POST',\n-            headers: {\n-                'Content-Type': 'application/json', // El backend /tts espera JSON {\"text\": ...}\n-                'Authorization': `Bearer ${token}`, // Adjuntar el token\n-            },\n-            body: JSON.stringify({ text: text }), // Enviar el texto en un cuerpo JSON\n-        });\n-\n-        console.log(`[speakText] Fetch completado. Status: ${response.status} ${response.statusText}`);\n-\n-        if (!response.ok) {\n-            let errorDetail = `Backend TTS error: ${response.status} ${response.statusText}`;\n-             let errorBody = null;\n-             try {\n-                 errorBody = await response.json();\n-                 console.error(\"[speakText] Backend Error Body (Parsed):\", errorBody); // Log el cuerpo de error\n-                 if (errorBody && errorBody.detail) {\n-                     if (Array.isArray(errorBody.detail)) { errorDetail += \" - Validation Errors: \" + errorBody.detail.map(err => `${err.loc.join('.')}: ${err.msg}`).join(\"; \"); }\n-                     else { errorDetail += ` - Detail: ${errorBody.detail}`; }\n-                 } else { errorDetail += \" - No detailed error body provided.\"; }\n-             } catch (e) { console.error(\"[speakText] Failed to parse backend error body as JSON.\", e); }\n-            console.error(\"[speakText] ERROR: Llamada al backend TTS falló.\", errorDetail);\n-            // Opcional: Usar un TTS de fallback del navegador si falla el backend\n-            // speakTextFallback(text, onEndCallback);\n-             if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n-            return null; // Devolver null si la llamada falló\n-        }\n-\n-        console.log(\"[speakText] Backend TTS respondió OK. Convirtiendo respuesta a Blob.\");\n-        const audioBlob = await response.blob();\n-        const audioUrl = URL.createObjectURL(audioBlob);\n-\n-        console.log(\"[speakText] Blob creado. Reproduciendo audio.\");\n-        const audio = new Audio(audioUrl);\n-\n-        // Configurar el callback para cuando termine la reproducción\n-        audio.onended = () => {\n-            console.log(\"[speakText] Audio playback finished.\");\n-            URL.revokeObjectURL(audioUrl); // Limpiar el Blob URL después de usarlo\n-            if (onEndCallback && typeof onEndCallback === 'function') {\n-                 onEndCallback(); // Ejecutar el callback al finalizar\n-            }\n-        };\n-\n-         // Configurar manejo de errores de reproducción de audio\n-        audio.onerror = (e) => {\n-             console.error(\"[speakText] ERROR: Audio playback error.\", e);\n-             URL.revokeObjectURL(audioUrl); // Limpiar el Blob URL en caso de error\n-              if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n-        };\n-\n-\n-        // Reproducir el audio\n-        audio.play().catch(playError => {\n-            // play() retorna una Promesa, capturar errores de reproducción (ej. navegador bloquea autoplay)\n-             console.error(\"[speakText] ERROR: Error starting audio playback.\", playError);\n-             // Limpiar el Blob URL\n-             URL.revokeObjectURL(audioUrl);\n-              if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n-        });\n-\n-        return audio; // Devolver el objeto Audio si la reproducción se inicia (no garantiza que termine)\n-\n-    } catch (error) {\n-        // Este catch captura errores de red o errores lanzados antes de response.ok\n-        console.error(\"[speakText] ERROR: Error during fetch or initial processing.\", error);\n-        // Opcional: Usar un TTS de fallback del navegador si falla la llamada\n-        // speakTextFallback(text, onEndCallback);\n-         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n-        return null; // Devolver null si hubo un error en el fetch/proceso inicial\n-    }\n-};\n-\n-// Helper para manejar errores de flujo de interacción y pasar al estado ERROR (definida fuera)\n-// Ya no necesita speakText como argumento porque speakText es global\n-const handleInteractionErrorHelper = (errorMsg, setProblemError, setInteractionState, speakText, navigateToLogin = false, navigate = null) => { // speakText ya no se pasa, usar la función global\n-     console.error(\"[LogicPage] Interaction Error:\", errorMsg);\n-     // Solo seteamos el error visual/para TTS si no es el error de no autenticado que puede ser manejado por redirección\n-     if (errorMsg !== \"Debes iniciar sesión para acceder a esta sección.\") {\n-          setProblemError(errorMsg); // Usamos problemError para errores de flujo general\n-     }\n-     setInteractionState(INTERACTION_STATES.ERROR); // Pasar a estado ERROR\n-     // Aquí llamamos a speakText directamente (ya no se pasa como argumento)\n-     speakText(`Error del sistema: ${errorMsg}. Por favor, intenta de nuevo o sal con Escape.`, () => {\n-          if(navigateToLogin && navigate){\n-              // Implementar navegación de salida aquí si es un error de autenticación\n-              console.log(\"[LogicPage] Redirecting to login after auth error.\");\n-              navigate('/login'); // Ejemplo con react-router-dom\n-              // logout(); // Si la redirección también implica limpiar sesión actual\n-          }\n-     });\n-};\n-\n-\n-export const LogicSectionPage = () => {\n-  // --- Estado de la Sidebar (si lo usas, mantener esta parte) ---\n-   const [isSidebarExpanded, setIsSidebarExpanded] = useState(false);\n-   const handleSidebarToggle = useCallback((expanded) => { // Use useCallback for stability\n-     setIsSidebarExpanded(expanded);\n-   }, []); // Empty dependency array as it doesn't depend on anything else\n-\n-  // --- Obtener estado de autenticación del contexto ---\n-   // Usamos 'user' y 'loading' del contexto. El token se lee de sessionStorage en api.js.\n-   // 'user' del contexto nos dirá si el AuthContext considera al usuario logeado.\n-   const { user, loading: authLoading, logout } = useAuth();\n-   // Opcional: Loguear si el token existe en sessionStorage (para depuración)\n-   console.log(\"[LogicPage] Auth State (from Context):\", { user: user?.email, authLoading });\n-   console.log(\"[LogicPage] Token State (from SessionStorage):\", sessionStorage.getItem('access_token') ? 'exists' : 'null');\n-\n-\n-  // TODO: Si usas react-router-dom para navegación de salida, inicializa el hook aquí\n-  // const navigate = useNavigate();\n-\n-\n-  // --- Estado principal de la interacción ---\n-  const [interactionState, setInteractionState] = useState(INTERACTION_STATES.IDLE);\n-\n-  // --- Estados de datos ---\n-  const [userProgress, setUserProgress] = useState(null); // Progreso cargado\n-  const [currentProblem, setCurrentProblem] = useState(null); // Problema actual\n-  const [backendFeedback, setBackendFeedback] = useState(''); // Feedback del LLM\n-  const [recognizedText, setRecognizedText] = useState(''); // Texto de VoiceRecognition\n-\n-  // --- Estados de errores ---\n-  const [progressError, setProgressError] = useState(null); // Error al cargar progreso (No usado actualmente, se usa problemError)\n-  const [problemError, setProblemError] = useState(null); // Error cargar problem, mensaje \"no hay problem\", o error de flujo gral\n-  const [backendError, setBackendError] = useState(''); // Errores de submit_answer o reconocimiento vacío\n-\n-  // --- REFERENCIA PARA EL AUDIO ACTUALMENTE REPRODUCIÉNDOSE ---\n-  const audioRef = useRef(null); // Para mantener la referencia del objeto Audio\n-\n-  // --- Helper para detener el audio actual y reproducir uno nuevo ---\n-  // Esta es la función que llamaremos DENTRO del componente para iniciar una reproducción.\n-  // Usa useCallback para que sea estable y no cause re-renders innecesarios.\n-  const speakAndStopOthers = useCallback(async (text, onEndCallback = null) => {\n-      // 1. Detener cualquier audio que se esté reproduciendo a través de esta referencia\n-      if (audioRef.current) {\n-          console.log(\"[speakAndStopOthers] Deteniendo audio previo.\");\n-          audioRef.current.pause(); // Pausar\n-          audioRef.current.currentTime = 0; // Resetear tiempo (opcional)\n-           // No limpiamos la referencia ni el URL aquí, speakText lo hará al terminar/error si devuelve el objeto audio.\n-      }\n-\n-       // Llamar a la función speakText global que hace el fetch y crea el Audio object\n-       // speakText AHORA DEBE DEVOLVER el objeto Audio si la llamada y creación fueron exitosas.\n-       const audioObject = await speakText(text, onEndCallback); // Pasar el callback original\n-\n-       // Si speakText devolvió el objeto Audio, guardarlo en la referencia\n-       if (audioObject) {\n-            audioRef.current = audioObject;\n-       } else {\n-            // Si speakText devolvió null (error o texto vacío), asegurar que la referencia se limpia\n-            audioRef.current = null;\n-       }\n-\n-   }, []); // Dependencias: ninguna si speakText es global y no usa estados/props\n-\n-\n-    // --- Helper para manejar errores de flujo de interacción (Usar useCallback) ---\n-    const handleInteractionError = useCallback((errorMsg, navigateToLogin = false) => {\n-        // Pasa null por navigate si no lo usas/necesitas aquí, o pasa el hook navigate si lo usas:\n-        // const navigate = useNavigate(); // <--- Descomentar si usas react-router-dom\n-        handleInteractionErrorHelper(errorMsg, setProblemError, setInteractionState, speakText, navigateToLogin, null); // O pasa 'navigate' si lo tienes\n-    }, [setProblemError, setInteractionState, speakText]); // Dependencias necesarias para el hook useCallback (añadir navigate si se usa)\n-\n-\n-  // --- Función para verificar si los datos mínimos de auth están en SessionStorage ---\n-  // Esta función reemplaza la verificación de 'token' en los triggers de los useEffect\n-  // Verificamos si las claves específicas de sessionStorage existen y tienen contenido.\n-  // Esto NO valida el contenido, solo si están presentes.\n-  const isAuthDataReadyForFlow = useCallback(() => {\n-       // Revisa si los campos clave existen en sessionStorage y no están vacíos.\n-       const tokenExists = typeof sessionStorage.getItem('access_token') === 'string' && sessionStorage.getItem('access_token').length > 0;\n-       const userJsonExists = typeof sessionStorage.getItem('user') === 'string' && sessionStorage.getItem('user').length > 0;\n-\n-       // Verificamos también si el AuthContext logró setear un user object.\n-       // Esto ayuda a asegurar que el AuthContext al menos intentó inicializarse.\n-        const userObjectExistsInContext = !!user; // user viene de useAuth()\n-\n-\n-       return tokenExists && userJsonExists && userObjectExistsInContext && !authLoading; // AuthContext debe haber terminado de cargar\n-\n-  }, [user, authLoading]); // Depende de si el user object en context cambia y si authLoading termina.\n-\n-\n-  // --- Función para cargar el progreso ---\n-  const loadProgress = useCallback(async () => {\n-         // SOLO ejecutar la llamada a la API si estamos en el estado correcto (LOADING_PROGRESS)\n-         if (interactionState !== INTERACTION_STATES.LOADING_PROGRESS) {\n-              console.log(`[LogicPage] loadProgress API call skipped. State is ${interactionState}.`);\n-              return; // No hacer la llamada API si no estamos en el estado LOADING_PROGRESS\n-         }\n-         // Si ya tenemos progreso y no estamos en un estado que requiera recarga (ej. después de resolver)\n-         // podemos saltar la llamada API, pero debemos asegurar la transición al siguiente estado.\n-         if (userProgress && (interactionState !== INTERACTION_STATES.ERROR && interactionState !== INTERACTION_STATES.POST_FEEDBACK_CHOICES)) {\n-              console.log(\"[LogicPage] Progress already loaded. Skipping API call.\");\n-               // Si estábamos en LOADING_PROGRESS pero ya teníamos datos, pasar a mostrar.\n-               setInteractionState(INTERACTION_STATES.SHOWING_PROGRESS);\n-              return;\n-         }\n-\n-\n-         console.log(\"[LogicPage] Executing actual progress API call.\");\n-         // El estado ya debe ser LOADING_PROGRESS al llegar aquí.\n-\n-         // Verificamos ANTES de la llamada API que los datos de auth estén en SessionStorage.\n-         // La función getUserProgress (en api.js) también lo verifica internamente llamando a getAuthTokenFromSession.\n-         if (!isAuthDataReadyForFlow()) { // <-- Usamos la nueva verificación aquí\n-              console.error(\"[LogicPage] loadProgress API call attempted without sufficient auth data in SessionStorage!\");\n-               // Esto no debería pasar si el flujo de estados es correcto, pero es una seguridad.\n-              handleInteractionError(\"No se encontraron datos de inicio de sesión válidos. Por favor, inicia sesión de nuevo.\", true); // Redirigir/error\n-              return;\n-         }\n-\n-\n-         try {\n-           // LLAMADA API - SIN PASAR TOKEN (ya lo obtiene internamente de sessionStorage)\n-           const progressData = await getUserProgress();\n-           setUserProgress(progressData);\n-           console.log(\"[LogicPage] Progress API call successful.\");\n-           setInteractionState(INTERACTION_STATES.SHOWING_PROGRESS); // Transición después de cargar\n-\n-         } catch (error) {\n-           console.error(\"[LogicPage] Progress API call failed:\", error);\n-            // Si es un error 401 de API, significa que el token de sessionStorage es inválido/expirado (el backend lo rechazó)\n-            // Asumiendo que el error tiene una propiedad status (puede variar según cómo manejes los errores de fetch/axios)\n-             if (error && error.status === 401) {\n-                  handleInteractionError(\"Tu sesión ha expirado. Por favor, inicia sesión de nuevo.\", true); // Redirigir/error\n-             } else {\n-                 handleInteractionError(`No se pudo cargar el progreso. ${error.message || 'Error desconocido'}`); // Transición a ERROR\n-             }\n-\n-         }\n-    }, [userProgress, interactionState, handleInteractionError, getUserProgress, setUserProgress, setInteractionState, isAuthDataReadyForFlow]); // Dependencias. Asegurarse de que getUserProgress es estable.\n-\n-\n-  // --- useEffect para la Inicialización (Controla el flujo inicial IDLE -> OFFERING_CHOICES o ERROR) ---\n-  // Este efecto solo reacciona a cambios en el estado de autenticación y al estado IDLE\n-  useEffect(() => {\n-      console.log(\"[LogicPage] Auth state or interactionState changed.\", { user: user?.email, authLoading, interactionState });\n-\n-      // Si Auth context termina de cargar Y estamos en el estado inicial IDLE\n-      if (!authLoading && interactionState === INTERACTION_STATES.IDLE) {\n-          // Check if required auth data EXISTS IN SESSIONSTORAGE para iniciar el flujo\n-          if (isAuthDataReadyForFlow()) { // <-- Usamos la nueva verificación\n-            // Datos de autenticación necesarios encontrados en SessionStorage, START the flow\n-            console.log(\"[LogicPage] Auth finished, auth data found in SessionStorage. Offering initial choices.\");\n-            setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); // <-- CAMBIO CLAVE: Ir directo a ofrecer opciones\n-            \n-          } else {\n-            // Auth finished loading, but NO required data found in SessionStorage. User is NOT authenticated for this section.\n-            console.warn(\"[LogicPage] Auth finished loading, but NO auth data found in SessionStorage. User not authenticated for this section.\");\n-            // Set a message and transition to ERROR state (marking it as an auth error)\n-            handleInteractionError(\"Debes iniciar sesión para acceder a esta sección.\", true); // Pasar true para posible redirección\n-          }\n-        } else if (interactionState === INTERACTION_STATES.OFFERING_CHOICES) {\n-            // Auth finished loading, and we are in IDLE state. This means we are ready to offer choices.\n-            speakAndStopOthers(\"¿Quieres practicar lógica, escuchar tu progreso, o salir?\")\n-            }\n-        else {\n-            // Auth finished loading, but we are NOT in IDLE state.\n-            // This means the flow was already started (or in ERROR etc.). Do nothing in this effect.\n-            console.log(`[LogicPage] Auth finished, but state is ${interactionState}. Initial load already handled.`);\n-        }\n-      }\n-      // If authLoading is true, the component is still initializing auth, do nothing in this effect yet.\n-\n-  , [user, authLoading, interactionState, handleInteractionError, setInteractionState, isAuthDataReadyForFlow]); // Dependencias (Usamos user en lugar de token)\n-\n-\n-  // --- useEffect que se activa cuando el estado es LOADING_PROGRESS para llamar a la API ---\n-  // Este useEffect es DISPARADO AHORA SOLO por el comando \"progreso\" en handleTextRecognized.\n-  // Su lógica interna sigue llamando a loadProgress API call cuando el estado es LOADING_PROGRESS\n-  useEffect(() => {\n-       if (interactionState === INTERACTION_STATES.LOADING_PROGRESS) {\n-           console.log(\"[LogicPage] Entering LOADING_PROGRESS state. Initiating API call.\");\n-           loadProgress();\n-       }\n-\n-  }, [interactionState, loadProgress]); // Dependencia: se ejecuta cuando interactionState cambia a LOADING_PROGRESS (y loadProgress es estable)\n-\n-\n-  // --- useEffect para leer el progreso y pasar a OFERTAR OPCIONES ---\n-  // Se activa cuando el estado es SHOWING_PROGRESS\n-  useEffect(() => {\n-       if (interactionState === INTERACTION_STATES.SHOWING_PROGRESS && userProgress) {\n-           console.log(\"[LogicPage] Entering SHOWING_PROGRESS state. Reading progress.\");\n-           // LINE 231 (CORRECTED): Ensure correct template literal syntax\n-           let progressText = `Tu progreso. Total resueltos: ${userProgress.total_solved}. Promedio general: ${userProgress.overall_average_grade !== null ? userProgress.overall_average_grade.toFixed(2) : 'N/A'}. `;\n-           Object.entries(userProgress.progress_by_difficulty).forEach(([level, data]) => {\n-                progressText += `Nivel ${level}: ${data.solved_count} resueltos${data.solved_count > 0 ? `, promedio ${data.average_grade.toFixed(2)}` : ''}. `;\n-           });\n-           // Leer el progreso y, al terminar, pasar al estado OFFERING_CHOICES\n-           speakAndStopOthers(progressText, () => {\n-                console.log(\"[LogicPage] Reading progress finished. Offering choices.\");\n-                setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); // Transición después de leer\n-           });\n-\n-       }\n-  }, [interactionState, userProgress, setInteractionState, speakAndStopOthers]); // Depende de interactionState, userProgress, setInteractionState, y speakAndStopOthers\n-\n-\n-// --- Función para cargar un nuevo problema ---\n-const loadNewProblem = useCallback(async (difficulty = null) => {\n-    console.log(`[LogicPage] loadNewProblem - INICIO. Dificultad: ${difficulty}. Estado actual de interacción: ${interactionState}`);\n-\n-    // Verificamos que los datos de auth estén en SessionStorage antes de intentar API call\n-    if (!isAuthDataReadyForFlow()) {\n-        console.error(\"[LogicPage] loadNewProblem - Falla la verificación isAuthDataReadyForFlow.\");\n-        handleInteractionError(\"No hay datos de inicio de sesión disponibles en SessionStorage para cargar problema.\", true); // Redirigir/error\n-        return;\n-    }\n-\n-    // Evitar múltiples cargas o llamadas si ya estamos en proceso\n-    if (interactionState === INTERACTION_STATES.LOADING_PROBLEM || interactionState === INTERACTION_STATES.PROCESSING_ANSWER) {\n-        console.warn(`[LogicPage] loadNewProblem - Se intentó cargar pero ya estaba en estado: ${interactionState}. Se ignora.`);\n-        return;\n-    }\n-\n-    console.log(\"[LogicPage] loadNewProblem - Estableciendo estado a LOADING_PROBLEM y reseteando estados relevantes.\");\n-    setInteractionState(INTERACTION_STATES.LOADING_PROBLEM); // Nuevo estado: Cargando problema\n-    setProblemError(null); // Limpiar errores anteriores de problema/no hay problemas\n-    setCurrentProblem(null); // Limpiar problema anterior\n-    console.log(\"[LogicPage] loadNewProblem - currentProblem reseteado a null.\"); // LOG CLAVE\n-    setRecognizedText(''); // Limpiar input anterior de voz\n-    setBackendFeedback(''); // Limpiar feedback anterior\n-    setBackendError(''); // Limpiar errores de submit_answer/reconocimiento\n-\n-    try {\n-        console.log(\"[LogicPage] loadNewProblem - Llamando a getLogicProblem con dificultad:\", difficulty);\n-        const problemData = await getLogicProblem(difficulty);\n-        // Usar JSON.stringify para ver la estructura completa si es un objeto complejo.\n-        // Si problemData puede ser undefined o null, tener cuidado con stringify.\n-        console.log(\"[LogicPage] loadNewProblem - Datos recibidos de getLogicProblem:\", typeof problemData === 'object' ? JSON.stringify(problemData) : problemData); // LOG CLAVE\n-\n-        if (problemData && problemData._id) { // Asegúrate que aquí es _id\n-            setCurrentProblem(problemData);\n-            console.log(\"[LogicPage] loadNewProblem - setCurrentProblem EJECUTADO con datos. ID del Problema:\", problemData._id); // LOG CLAVE\n-            setInteractionState(INTERACTION_STATES.PRESENTING_PROBLEM); // Indicar que el problema está listo para ser leído\n-            console.log(\"[LogicPage] loadNewProblem - Estado cambiado a PRESENTING_PROBLEM.\");\n-        } else if (problemData && problemData.message) { // Si tiene un 'message', es el mensaje de no hay problemas\n-            setCurrentProblem(null); // Asegurar que no haya problema actual\n-            setProblemError(problemData.message); // Almacenar el mensaje\n-            console.warn(\"[LogicPage] loadNewProblem - No hay problemas disponibles. Mensaje:\", problemData.message);\n-            speakAndStopOthers(`Mensaje del sistema. ${problemData.message}`, () => {\n-                console.log(\"[LogicPage] loadNewProblem - Mensaje 'No hay problemas' leído. Cambiando estado a OFFERING_CHOICES.\");\n-                setInteractionState(INTERACTION_STATES.OFFERING_CHOICES);\n-            });\n-        } else {\n-            // Es posible que problemData sea null, undefined, o un formato inesperado\n-            console.error(\"[LogicPage] loadNewProblem - problemData no tiene _id ni message. problemData recibido:\", typeof problemData === 'object' ? JSON.stringify(problemData) : problemData); // LOG CLAVE\n-            handleInteractionError(\"Error inesperado al obtener problema: Formato de respuesta desconocido o datos incompletos.\");\n-        }\n-    } catch (error) {\n-        console.error(\"[LogicPage] loadNewProblem - ERROR en el bloque try-catch:\", error);\n-        if (error && error.status === 401) {\n-            handleInteractionError(\"Tu sesión ha expirado. Por favor, inicia sesión de nuevo.\", true);\n-        } else {\n-            handleInteractionError(`No se pudo obtener un nuevo problema. ${error.message || 'Error desconocido'}`);\n-        }\n-    }\n-}, [interactionState, handleInteractionError, /*getLogicProblem,*/ /*setInteractionState,*/ /*setCurrentProblem,*/ /*setProblemError,*/ /*setRecognizedText,*/ /*setBackendFeedback,*/ /*setBackendError,*/ isAuthDataReadyForFlow, speakAndStopOthers]);\n-// NOTA SOBRE DEPENDENCIAS:\n-// Las dependencias comentadas son las funciones de estado (setX) o funciones importadas que usualmente son estables.\n-// ESlint puede quejarse si no están, pero si sabes que son estables, a veces se omiten para evitar re-creaciones innecesarias del callback.\n-// Sin embargo, es más seguro incluirlas todas como las tenías originalmente si no estás seguro:\n-// [interactionState, handleInteractionError, getLogicProblem, setInteractionState, setCurrentProblem, setProblemError, setRecognizedText, setBackendFeedback, setBackendError, isAuthDataReadyForFlow, speakAndStopOthers]\n-\n-   // --- useEffect para leer el problema y pasar a PRESENTING_PROBLEM ---\n-   // Se activa cuando el estado es PRESENTING_PROBLEM\n-   useEffect(() => {\n-        if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM && currentProblem && currentProblem.text) {\n-            console.log(\"[LogicPage] Entering PRESENTING_PROBLEM state. Reading problem.\");\n-            // Leer el problema y, al terminar, decir al usuario cómo grabar.\n-            // El estado se mantiene en PRESENTING_PROBLEM hasta que VoiceRecognition actúe (grabe/suelte Enter).\n-            speakAndStopOthers(`Problema. Dificultad ${currentProblem.difficulty}. ${currentProblem.text}. Presiona y mantén Enter para grabar tu respuesta.`, () => {\n-                  console.log(\"[LogicPage] Instruction to record read.\");\n-                  // No hacemos transición de estado aquí. La transición RECORDING_ANSWER\n-                  // la manejará handleListeningStatusChange (if implementamos la prop).\n-            });\n-\n-        }\n-   }, [interactionState, currentProblem, speakAndStopOthers]); // Dependencias\n-\n-\n-\n-    // --- Función para manejar el envío de la respuesta ---\n-    // Es llamada desde handleTextRecognized cuando el estado es PRESENTING_PROBLEM y hay texto\n-    const handleAnswerSubmission = useCallback(async (answerText, problemId) => {\n-         // Verificamos que los datos de auth estén en SessionStorage antes de intentar API call\n-         if (!isAuthDataReadyForFlow() || !problemId || !answerText) { // <-- Usamos la nueva verificación\n-             handleInteractionError(\"Faltan datos (autenticación o respuesta/problema) para enviar la respuesta.\");\n-             setInteractionState(INTERACTION_STATES.ERROR); // Asegurarse de ir a ERROR si faltan datos\n-             return;\n-         }\n-          // Solo procesar si estábamos en estado PRESENTING_PROBLEM esperando respuesta\n-          // OJO: Podríamos estar en RECORDING_ANSWER si handleTextRecognized se llama justo al terminar de grabar\n-          if (interactionState !== INTERACTION_STATES.PRESENTING_PROBLEM && interactionState !== INTERACTION_STATES.RECORDING_ANSWER) {\n-               console.warn(\"[LogicPage] handleAnswerSubmission called in incorrect state:\", interactionState);\n-               return; // Solo procesar si estábamos esperando una respuesta al problema\n-          }\n-\n-         setInteractionState(INTERACTION_STATES.PROCESSING_ANSWER); // Nuevo estado: Procesando respuesta\n-         setBackendError(''); // Limpiar errores anteriores de submit_answer\n-\n-\n-         try {\n-           // LLAMADA API - SIN PASAR TOKEN (ya lo obtiene internamente)\n-           const feedbackResponse = await submitLogicAnswer(problemId, answerText); // <-- YA NO PASAMOS TOKEN AQUÍ\n-\n-           // La respuesta del backend debe tener el formato del LLM: { analysis: \"...\", grade: X }\n-           if (feedbackResponse && typeof feedbackResponse.analysis === 'string' && typeof feedbackResponse.grade === 'number') {\n-                // Almacenar feedback para mostrar/leer\n-                setBackendFeedback(`Análisis: ${feedbackResponse.analysis} | Calificación: ${feedbackResponse.grade}/5.`); // Añadimos punto final para TTS\n-                console.log(\"[LogicPage] Feedback recibido:\", feedbackResponse);\n-                 // Transición de estado después de recibir feedback\n-                setInteractionState(INTERACTION_STATES.SHOWING_FEEDBACK); // Indicar que el feedback está listo para ser leído\n-\n-                // Opcional: Recargar el progreso en segundo plano (sin esperar await) para la siguiente visualización\n-                getUserProgress().then(setUserProgress).catch(e => console.error(\"Error reloading progress silently:\", e));\n-\n-           } else if (feedbackResponse && typeof feedbackResponse.detail === 'string') {\n-                // Si el backend devuelve un error de HTTP con detalle\n-                 handleInteractionError(`Error del backend: ${feedbackResponse.detail}`);\n-           }\n-           else {\n-                // Formato de respuesta de feedback inesperado\n-                handleInteractionError(\"Error: Formato de feedback del backend inesperado.\");\n-           }\n-\n-         } catch (error) {\n-           console.error(\"[LogicPage] Error al enviar respuesta al backend:\", error);\n-            // Si es un error 401 de API\n-             if (error && error.status === 401) {\n-                  handleInteractionError(\"Tu sesión ha expirado. Por favor, inicia sesión de nuevo.\", true); // Redirigir/error\n-             } else {\n-                 handleInteractionError(`Error al procesar respuesta: ${error.message || 'Error desconocido'}`);\n-             }\n-         }\n-         // Nota: El estado se actualiza en el try/catch. Si todo falla, se va al estado ERROR.\n-         // El estado PROCESSING_ANSWER se mantiene hasta que una de las ramas try/catch/error lo cambie.\n-    }, [interactionState, handleInteractionError, submitLogicAnswer, setInteractionState, setBackendFeedback, setBackendError, getUserProgress, setUserProgress, isAuthDataReadyForFlow]); // Dependencias\n-\n-\n-    // --- useEffect para leer el feedback y pasar a POST_FEEDBACK_CHOICES ---\n-    // Se activa cuando el estado es SHOWING_FEEDBACK\n-    useEffect(() => {\n-       if (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && backendFeedback) {\n-           console.log(\"[LogicPage] Entering SHOWING_FEEDBACK state. Reading feedback.\");\n-           // Leer feedback y, al terminar, pasar al estado POST_FEEDBACK_CHOICES\n-            speakAndStopOthers(`Feedback del asistente. ${backendFeedback}`, () => { // <-- USAR speakAndStopOthers\n-                 console.log(\"[LogicPage] Reading feedback finished. Offering post-feedback choices.\");\n-                 setInteractionState(INTERACTION_STATES.POST_FEEDBACK_CHOICES); // Transición después de leer\n-                 // Al pasar a POST_FEEDBACK_CHOICES, la función handleTextRecognized\n-                 // interpretará los comandos \"otro\", \"cambiar\", \"salir\", \"progreso\".\n-                 // Opcional: Decir por voz las opciones principales después del feedback\n-                  speakAndStopOthers(\"¿Quieres otro problema, cambiar dificultad, escuchar tu progreso, o salir?\"); // Es útil para guiar al usuario\n-            });\n-       } else if (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && backendError) {\n-            // Si hay un error de backend que llegó a SHOWING_FEEDBACK\n-            console.log(\"[LogicPage] Entering SHOWING_FEEDBACK state with backend error.\", backendError);\n-             // No leer el error de \"no voz detectada\"\n-             if (backendError !== \"No se detectó voz. Intenta hablar más claro.\") {\n-                  speakAndStopOthers(`Error del sistema. ${backendError}. Por favor, intenta de nuevo o sal con Escape.`, () => { // <-- USAR speakAndStopOthers\n-                      // Después de leer el error, pasar a un estado donde se pueda salir o reintentar\n-                      console.log(\"[LogicPage] Reading backend error finished. Transitioning to ERROR.\");\n-                      setInteractionState(INTERACTION_STATES.ERROR); // Pasar a estado ERROR\n-                  });\n-             } else {\n-                 // Si el error fue solo \"no detectó voz\", volver al estado de presentar problema para reintentar\n-                 console.log(\"[LogicPage] Reading 'no speech' error. Returning to PRESENTING_PROBLEM.\");\n-                 // Limpiamos el error para que no se muestre visualmente persistentemente\n-                 setBackendError(''); // Limpiar el error\n-                 setInteractionState(INTERACTION_STATES.PRESENTING_PROBLEM); // Volver a esperar grabación\n-                  speakAndStopOthers(\"No detecté tu respuesta. Intenta de nuevo. Presiona y mantén Enter para grabar.\"); // <-- USAR speakAndStopOthers\n-             }\n-       }\n-    }, [interactionState, backendFeedback, backendError, setInteractionState, setBackendError, speakAndStopOthers]); // Dependencias\n-\n-\n-    // --- Función para manejar el texto reconocido (el INTERPRETE DE COMANDOS) ---\n-    // Es llamada por VoiceRecognition cuando la grabación termina y hay texto o está vacía\n-    const handleTextRecognized = useCallback(async (text, isClearRequest = false) => {\n-       // Guardar el texto reconocido solo si no es una solicitud de limpieza total\n-       if (!isClearRequest) {\n-            setRecognizedText(text); // Actualizar el estado local del texto reconocido\n-             // Opcional: Leer el texto reconocido al usuario para confirmación si lo deseas en algún estado\n-             // if (interactionState === INTERACTION_STATES.SOME_STATE_TO_CONFIRM_INPUT) { speakAndStopOthers(`Dijiste: ${text}`); } // <-- USAR speakAndStopOthers si se hace\n-       }\n-\n-       // Limpiar el estado de backendError si fue por voz vacía de la vez anterior\n-       // Esto asegura que el mensaje visual y el estado de error se limpien\n-       if (backendError === \"No se detectó voz. Intenta hablar más claro.\") {\n-            setBackendError('');\n-       }\n-\n-\n-       // Lógica para limpiar la UI (si VoiceRecognition tiene un botón de limpiar que llama a esto)\n-       if (isClearRequest) {\n-           console.log(\"[LogicPage] Clear request received from VoiceRecognition.\");\n-           setRecognizedText('');\n-           setBackendFeedback('');\n-           setBackendError('');\n-           setProblemError(null); // Limpiar errores de problema/flujo\n-           // Volver a un estado neutral o el de ofrecer opciones principal\n-           setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); // Ejemplo: Volver a ofrecer opciones\n-            speakAndStopOthers(\"Conversación limpiada. ¿Quieres practicar lógica, escuchar tu progreso, o salir?\"); // <-- USAR speakAndStopOthers\n-           return;\n-       }\n-\n-       const lowerText = text.toLowerCase().trim();\n-\n-       // Si no hay texto reconocido válido después de la grabación (y no fue una solicitud de limpieza)\n-       if (!lowerText) {\n-            console.warn(\"[LogicPage] Grabación finalizada sin texto reconocido después de trim.\");\n-            // Si estábamos en un estado que esperaba una respuesta hablada (que no sea la respuesta al problema)\n-            if (interactionState === INTERACTION_STATES.ASKING_DIFFICULTY ||\n-                interactionState === INTERACTION_STATES.OFFERING_CHOICES ||\n-                interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES ||\n-                interactionState === INTERACTION_STATES.ERROR) // También si esperábamos un comando de error/salida\n-             {\n-                 // Decir que no se entendió y repetir las opciones/pregunta\n-                 speakAndStopOthers(\"No detecté voz. Por favor, repite tu elección.\"); // <-- USAR speakAndStopOthers\n-                 // Mantener el estado actual para esperar otra respuesta hablada\n-             } else if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM || interactionState === INTERACTION_STATES.RECORDING_ANSWER) { // Aceptar también si VR termina antes de que el estado cambie a RECORDING_ANSWER\n-                 // Si estábamos esperando la respuesta al problema pero no se detectó voz\n-                  setBackendError(\"No se detectó voz. Intenta hablar más claro.\"); // Usamos backendError para este mensaje\n-                  // El useEffect de leer feedback/error lo leerá y nos devolverá a PRESENTING_PROBLEM\n-             } else {\n-                  // En otros estados (ej. LOADING, SHOWING_PROGRESS, PROCESSING_ANSWER, RECORDING_ANSWER), simplemente ignorar voz vacía.\n-                  console.log(\"Voz vacía ignorada en estado:\", interactionState);\n-             }\n-            return; // Salir de la función si no hay texto para procesar\n-       }\n-\n-        // --- Interpretación de Comandos Basada en el Estado ---\n-        console.log(`[LogicPage] Procesando texto \"${lowerText}\" en estado: ${interactionState}`);\n-\n-\n-       switch (interactionState) {\n-           case INTERACTION_STATES.OFFERING_CHOICES: // Esperando \"practicar\", \"progreso\", \"salir\"\n-               if (lowerText.includes('practicar') || lowerText.includes('ejercicio')) {\n-                   setInteractionState(INTERACTION_STATES.ASKING_DIFFICULTY);\n-                   speakAndStopOthers(\"Okay. ¿Qué dificultad quieres practicar: básico, intermedio o avanzado?\"); // <-- USAR speakAndStopOthers\n-               } else if (lowerText.includes('progreso') || lowerText.includes('estadísticas')) {\n-                   // Volver a leer el progreso. Pasamos por SHOWING_PROGRESS.\n-                   setInteractionState(INTERACTION_STATES.LOADING_PROGRESS); // Transicionar a LOADING_PROGRESS para forzar recarga/relectura\n-               } else if (lowerText.includes('salir') || lowerText.includes('adiós')) {\n-                   setInteractionState(INTERACTION_STATES.EXITING);\n-                   speakAndStopOthers(\"Adiós. Espero verte pronto.\", () => { /* ... */ }); // <-- USAR speakAndStopOthers\n-               } else {\n-                   // Comando no reconocido en este estado\n-                   speakAndStopOthers(\"No entendí. ¿Quieres practicar lógica, escuchar tu progreso, o salir?\"); // <-- USAR speakAndStopOthers\n-                   // Mantener el estado OFFERING_CHOICES\n-               }\n-               break;\n-\n-           case INTERACTION_STATES.ASKING_DIFFICULTY: // Esperando \"básico\", \"intermedio\", \"avanzado\"\n-                if (lowerText.includes('básico') || lowerText.includes('basico')) {\n-                   loadNewProblem('basico'); // loadNewProblem cambiará el estado a LOADING_PROBLEM\n-               } else if (lowerText.includes('intermedio')) {\n-                   loadNewProblem('intermedio'); // loadNewProblem cambiará el estado\n-               } else if (lowerText.includes('avanzado')) {\n-                   loadNewProblem('avanzado'); // loadNewProblem cambiará el estado\n-               } else {\n-                   // Dificultad no reconocida\n-                   speakAndStopOthers(\"Dificultad no válida. Por favor, di básico, intermedio o avanzado.\"); // <-- USAR speakAndStopOthers\n-                   // Mantener el estado ASKING_DIFFICULTY\n-               }\n-               break;\n-\n-           case INTERACTION_STATES.PRESENTING_PROBLEM: // Esperando la respuesta al problema (la grabación ya terminó)\n-           case INTERACTION_STATES.RECORDING_ANSWER: // Aceptar también si VR termina antes de que el estado cambie a RECORDING_ANSWER\n-               // Si llegamos aquí con texto, es la respuesta al problema.\n-               if (lowerText) { // Asegurarse de que la transcripción no esté vacía después de trim\n-                   // Verificar si tenemos un currentProblem válido antes de intentar submit\n-                    if (currentProblem && currentProblem._id) {\n-                       handleAnswerSubmission(lowerText, currentProblem._id); // Llamar a la función de submit\n-                    } else {\n-                         console.warn(\"[LogicPage] Texto reconocido pero no hay currentProblem.id válido. Ignorando.\");\n-                          // Podríamos informar al usuario por voz que no hay problema activo\n-                          // speakAndStopOthers(\"No hay un problema activo para responder.\"); // <-- USAR speakAndStopOthers si se hace\n-                    }\n-               } else {\n-                   console.warn(\"[LogicPage] Texto de respuesta al problema vacío después de trim.\");\n-                   // Ya se maneja el error de \"No detectó voz\" arriba.\n-               }\n-               break;\n-\n-           case INTERACTION_STATES.POST_FEEDBACK_CHOICES: // Feedback leído, esperando \"otro\", \"cambiar\", \"salir\", \"progreso\"\n-                if (lowerText.includes('otro') || lowerText.includes('siguiente')) {\n-                    // Cargar otro problema del MISMO NIVEL\n-                    const nextDifficulty = currentProblem?.difficulty; // Usar la dificultad del problema recién resuelto\n-                    if (nextDifficulty) {\n-                         speakAndStopOthers(\"Okay, buscando otro problema...\", () => { // <-- USAR speakAndStopOthers\n-                              loadNewProblem(nextDifficulty); // Cargar siguiente del mismo nivel\n-                         });\n-                    } else {\n-                         // Si no sabemos la dificultad del problema anterior, pedirla de nuevo (caso raro)\n-                         speakAndStopOthers(\"Okay, otro problema...\", () => { // <-- USAR speakAndStopOthers\n-                              setInteractionState(INTERACTION_STATES.ASKING_DIFFICULTY);\n-                              speakAndStopOthers(\"¿Qué dificultad quieres practicar?\"); // <-- USAR speakAndStopOthers\n-                         });\n-                    }\n-                } else if (lowerText.includes('cambiar') || lowerText.includes('dificultad')) {\n-                    // Pedir cambiar dificultad\n-                    setInteractionState(INTERACTION_STATES.ASKING_DIFFICULTY);\n-                    speakAndStopOthers(\"Okay. ¿Qué dificultad quieres practicar: básico, intermedio o avanzado?\"); // <-- USAR speakAndStopOthers\n-                } else if (lowerText.includes('salir') || lowerText.includes('adiós')) {\n-                    setInteractionState(INTERACTION_STATES.EXITING);\n-                   speakAndStopOthers(\"Adiós. Espero verte pronto.\", () => { /* ... */ }); // <-- USAR speakAndStopOthers\n-                } else if (lowerText.includes('progreso') || lowerText.includes('estadísticas')) {\n-                     // Leer progreso y volver a ofrecer opciones post-feedback\n-                    speakAndStopOthers(\"Okay, revisemos tu progreso.\", () => { // <-- USAR speakAndStopOthers\n-                         // Mostrar progreso (ya debería estar cargado). El useEffect se encargará de leerlo y volver a OFFERING_CHOICES\n-                         // Si queremos que después de leer progreso vuelva a POST_FEEDBACK_CHOICES, necesitaríamos lógica adicional.\n-                         // Por simplicidad, lo mandamos a LOADING_PROGRESS para releerlo y luego a OFFERING_CHOICES.\n-                         setInteractionState(INTERACTION_STATES.LOADING_PROGRESS); // Dispara la carga/relectura\n-                    });\n-                }\n-                else {\n-                    // Comando no reconocido en este estado\n-                    speakAndStopOthers(\"No entendí. ¿Quieres otro problema, cambiar dificultad, escuchar tu progreso, o salir?\"); // <-- USAR speakAndStopOthers\n-                    // Mantener el estado POST_FEEDBACK_CHOICES\n-                }\n-               break;\n-\n-           case INTERACTION_STATES.ERROR: // En estado de error, esperando comando de recuperación/salida\n-                if (lowerText.includes('salir') || lowerText.includes('adiós')) {\n-                     setInteractionState(INTERACTION_STATES.EXITING);\n-                       speakAndStopOthers(\"Okay, saliendo.\", () => { /* ... */ }); // <-- USAR speakAndStopOthers\n-                } else if (lowerText.includes('intentar') || lowerText.includes('empezar') || lowerText.includes('inicio') || lowerText.includes('reiniciar')) {\n-                     // Intentar reiniciar el flujo\n-                      speakAndStopOthers(\"Okay, intentemos desde el inicio.\", () => { // <-- USAR speakAndStopOthers\n-                           // Limpiar estados relevantes\n-                           setCurrentProblem(null);\n-                           setProblemError(null);\n-                           setBackendFeedback('');\n-                           setBackendError('');\n-                           setRecognizedText('');\n-                           setUserProgress(null); // Forzar recarga de progreso\n-                           // Volver al inicio del flujo principal (cargar progreso)\n-                           setInteractionState(INTERACTION_STATES.LOADING_PROGRESS); // Dispara la carga/relectura\n-                      });\n-                }\n-                else {\n-                     // Comando no reconocido en estado de error\n-                     speakAndStopOthers(\"No entendí. ¿Quieres salir, o intentar desde el inicio?\"); // <-- USAR speakAndStopOthers\n-                     // Mantener estado ERROR\n-                }\n-               break;\n-\n-           default: // Ignorar voz en otros estados (IDLE, LOADING, PROCESSING, RECORDING)\n-               console.log(`[LogicPage] Texto \"${lowerText}\" ignorado en estado: ${interactionState}`);\n-               break;\n-       }\n-    }, [interactionState, currentProblem, backendError, loadNewProblem, handleAnswerSubmission, setInteractionState, setRecognizedText, setBackendFeedback, setBackendError, setProblemError, setCurrentProblem, setUserProgress, handleInteractionError, speakAndStopOthers]); // Dependencias\n-\n-\n-    const handleListeningStatusChange = useCallback((isListening) => {\n-        console.log(\"[LogicPage] Micrófono callback:\", isListening ? \"EMPEZÓ A ESCUCHAR\" : \"TERMINÓ DE ESCUCHAR\");\n-    \n-        if (isListening) {\n-            if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM) {\n-                console.log(\"[LogicPage] Micrófono INICIADO. Esperando respuesta al problema...\");\n-                setBackendError('');\n-                // Cambiar a RECORDING_ANSWER sin reproducir audio para evitar conflictos\n-                setInteractionState(prevInteractionState =>\n-                    prevInteractionState === INTERACTION_STATES.PRESENTING_PROBLEM\n-                        ? INTERACTION_STATES.RECORDING_ANSWER\n-                        : prevInteractionState\n-                );\n-                // Eliminamos la reproducción de \"Adelante\" que parece estar causando conflictos\n-            }\n-        } else {\n-            // El micrófono ha terminado de escuchar (onend o onerror en VoiceRecognition)\n-            if (interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n-                console.log(\"[LogicPage] Micrófono DETENIDO. Procesando respuesta...\");\n-                // VoiceRecognition llamará a onTextRecognized que manejará el siguiente estado.\n-            } else {\n-                // Si deja de escuchar y no estábamos grabando (ej. error al iniciar),\n-                // resetear el mensaje si se quedó en \"Grabando...\"\n-                console.log(\"[LogicPage] Micrófono DETENIDO pero no estábamos grabando. Limpiando mensaje.\");\n-            }\n-        }\n-    }, [interactionState, setInteractionState, setBackendError]);\n-\n-    // --- Implementar listener de teclado general (para acciones como Escape y Enter de flujo) ---\n-    useEffect(() => {\n-        const handleKeyDown = (event) => {\n-             // No procesar si un input/textarea tiene foco (si tuvieras alguno)\n-             if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {\n-                 return;\n-             }\n-\n-            // Ignorar eventos de teclado si está en un estado de carga o procesamiento crítico donde no queremos interrupción.\n-            // O si está grabando (Enter lo maneja VR, Escape podría ser útil pero puede ser confuso)\n-            if (interactionState === INTERACTION_STATES.LOADING_PROGRESS ||\n-                interactionState === INTERACTION_STATES.LOADING_PROBLEM ||\n-                interactionState === INTERACTION_STATES.PROCESSING_ANSWER ||\n-                interactionState === INTERACTION_STATES.EXITING\n-               ) {\n-                 // console.log(`[LogicPage] Keyboard event (${event.key}) ignored during critical state: ${interactionState}`);\n-                return;\n-               }\n-\n-            // --- Manejar tecla Escape ---\n-             if (event.key === 'Escape') {\n-                // Permitir salir desde cualquier estado excepto los críticos ya filtrados\n-                 console.log(\"[LogicPage] Escape pressed. Initiating exit.\");\n-                 SpeechSynthesis.cancel(); // Limpiar cualquier TTS que esté hablando (menos crítico ahora con speakAndStopOthers, pero buena práctica)\n-                 // Asegurar que cualquier audio de backend también se detenga\n-                 if (audioRef.current) {\n-                      audioRef.current.pause();\n-                      audioRef.current.currentTime = 0;\n-                       if (audioRef.current.url) URL.revokeObjectURL(audioRef.current.url);\n-                      audioRef.current = null;\n-                 }\n-                 // Asegurar que el micrófono se detenga si estaba activo\n-                  setInterruptTrigger(prev => prev + 1);\n-\n-\n-                 setInteractionState(INTERACTION_STATES.EXITING);\n-                  speakAndStopOthers(\"Saliendo de la sección de lógica. Adiós.\", () => { // <-- USAR speakAndStopOthers\n-                      // TODO: Implementar navegación para salir de la sección\n-                      console.log(\"[LogicPage] Implementación de navegación de salida.\");\n-                       // const navigate = useNavigate(); navigate('/'); // Ejemplo con react-router-dom, requiere el hook useNavigate\n-                       // logout(); // Si salir también implica hacer logout también\n-                  });\n-                 event.preventDefault(); // Prevenir comportamiento por defecto\n-                 return; // No procesar Enter si ya se presionó Escape\n-             }\n-\n-            if (event.key === 'Enter') {\n-                // 1. Si ya se está grabando, VoiceRecognition lo maneja (para detener).\n-                //    Logica.jsx no hace nada.\n-                if (interactionState === INTERACTION_STATES.RECORDING_ANSWER) {\n-                    console.log(\"[LogicPage] Enter pressed during RECORDING_ANSWER. Handled by VoiceRecognition.\");\n-                    // VoiceRecognition.jsx debe llamar a event.preventDefault() si lo necesita.\n-                    return;\n-                }\n-\n-                // 2. Si estamos en un estado donde VoiceRecognition está visible y esperando\n-                //    Enter para INICIAR la grabación, Logica.jsx tampoco debe interferir.\n-                const isVoiceRecognitionActiveAndWaitingToStart = [\n-                    INTERACTION_STATES.OFFERING_CHOICES,\n-                    INTERACTION_STATES.ASKING_DIFFICULTY,\n-                    INTERACTION_STATES.PRESENTING_PROBLEM,\n-                    INTERACTION_STATES.POST_FEEDBACK_CHOICES,\n-                    INTERACTION_STATES.ERROR\n-                    // Asegúrate de que esta lista coincida con los estados donde VR está\n-                    // activo y Enter inicia la grabación.\n-                ].includes(interactionState);\n-\n-                if (isVoiceRecognitionActiveAndWaitingToStart) {\n-                    console.log(`[LogicPage] Enter pressed in state ${interactionState}. VoiceRecognition should handle this to START recording. Logica.jsx takes no action.`);\n-                    // VoiceRecognition.jsx debe llamar a event.preventDefault() si lo necesita.\n-                    return;\n-                }\n-\n-                // 3. Si llegamos aquí, Enter NO es para el micrófono en este momento.\n-                //    Y como NO quieres que Enter repita audios desde Logica.jsx,\n-                //    eliminamos toda la lógica que hacía eso.\n-                //    Lo que sigue es lo que puedes borrar de tu bloque original:\n-                //\n-                //    console.log(\"[LogicPage] Enter pressed outside recording. Repeating prompt or triggering action.\"); // <-- BORRAR o cambiar mensaje\n-                //    event.preventDefault(); // <-- BORRAR si Enter no debe hacer nada globalmente, o mantener si quieres prevenir default action siempre.\n-                //\n-                //    // TODAS LAS SIGUIENTES CONDICIONES if/else if QUE LLAMAN A speakAndStopOthers DEBEN SER BORRADAS:\n-                //    // if (interactionState === INTERACTION_STATES.ASKING_DIFFICULTY) { ... } <--- BORRAR\n-                //    // else if (interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES) { ... } <--- BORRAR\n-                //    // else if (interactionState === INTERACTION_STATES.ERROR && problemError) { ... } <--- BORRAR\n-                //    // else if (interactionState === INTERACTION_STATES.SHOWING_PROGRESS && userProgress) { ... } <--- BORRAR\n-                //    // else if (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM && currentProblem) { ... } <--- BORRAR (esta ya estaría cubierta por la guarda de arriba de todas formas)\n-                //    // else if (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && backendFeedback) { ... } <--- BORRAR\n-\n-                // En su lugar, puedes dejar un log para saber que se presionó Enter\n-                // y no se tomó acción deliberadamente, o incluso no hacer nada.\n-                console.log(`[LogicPage] Enter pressed in state ${interactionState}. No TTS repeat action defined in Logica.jsx for Enter.`);\n-                // Opcional: Si quieres que Enter no haga absolutamente nada (como scroll, submit de form si existiera)\n-                // en estos otros casos, puedes dejar un event.preventDefault();\n-                // event.preventDefault();\n-            }\n-\n-                 // Opcional: Implementar que Enter *después* de feedback pase al siguiente problema sin voz\n-                 // if (interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.SHOWING_FEEDBACK) {\n-                 //     console.log(\"[LogicPage] Enter pressed after feedback. Loading next problem.\");\n-                 //      const nextDifficulty = currentProblem?.difficulty;\n-                 //      if (nextDifficulty) { loadNewProblem(nextDifficulty); } else { setInteractionState(INTERACTION_STATES.OFFERING_CHOICES); speakText(\"¿Qué dificultad quieres practicar?\"); }\n-                 // }\n-\n-\n-                 event.preventDefault(); // Prevenir comportamiento por defecto del Enter (ej. en formularios)\n-            }\n-        \n-\n-        window.addEventListener('keydown', handleKeyDown);\n-        return () => {\n-            window.removeEventListener('keydown', handleKeyDown);\n-            SpeechSynthesis.cancel(); // Limpiar TTS al desmontar\n-        };\n-    }, [interactionState, speakAndStopOthers, handleInteractionError, loadNewProblem, userProgress, currentProblem, backendFeedback, problemError]); // Dependencias\n-\n-\n-    // Define los anchos de la sidebar (si los usas para layout)\n-    const sidebarCollapsedWidth = 60; // px\n-    const sidebarExpandedWidth = 250; // px\n-    const mainContentPaddingLeft = isSidebarExpanded ? sidebarExpandedWidth : sidebarCollapsedWidth;\n-\n-\n-    // --- Lógica de renderizado condicional ---\n-    // Mostramos diferentes mensajes o componentes según el estado de interacción\n-  return (\n-    // Contenedor principal\n-    \n-    <div className=\"flex min-h-screen bg-gradient-to-br from-gray-50 to-gray-100\">\n-      {/* SideBar (si lo usas) */}\n-      {/* ASEGÚRATE DE QUE ESTA LÍNEA NO ESTÉ COMENTADA Y LA RUTA SEA CORRECTA */}\n-      <SideBar isExpanded={isSidebarExpanded} onToggleExpansion={handleSidebarToggle} />\n-\n-      {/* Contenedor del Contenido Principal */}\n-      <main\n-        className=\"flex-1 min-w-0 overflow-x-hidden\"\n-        style={{ paddingLeft: `${mainContentPaddingLeft}px`, transition: 'padding-left 0.3s ease' }}\n-      >\n-        {/* Navbar (si lo usas) */}\n-         {/* ASEGÚRATE DE QUE ESTA LÍNEA NO ESTÉ COMENTADA Y LA RUTA SEA CORRECTA */}\n-        <Navbar />\n-\n-        {/* Contenido específico de la Sección de Lógica */}\n-        <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\"> {/* CORREGIDO: lg-px-8 -> lg:px-8 */}\n-            <h1>Sección de Lógica de Programación</h1>\n-            <p>Aquí puedes practicar problemas de lógica. Tu progreso y las respuestas serán analizadas.</p>\n-\n-            {/* Mensajes de estado general o carga */}\n-            <div style={{ marginTop: '20px', fontWeight: 'bold', minHeight: '2em' }}>\n-                {/* Si el AuthContext está cargando */}\n-                {authLoading && interactionState === INTERACTION_STATES.IDLE && <p>Cargando datos de usuario...</p>}\n-\n-                {/* Mensajes basados en el estado de interacción */}\n-                {!authLoading && (\n-                    <>\n-                       {/* Mostrar IDLE si no hay user object O si no hay datos de auth en sessionStorage */}\n-                       {interactionState === INTERACTION_STATES.IDLE && !isAuthDataReadyForFlow() && <p>Iniciando sección de lógica...</p>}\n-\n-                       {interactionState === INTERACTION_STATES.LOADING_PROGRESS && <p>Cargando progreso...</p>}\n-                       {interactionState === INTERACTION_STATES.SHOWING_PROGRESS && <p>Mostrando tu progreso...</p>}\n-                       {interactionState === INTERACTION_STATES.OFFERING_CHOICES && <p>Di: \"practicar\", \"progreso\" o \"salir\".</p>}\n-                       {interactionState === INTERACTION_STATES.ASKING_DIFFICULTY && <p>Di la dificultad: \"básico\", \"intermedio\" o \"avanzado\".</p>}\n-                       {interactionState === INTERACTION_STATES.LOADING_PROBLEM && <p>Cargando problema...</p>}\n-                       {interactionState === INTERACTION_STATES.PRESENTING_PROBLEM && <p>Problema cargado. Esperando grabación...</p>}\n-                       {interactionState === INTERACTION_STATES.RECORDING_ANSWER && <p style={{color: 'green'}}>🎙️ Grabando respuesta... (Suelta 'Enter' para terminar)</p>}\n-                       {interactionState === INTERACTION_STATES.PROCESSING_ANSWER && <p>Procesando respuesta...</p>}\n-                       {interactionState === INTERACTION_STATES.SHOWING_FEEDBACK && <p>Mostrando feedback...</p>}\n-                       {interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES && <p>Di: \"otro problema\", \"cambiar dificultad, escuchar tu progreso, o salir\".</p>}\n-                       {interactionState === INTERACTION_STATES.EXITING && <p>Saliendo...</p>}\n-                    </>\n-                )}\n-                 {/* Mostrar error general de flujo si el estado es ERROR */}\n-                 {interactionState === INTERACTION_STATES.ERROR && problemError && (\n-                     <p style={{ color: 'red', fontWeight: 'bold' }}>{problemError}. Di \"intentar de nuevo\" o \"salir\".</p>\n-                 )}\n-            </div>\n-\n-\n-            {/* Mostrar Progreso del Usuario - Solo si ha sido cargado y el estado lo permite */}\n-            {userProgress && (interactionState === INTERACTION_STATES.SHOWING_PROGRESS || interactionState === INTERACTION_STATES.OFFERING_CHOICES || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && (\n-                 <div style={{ marginTop: '20px', border: '1px solid #ccc', padding: '15px', background: '#f9f9f9' }}>\n-                     <h2>Tu Progreso</h2>\n-                     {userProgress && ( // Asegurarse de que userProgress no sea null\n-                         <div>\n-                             <p>Total resueltos: {userProgress.total_solved}</p>\n-                             <p>Promedio general: {userProgress.overall_average_grade !== null ? userProgress.overall_average_grade.toFixed(2) : 'N/A'}</p>\n-                             <ul>\n-                                 {Object.entries(userProgress.progress_by_difficulty).map(([level, data]) => (\n-                                     <li key={level}>\n-                                         {level.charAt(0).toUpperCase() + level.slice(1)}: {data.solved_count} resueltos {data.solved_count > 0 ? `(Promedio: ${data.average_grade.toFixed(2)})` : ''}\n-                                     </li>\n-                                 ))}\n-                             </ul>\n-                         </div>\n-                     )}\n-                 </div>\n-             )}\n-\n-             {/* Mostrar Problema Actual - Solo si ha sido cargado y el estado lo permite */}\n-            {currentProblem && (interactionState === INTERACTION_STATES.PRESENTING_PROBLEM || interactionState === INTERACTION_STATES.RECORDING_ANSWER || interactionState === INTERACTION_STATES.PROCESSING_ANSWER || interactionState === INTERACTION_STATES.SHOWING_FEEDBACK || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && (\n-                <div style={{ marginTop: '20px', border: '2px solid blue', padding: '15px', background: '#eaf6ff' }}>\n-                    <h3>Problema de Lógica (Dificultad: {currentProblem.difficulty})</h3>\n-                    <p style={{ whiteSpace: 'pre-wrap' }}>{currentProblem.text}</p>\n-                </div>\n-            )}\n-\n-            {/* Integrar tu componente VoiceRecognition */}\n-            {/* Mostrarlo solo en los estados donde esperamos INPUT de voz del usuario */}\n-             {(interactionState === INTERACTION_STATES.OFFERING_CHOICES ||\n-               interactionState === INTERACTION_STATES.ASKING_DIFFICULTY ||\n-               interactionState === INTERACTION_STATES.PRESENTING_PROBLEM ||\n-               interactionState === INTERACTION_STATES.RECORDING_ANSWER ||\n-               interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES ||\n-               interactionState === INTERACTION_STATES.ERROR\n-             ) && !authLoading && ( // Añadir !authLoading para evitar mostrarlo mientras carga auth\n-            // Dentro del return de LogicSectionPage.jsx\n-\n-            <div style={{marginTop: '25px'}}>\n-                <p style={{textAlign: 'center', fontWeight:'bold', marginBottom:'10px'}}>Control de Voz:</p>\n-                <VoiceRecognition\n-                    onTextRecognized={handleTextRecognized}\n-                    isLoadingResponse={interactionState === INTERACTION_STATES.PROCESSING_ANSWER}\n-                    onListeningChange={handleListeningStatusChange}\n-                    // Eliminamos la key dinámica que causa el remontaje\n-                />\n-                 {recognizedText && <p style={{marginTop: '10px', fontSize: '0.9em', color: '#555'}}>Texto reconocido: \"{recognizedText}\"</p>}\n-                 {backendError && <p style={{ color: 'orange', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>}\n-             </div>\n-             )}\n-\n-             {/* Mostrar el feedback del backend (análisis/calificación) si está disponible */}\n-             {backendFeedback && (interactionState === INTERACTION_STATES.SHOWING_FEEDBACK || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && (\n-                 <div style={{ marginTop: '20px', border: '2px solid green', padding: '15px', background: '#eafaf9' }}>\n-                     <h3>Feedback del Asistente:</h3>\n-                     <p style={{ whiteSpace: 'pre-wrap' }}>{backendFeedback}</p>\n-                 </div>\n-             )}\n-             {/* Mostrar error específico si es el de \"no detectó voz\" */}\n-              {(interactionState === INTERACTION_STATES.PRESENTING_PROBLEM || interactionState === INTERACTION_STATES.RECORDING_ANSWER || interactionState === INTERACTION_STATES.PROCESSING_ANSWER) && backendError === \"No se detectó voz. Intenta hablar más claro.\" && (\n-                   <p style={{ color: 'orange', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>\n-              )}\n-             {/* Mostrar error general de submit/backend si existe y no es el de voz vacía */}\n-             {(interactionState === INTERACTION_STATES.PROCESSING_ANSWER || interactionState === INTERACTION_STATES.SHOWING_FEEDBACK || interactionState === INTERACTION_STATES.POST_FEEDBACK_CHOICES || interactionState === INTERACTION_STATES.ERROR) && backendError && backendError !== \"No se detectó voz. Intenta hablar más claro.\" && (\n-                 <p style={{ color: 'red', fontWeight: 'bold', marginTop: '10px' }}>{backendError}</p>\n-            )}\n-\n-\n-        </div>\n-      </main>\n-    </div>\n-  );\n-};\n-\n export default LogicSectionPage;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1747004577381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,107 +61,92 @@\n \n // --- Helper para leer texto por voz (llamando al backend) ---\n // Esta función se define FUERA del componente principal.\n // Devuelve el objeto Audio si la reproducción se inicia correctamente.\n+// Dentro de LogicSectionPage.jsx (o donde definiste speakText)\n+\n const speakText = async (text, onEndCallback = null) => {\n-    if (!text) {\n-        console.warn(\"[speakText] Llamada con texto vacío. Ignorando.\");\n-         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n-        return null; // Devolver null si no se intenta reproducir\n+    if (!text || typeof text !== 'string' || text.trim() === '') {\n+        console.warn(\"[speakText] Llamada con texto vacío.\");\n+        if (onEndCallback) onEndCallback(); return null;\n     }\n-    // Cancelar síntesis previa del navegador (la que usábamos antes, por si acaso)\n-    // SpeechSynthesis.cancel(); // Descomentar si antes usabas fallback TTS del navegador\n-\n-    console.log(`[speakText] Solicitando voz al backend para: \"${text.substring(0, Math.min(text.length, 50))}\"...`);\n-\n-    // URL del endpoint de backend que genera voz.\n-    // Debe coincidir con la API_BASE_URL de tu api.js + el endpoint /tts.\n-    const API_TTS_URL = \"http://127.0.0.1:8003/auth/api/logic/tts\"; // <-- ¡AJUSTA ESTA URL!\n-\n-    const token = sessionStorage.getItem('access_token'); // Obtener token directamente de sessionStorage\n+    console.log(`[speakText] Solicitando voz para: \"${text.substring(0, 50)}...\"`);\n+    const API_TTS_URL = \"http://127.0.0.1:8003/auth/api/logic/tts\";\n+    const token = sessionStorage.getItem('access_token') || localStorage.getItem('token');\n     if (!token) {\n-         console.error(\"[speakText] ERROR: No se encontró token en sessionStorage['access_token'] para la llamada TTS al backend.\");\n-         // Opcional: Usar un TTS de fallback del navegador si no hay token o falla el backend\n-         // speakTextFallback(text, onEndCallback); // Necesitarías implementar esta función\n-         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n-         return null; // Devolver null si no hay token\n+        console.error(\"[speakText] No hay token para TTS.\");\n+        if (onEndCallback) onEndCallback(); return null;\n     }\n \n-    // console.log(\"[speakText] Token encontrado en sessionStorage. Haciendo fetch a backend TTS.\"); // Redundante con log anterior\n+    let audioUrl = null; // Definir fuera para que esté disponible en el catch final del fetch\n+    let audioContextForCleanup = null; // Para guardar la referencia del audio\n \n-\n     try {\n         const response = await fetch(API_TTS_URL, {\n             method: 'POST',\n-            headers: {\n-                'Content-Type': 'application/json', // El backend /tts espera JSON {\"text\": ...}\n-                'Authorization': `Bearer ${token}`, // Adjuntar el token\n-            },\n-            body: JSON.stringify({ text: text }), // Enviar el texto en un cuerpo JSON\n+            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },\n+            body: JSON.stringify({ text: text }),\n         });\n-\n-        console.log(`[speakText] Fetch completado. Status: ${response.status} ${response.statusText}`);\n-\n+        console.log(`[speakText] Fetch TTS: ${response.status} ${response.statusText}`);\n         if (!response.ok) {\n-            let errorDetail = `Backend TTS error: ${response.status} ${response.statusText}`;\n-             let errorBody = null;\n-             try {\n-                 errorBody = await response.json();\n-                 console.error(\"[speakText] Backend Error Body (Parsed):\", errorBody); // Log el cuerpo de error\n-                 if (errorBody && errorBody.detail) {\n-                     if (Array.isArray(errorBody.detail)) { errorDetail += \" - Validation Errors: \" + errorBody.detail.map(err => `${err.loc.join('.')}: ${err.msg}`).join(\"; \"); }\n-                     else { errorDetail += ` - Detail: ${errorBody.detail}`; }\n-                 } else { errorDetail += \" - No detailed error body provided.\"; }\n-             } catch (e) { console.error(\"[speakText] Failed to parse backend error body as JSON.\", e); }\n-            console.error(\"[speakText] ERROR: Llamada al backend TTS falló.\", errorDetail);\n-            // Opcional: Usar un TTS de fallback del navegador si falla el backend\n-            // speakTextFallback(text, onEndCallback);\n-             if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n-            return null; // Devolver null si la llamada falló\n+            // ... (tu manejo de error de fetch como estaba) ...\n+            let errorDetail = `Backend TTS error: ${response.status}`;\n+            try { const errBody = await response.json(); errorDetail += ` - ${errBody.detail || JSON.stringify(errBody)}`; } catch (e) {}\n+            console.error(\"[speakText] ERROR TTS:\", errorDetail);\n+            if (onEndCallback) onEndCallback();\n+            return null;\n         }\n-\n-        console.log(\"[speakText] Backend TTS respondió OK. Convirtiendo respuesta a Blob.\");\n         const audioBlob = await response.blob();\n-        const audioUrl = URL.createObjectURL(audioBlob);\n-\n-        console.log(\"[speakText] Blob creado. Reproduciendo audio.\");\n+        audioUrl = URL.createObjectURL(audioBlob); // Asignar a la variable externa\n         const audio = new Audio(audioUrl);\n+        audioContextForCleanup = audio; // Guardar referencia\n \n-        // Configurar el callback para cuando termine la reproducción\n-        audio.onended = () => {\n-            console.log(\"[speakText] Audio playback finished.\");\n-            URL.revokeObjectURL(audioUrl); // Limpiar el Blob URL después de usarlo\n+        let hasEndedOrErrored = false; // Flag para evitar doble callback\n+\n+        const cleanupAndCallback = () => {\n+            if (hasEndedOrErrored) return;\n+            hasEndedOrErrored = true;\n+            console.log(\"[speakText] cleanupAndCallback: Revocando URL del Blob:\", audioUrl);\n+            if (audioUrl) URL.revokeObjectURL(audioUrl);\n             if (onEndCallback && typeof onEndCallback === 'function') {\n-                 onEndCallback(); // Ejecutar el callback al finalizar\n+                onEndCallback();\n             }\n         };\n \n-         // Configurar manejo de errores de reproducción de audio\n+        audio.onended = () => {\n+            console.log(\"[speakText] Audio playback finished via onended.\");\n+            cleanupAndCallback();\n+        };\n+\n         audio.onerror = (e) => {\n-             console.error(\"[speakText] ERROR: Audio playback error.\", e);\n-             URL.revokeObjectURL(audioUrl); // Limpiar el Blob URL en caso de error\n-              if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n+            console.error(\"[speakText] ERROR: Audio playback error via onerror.\", e);\n+            if (e.target && e.target.error) {\n+                 console.error(\"[speakText] Detalle error Audio: Code=\", e.target.error.code, \"Message=\", e.target.error.message);\n+            }\n+            cleanupAndCallback();\n         };\n \n-\n         // Reproducir el audio\n-        audio.play().catch(playError => {\n-            // play() retorna una Promesa, capturar errores de reproducción (ej. navegador bloquea autoplay)\n-             console.error(\"[speakText] ERROR: Error starting audio playback.\", playError);\n-             // Limpiar el Blob URL\n-             URL.revokeObjectURL(audioUrl);\n-              if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n-        });\n+        console.log(\"[speakText] Intentando audio.play() para:\", audioUrl);\n+        await audio.play(); // Usar await aquí para capturar el error de forma más directa\n+        console.log(\"[speakText] audio.play() promesa resuelta (reproducción probablemente iniciada).\");\n+        // No llamar cleanupAndCallback aquí, se llamará en onended o onerror\n \n-        return audio; // Devolver el objeto Audio si la reproducción se inicia (no garantiza que termine)\n+        return audio; // Devolver el objeto Audio\n \n-    } catch (error) {\n-        // Este catch captura errores de red o errores lanzados antes de response.ok\n-        console.error(\"[speakText] ERROR: Error during fetch or initial processing.\", error);\n-        // Opcional: Usar un TTS de fallback del navegador si falla la llamada\n-        // speakTextFallback(text, onEndCallback);\n-         if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); } // Ejecutar callback incluso en error\n-        return null; // Devolver null si hubo un error en el fetch/proceso inicial\n+    } catch (error) { // Este catch ahora manejará errores de fetch Y errores de audio.play()\n+        console.error(\"[speakText] ERROR GENERAL en speakText (fetch, blob, o play):\", error);\n+        // Loguear detalles del error si es un error de reproducción\n+        if (error && error.name && error.message) {\n+             console.error(`[speakText] Detalles del playError: Name=${error.name}, Message=${error.message}`);\n+        }\n+        // Asegurar limpieza si audioUrl fue creado\n+        if (audioUrl && audioContextForCleanup) { // Usar audioContextForCleanup para evitar problemas de scope\n+            console.log(\"[speakText] Limpiando Blob URL en catch general:\", audioUrl);\n+            URL.revokeObjectURL(audioUrl);\n+        }\n+        if (onEndCallback && typeof onEndCallback === 'function') { onEndCallback(); }\n+        return null;\n     }\n };\n \n // Helper para manejar errores de flujo de interacción y pasar al estado ERROR (definida fuera)\n"
                }
            ],
            "date": 1746061173230,
            "name": "Commit-0",
            "content": "// 1. Importa React\nimport React from 'react';\n\n// 2. Define el componente como una función\n//    (El nombre de la función debe empezar con mayúscula)\nconst MiComponenteBasico = () => {\n  // 3. La función devuelve JSX (código que parece HTML)\n  return (\n    <div>\n      <h1>Hola desde mi componente básico!</h1>\n      <p>Este es un párrafo simple.</p>\n    </div>\n  );\n};\n\n// 4. Exporta el componente para poder usarlo en otras partes de tu aplicación\nexport default MiComponenteBasico;"
        }
    ]
}